{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { useMemo, useReducer } from 'react';\nimport { SendingStatus } from '@sendbird/chat/message';\nimport { getMessageUniqId, isMyMessage, isNewMessage, isSendableMessage } from '../../utils/message.js';\nexport function arrayToMapWithGetter(arr, getSelector) {\n  return arr.reduce((accum, curr) => {\n    const _key = getSelector(curr);\n    accum[_key] = curr;\n    return accum;\n  }, {});\n}\nconst defaultReducer = (_a, action) => {\n  var draft = __rest(_a, []);\n  switch (action.type) {\n    case 'update_initialized':\n      {\n        draft['initialized'] = action.value.status;\n        return draft;\n      }\n    case 'update_refreshing':\n      {\n        draft['refreshing'] = action.value.status;\n        return draft;\n      }\n    case 'update_loading':\n      {\n        draft['loading'] = action.value.status;\n        return draft;\n      }\n    case 'update_has_previous':\n      {\n        draft['hasPreviousMessages'] = action.value.status;\n        return draft;\n      }\n    case 'update_has_next':\n      {\n        draft['hasNextMessages'] = action.value.status;\n        return draft;\n      }\n    case 'update_messages':\n      {\n        const userId = action.value.currentUserId;\n        if (action.value.clearBeforeAction) {\n          draft['messageMap'] = messagesToObject(action.value.messages);\n        } else {\n          // Filtering meaningless message updates\n          const nextMessages = action.value.messages.filter(next => {\n            var _a;\n            if (isMyMessage(next, userId)) {\n              const prev = (_a = draft['messageMap'][next.reqId]) !== null && _a !== void 0 ? _a : draft['messageMap'][next.messageId];\n              if (isMyMessage(prev, userId)) {\n                const shouldUpdate = shouldUpdateMessage(prev, next);\n                if (shouldUpdate) {\n                  // Remove existing messages before update to prevent duplicate display\n                  delete draft['messageMap'][prev.reqId];\n                  delete draft['messageMap'][prev.messageId];\n                }\n                return shouldUpdate;\n              }\n            }\n            return true;\n          });\n          const obj = messagesToObject(nextMessages);\n          draft['messageMap'] = Object.assign(Object.assign({}, draft['messageMap']), obj);\n        }\n        return draft;\n      }\n    case 'update_new_messages':\n      {\n        const userId = action.value.currentUserId;\n        const newMessages = action.value.messages.filter(it => isNewMessage(it, userId));\n        if (action.value.clearBeforeAction) {\n          draft['newMessageMap'] = arrayToMapWithGetter(newMessages, getMessageUniqId);\n        } else {\n          // Remove existing messages before update to prevent duplicate display\n          const messageKeys = newMessages.map(it => it.messageId);\n          messageKeys.forEach(key => delete draft['newMessageMap'][key]);\n          draft['newMessageMap'] = Object.assign(Object.assign({}, draft['newMessageMap']), arrayToMapWithGetter(newMessages, getMessageUniqId));\n        }\n        return draft;\n      }\n    case 'delete_messages':\n    case 'delete_new_messages':\n      {\n        const key = action.type === 'delete_messages' ? 'messageMap' : 'newMessageMap';\n        draft[key] = Object.assign({}, draft[key]);\n        action.value.messageIds.forEach(msgId => {\n          const message = draft[key][msgId];\n          if (message) {\n            if (isSendableMessage(message)) delete draft[key][message.reqId];\n            delete draft[key][message.messageId];\n          }\n        });\n        action.value.reqIds.forEach(reqId => {\n          const message = draft[key][reqId];\n          if (message) {\n            if (isSendableMessage(message)) delete draft[key][message.reqId];\n            delete draft[key][message.messageId];\n          }\n        });\n        return draft;\n      }\n  }\n};\nconst messagesToObject = messages => {\n  return messages.reduce((accum, curr) => {\n    if (isSendableMessage(curr)) {\n      accum[curr.reqId] = curr;\n      if (curr.sendingStatus === SendingStatus.SUCCEEDED) {\n        accum[curr.messageId] = curr;\n      }\n    } else {\n      accum[curr.messageId] = curr;\n    }\n    return accum;\n  }, {});\n};\nconst shouldUpdateMessage = (prev, next) => {\n  // message data update (e.g. reactions)\n  if (prev.sendingStatus === SendingStatus.SUCCEEDED) return next.sendingStatus === SendingStatus.SUCCEEDED;\n  // message sending status update\n  return prev.sendingStatus !== next.sendingStatus;\n};\nconst getOldestMessageTimeStamp = messages => {\n  return messages.reduce((accum, curr) => {\n    return Math.min(accum, curr.createdAt);\n  }, Number.MAX_SAFE_INTEGER);\n};\nconst getLatestMessageTimeStamp = messages => {\n  return messages.reduce((accum, curr) => {\n    return Math.max(accum, curr.createdAt);\n  }, Number.MIN_SAFE_INTEGER);\n};\nexport const useChannelThreadMessagesReducer = function () {\n  let sortComparator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultMessageComparator;\n  const [{\n    initialized,\n    loading,\n    refreshing,\n    hasPreviousMessages,\n    hasNextMessages,\n    messageMap,\n    newMessageMap\n  }, dispatch] = useReducer(defaultReducer, {\n    initialized: false,\n    loading: true,\n    refreshing: false,\n    hasPreviousMessages: false,\n    hasNextMessages: false,\n    messageMap: {},\n    newMessageMap: {}\n  });\n  const updateMessages = (messages, clearBeforeAction, currentUserId) => {\n    dispatch({\n      type: 'update_messages',\n      value: {\n        messages,\n        clearBeforeAction,\n        currentUserId\n      }\n    });\n  };\n  const deleteMessages = (messageIds, reqIds) => {\n    dispatch({\n      type: 'delete_messages',\n      value: {\n        messageIds,\n        reqIds\n      }\n    });\n  };\n  const updateNewMessages = (messages, clearBeforeAction, currentUserId) => {\n    dispatch({\n      type: 'update_new_messages',\n      value: {\n        messages,\n        clearBeforeAction,\n        currentUserId\n      }\n    });\n  };\n  const deleteNewMessages = (messageIds, reqIds) => {\n    dispatch({\n      type: 'delete_new_messages',\n      value: {\n        messageIds,\n        reqIds\n      }\n    });\n  };\n  const updateInitialized = status => {\n    dispatch({\n      type: 'update_initialized',\n      value: {\n        status\n      }\n    });\n  };\n  const updateLoading = status => {\n    dispatch({\n      type: 'update_loading',\n      value: {\n        status\n      }\n    });\n  };\n  const updateRefreshing = status => {\n    dispatch({\n      type: 'update_refreshing',\n      value: {\n        status\n      }\n    });\n  };\n  const updateHasPreviousMessages = status => {\n    dispatch({\n      type: 'update_has_previous',\n      value: {\n        status\n      }\n    });\n  };\n  const updateHasNextMessages = status => {\n    dispatch({\n      type: 'update_has_next',\n      value: {\n        status\n      }\n    });\n  };\n  const newMessages = Object.values(newMessageMap);\n  const messages = useMemo(() => Array.from(new Set(Object.values(messageMap))).sort(sortComparator), [messageMap]);\n  const oldestMessageTimeStamp = getOldestMessageTimeStamp(messages);\n  const latestMessageTimeStamp = getLatestMessageTimeStamp(messages);\n  return {\n    updateInitialized,\n    updateLoading,\n    updateRefreshing,\n    updateMessages,\n    deleteMessages,\n    updateHasPreviousMessages,\n    updateHasNextMessages,\n    initialized,\n    loading,\n    refreshing,\n    hasPreviousMessages,\n    hasNextMessages,\n    oldestMessageTimeStamp,\n    latestMessageTimeStamp,\n    messages,\n    newMessages,\n    updateNewMessages,\n    deleteNewMessages\n  };\n};\nconst LARGE_OFFSET = Math.floor(Number.MAX_SAFE_INTEGER / 10);\nexport function defaultMessageComparator(a, b) {\n  let aStatusOffset = 0;\n  let bStatusOffset = 0;\n  if (isSendableMessage(a) && a.sendingStatus !== 'succeeded') aStatusOffset = LARGE_OFFSET;\n  if (isSendableMessage(b) && b.sendingStatus !== 'succeeded') bStatusOffset = LARGE_OFFSET;\n  return a.createdAt + aStatusOffset - (b.createdAt + bStatusOffset);\n}","map":{"version":3,"names":["__rest","s","e","t","p","Object","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","useMemo","useReducer","SendingStatus","getMessageUniqId","isMyMessage","isNewMessage","isSendableMessage","arrayToMapWithGetter","arr","getSelector","reduce","accum","curr","_key","defaultReducer","_a","action","draft","type","value","status","userId","currentUserId","clearBeforeAction","messagesToObject","messages","nextMessages","filter","next","prev","reqId","messageId","shouldUpdate","shouldUpdateMessage","obj","assign","newMessages","it","messageKeys","map","forEach","key","messageIds","msgId","message","reqIds","sendingStatus","SUCCEEDED","getOldestMessageTimeStamp","Math","min","createdAt","Number","MAX_SAFE_INTEGER","getLatestMessageTimeStamp","max","MIN_SAFE_INTEGER","useChannelThreadMessagesReducer","sortComparator","arguments","undefined","defaultMessageComparator","initialized","loading","refreshing","hasPreviousMessages","hasNextMessages","messageMap","newMessageMap","dispatch","updateMessages","deleteMessages","updateNewMessages","deleteNewMessages","updateInitialized","updateLoading","updateRefreshing","updateHasPreviousMessages","updateHasNextMessages","values","Array","from","Set","sort","oldestMessageTimeStamp","latestMessageTimeStamp","LARGE_OFFSET","floor","a","b","aStatusOffset","bStatusOffset"],"sources":["D:/ebgbot/node_modules/@sendbird/uikit-react/node_modules/@sendbird/uikit-tools/dist/esm/hooks/useGroupChannelThreadMessages/reducer.js"],"sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { useMemo, useReducer } from 'react';\nimport { SendingStatus } from '@sendbird/chat/message';\nimport { getMessageUniqId, isMyMessage, isNewMessage, isSendableMessage } from '../../utils/message.js';\nexport function arrayToMapWithGetter(arr, getSelector) {\n    return arr.reduce((accum, curr) => {\n        const _key = getSelector(curr);\n        accum[_key] = curr;\n        return accum;\n    }, {});\n}\nconst defaultReducer = (_a, action) => {\n    var draft = __rest(_a, []);\n    switch (action.type) {\n        case 'update_initialized': {\n            draft['initialized'] = action.value.status;\n            return draft;\n        }\n        case 'update_refreshing': {\n            draft['refreshing'] = action.value.status;\n            return draft;\n        }\n        case 'update_loading': {\n            draft['loading'] = action.value.status;\n            return draft;\n        }\n        case 'update_has_previous': {\n            draft['hasPreviousMessages'] = action.value.status;\n            return draft;\n        }\n        case 'update_has_next': {\n            draft['hasNextMessages'] = action.value.status;\n            return draft;\n        }\n        case 'update_messages': {\n            const userId = action.value.currentUserId;\n            if (action.value.clearBeforeAction) {\n                draft['messageMap'] = messagesToObject(action.value.messages);\n            }\n            else {\n                // Filtering meaningless message updates\n                const nextMessages = action.value.messages.filter((next) => {\n                    var _a;\n                    if (isMyMessage(next, userId)) {\n                        const prev = (_a = draft['messageMap'][next.reqId]) !== null && _a !== void 0 ? _a : draft['messageMap'][next.messageId];\n                        if (isMyMessage(prev, userId)) {\n                            const shouldUpdate = shouldUpdateMessage(prev, next);\n                            if (shouldUpdate) {\n                                // Remove existing messages before update to prevent duplicate display\n                                delete draft['messageMap'][prev.reqId];\n                                delete draft['messageMap'][prev.messageId];\n                            }\n                            return shouldUpdate;\n                        }\n                    }\n                    return true;\n                });\n                const obj = messagesToObject(nextMessages);\n                draft['messageMap'] = Object.assign(Object.assign({}, draft['messageMap']), obj);\n            }\n            return draft;\n        }\n        case 'update_new_messages': {\n            const userId = action.value.currentUserId;\n            const newMessages = action.value.messages.filter((it) => isNewMessage(it, userId));\n            if (action.value.clearBeforeAction) {\n                draft['newMessageMap'] = arrayToMapWithGetter(newMessages, getMessageUniqId);\n            }\n            else {\n                // Remove existing messages before update to prevent duplicate display\n                const messageKeys = newMessages.map((it) => it.messageId);\n                messageKeys.forEach((key) => delete draft['newMessageMap'][key]);\n                draft['newMessageMap'] = Object.assign(Object.assign({}, draft['newMessageMap']), arrayToMapWithGetter(newMessages, getMessageUniqId));\n            }\n            return draft;\n        }\n        case 'delete_messages':\n        case 'delete_new_messages': {\n            const key = action.type === 'delete_messages' ? 'messageMap' : 'newMessageMap';\n            draft[key] = Object.assign({}, draft[key]);\n            action.value.messageIds.forEach((msgId) => {\n                const message = draft[key][msgId];\n                if (message) {\n                    if (isSendableMessage(message))\n                        delete draft[key][message.reqId];\n                    delete draft[key][message.messageId];\n                }\n            });\n            action.value.reqIds.forEach((reqId) => {\n                const message = draft[key][reqId];\n                if (message) {\n                    if (isSendableMessage(message))\n                        delete draft[key][message.reqId];\n                    delete draft[key][message.messageId];\n                }\n            });\n            return draft;\n        }\n    }\n};\nconst messagesToObject = (messages) => {\n    return messages.reduce((accum, curr) => {\n        if (isSendableMessage(curr)) {\n            accum[curr.reqId] = curr;\n            if (curr.sendingStatus === SendingStatus.SUCCEEDED) {\n                accum[curr.messageId] = curr;\n            }\n        }\n        else {\n            accum[curr.messageId] = curr;\n        }\n        return accum;\n    }, {});\n};\nconst shouldUpdateMessage = (prev, next) => {\n    // message data update (e.g. reactions)\n    if (prev.sendingStatus === SendingStatus.SUCCEEDED)\n        return next.sendingStatus === SendingStatus.SUCCEEDED;\n    // message sending status update\n    return prev.sendingStatus !== next.sendingStatus;\n};\nconst getOldestMessageTimeStamp = (messages) => {\n    return messages.reduce((accum, curr) => {\n        return Math.min(accum, curr.createdAt);\n    }, Number.MAX_SAFE_INTEGER);\n};\nconst getLatestMessageTimeStamp = (messages) => {\n    return messages.reduce((accum, curr) => {\n        return Math.max(accum, curr.createdAt);\n    }, Number.MIN_SAFE_INTEGER);\n};\nexport const useChannelThreadMessagesReducer = (sortComparator = defaultMessageComparator) => {\n    const [{ initialized, loading, refreshing, hasPreviousMessages, hasNextMessages, messageMap, newMessageMap }, dispatch,] = useReducer(defaultReducer, {\n        initialized: false,\n        loading: true,\n        refreshing: false,\n        hasPreviousMessages: false,\n        hasNextMessages: false,\n        messageMap: {},\n        newMessageMap: {},\n    });\n    const updateMessages = (messages, clearBeforeAction, currentUserId) => {\n        dispatch({ type: 'update_messages', value: { messages, clearBeforeAction, currentUserId } });\n    };\n    const deleteMessages = (messageIds, reqIds) => {\n        dispatch({ type: 'delete_messages', value: { messageIds, reqIds } });\n    };\n    const updateNewMessages = (messages, clearBeforeAction, currentUserId) => {\n        dispatch({ type: 'update_new_messages', value: { messages, clearBeforeAction, currentUserId } });\n    };\n    const deleteNewMessages = (messageIds, reqIds) => {\n        dispatch({ type: 'delete_new_messages', value: { messageIds, reqIds } });\n    };\n    const updateInitialized = (status) => {\n        dispatch({ type: 'update_initialized', value: { status } });\n    };\n    const updateLoading = (status) => {\n        dispatch({ type: 'update_loading', value: { status } });\n    };\n    const updateRefreshing = (status) => {\n        dispatch({ type: 'update_refreshing', value: { status } });\n    };\n    const updateHasPreviousMessages = (status) => {\n        dispatch({ type: 'update_has_previous', value: { status } });\n    };\n    const updateHasNextMessages = (status) => {\n        dispatch({ type: 'update_has_next', value: { status } });\n    };\n    const newMessages = Object.values(newMessageMap);\n    const messages = useMemo(() => Array.from(new Set(Object.values(messageMap))).sort(sortComparator), [messageMap]);\n    const oldestMessageTimeStamp = getOldestMessageTimeStamp(messages);\n    const latestMessageTimeStamp = getLatestMessageTimeStamp(messages);\n    return {\n        updateInitialized,\n        updateLoading,\n        updateRefreshing,\n        updateMessages,\n        deleteMessages,\n        updateHasPreviousMessages,\n        updateHasNextMessages,\n        initialized,\n        loading,\n        refreshing,\n        hasPreviousMessages,\n        hasNextMessages,\n        oldestMessageTimeStamp,\n        latestMessageTimeStamp,\n        messages,\n        newMessages,\n        updateNewMessages,\n        deleteNewMessages,\n    };\n};\nconst LARGE_OFFSET = Math.floor(Number.MAX_SAFE_INTEGER / 10);\nexport function defaultMessageComparator(a, b) {\n    let aStatusOffset = 0;\n    let bStatusOffset = 0;\n    if (isSendableMessage(a) && a.sendingStatus !== 'succeeded')\n        aStatusOffset = LARGE_OFFSET;\n    if (isSendableMessage(b) && b.sendingStatus !== 'succeeded')\n        bStatusOffset = LARGE_OFFSET;\n    return a.createdAt + aStatusOffset - (b.createdAt + bStatusOffset);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}