{"ast":null,"code":"import { useCallback, useEffect } from 'react';\nimport { ReplyType } from '@sendbird/chat/message';\nimport { s as scrollIntoLast, d as scrollToRenderedMessage } from './bundle-CMLImr6T.js';\nimport { R as RESET_MESSAGES, M as MESSAGE_LIST_PARAMS_CHANGED, F as FETCH_INITIAL_MESSAGES_START, a as FETCH_INITIAL_MESSAGES_SUCCESS, b as FETCH_INITIAL_MESSAGES_FAILURE } from './bundle-CpjASiz4.js';\nimport './bundle-CveCFQYP.js';\nimport { c as SCROLL_BOTTOM_DELAY_FOR_FETCH } from './bundle-DCMGp6rH.js';\n\n// For legacy\n// These are not used for collections(GroupChannel)\nvar PREV_RESULT_SIZE = 30;\nvar NEXT_RESULT_SIZE = 15;\nfunction useInitialMessagesFetch(_a, _b) {\n  var currentGroupChannel = _a.currentGroupChannel,\n    initialTimeStamp = _a.initialTimeStamp,\n    userFilledMessageListQuery = _a.userFilledMessageListQuery,\n    replyType = _a.replyType,\n    setIsScrolled = _a.setIsScrolled;\n  var logger = _b.logger,\n    scrollRef = _b.scrollRef,\n    messagesDispatcher = _b.messagesDispatcher;\n  var channelUrl = currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url;\n  /**\n   * useCallback(() => {}, [currentGroupChannel]) was buggy, that is why we did\n   * const channelUrl = currentGroupChannel && currentGroupChannel.url;\n   * useCallback(() => {}, [channelUrl])\n   * Again, this hook is supposed to execute when currentGroupChannel changes\n   * The 'channelUrl' here is not the same memory reference from Conversation.props\n   */\n  var fetchMessages = useCallback(function () {\n    logger.info('Channel useInitialMessagesFetch: Setup started', currentGroupChannel);\n    setIsScrolled(false);\n    messagesDispatcher({\n      type: RESET_MESSAGES,\n      payload: null\n    });\n    if (currentGroupChannel && (currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.getMessagesByTimestamp)) {\n      var messageListParams_1 = {\n        prevResultSize: PREV_RESULT_SIZE,\n        isInclusive: true,\n        includeReactions: true,\n        includeMetaArray: true\n      };\n      if (initialTimeStamp) {\n        messageListParams_1.nextResultSize = NEXT_RESULT_SIZE;\n      }\n      if (replyType === 'QUOTE_REPLY' || replyType === 'THREAD') {\n        messageListParams_1.includeThreadInfo = true;\n        messageListParams_1.includeParentMessageInfo = true;\n        messageListParams_1.replyType = ReplyType.ONLY_REPLY_TO_CHANNEL;\n      }\n      if (userFilledMessageListQuery) {\n        Object.keys(userFilledMessageListQuery).forEach(function (key) {\n          // @ts-ignore\n          messageListParams_1[key] = userFilledMessageListQuery[key];\n        });\n      }\n      if (replyType && (replyType === 'QUOTE_REPLY' || replyType === 'THREAD') || userFilledMessageListQuery) {\n        logger.info('Channel useInitialMessagesFetch: Setup messageListParams', messageListParams_1);\n        messagesDispatcher({\n          type: MESSAGE_LIST_PARAMS_CHANGED,\n          payload: messageListParams_1\n        });\n      }\n      logger.info('Channel: Fetching messages', {\n        currentGroupChannel: currentGroupChannel,\n        userFilledMessageListQuery: userFilledMessageListQuery\n      });\n      messagesDispatcher({\n        type: FETCH_INITIAL_MESSAGES_START,\n        payload: null\n      });\n      currentGroupChannel.getMessagesByTimestamp(initialTimeStamp || new Date().getTime(), messageListParams_1).then(function (messages) {\n        messagesDispatcher({\n          type: FETCH_INITIAL_MESSAGES_SUCCESS,\n          payload: {\n            currentGroupChannel: currentGroupChannel,\n            messages: messages\n          }\n        });\n      }).catch(function (error) {\n        logger.error('Channel: Fetching messages failed', error);\n        messagesDispatcher({\n          type: FETCH_INITIAL_MESSAGES_FAILURE,\n          payload: {\n            currentGroupChannel: currentGroupChannel\n          }\n        });\n      }).finally(function () {\n        if (!initialTimeStamp) {\n          setTimeout(function () {\n            return scrollIntoLast(0, scrollRef, setIsScrolled);\n          }, SCROLL_BOTTOM_DELAY_FOR_FETCH);\n        } else {\n          setTimeout(function () {\n            scrollToRenderedMessage(scrollRef, initialTimeStamp, setIsScrolled);\n          }, 500);\n        }\n      });\n    }\n  }, [channelUrl, userFilledMessageListQuery, initialTimeStamp]);\n  useEffect(function () {\n    fetchMessages();\n  }, [fetchMessages]);\n  return fetchMessages;\n}\nexport { NEXT_RESULT_SIZE as N, PREV_RESULT_SIZE as P, useInitialMessagesFetch as u };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import { useCallback, useEffect } from 'react';\nimport { ReplyType } from '@sendbird/chat/message';\nimport { s as scrollIntoLast, d as scrollToRenderedMessage } from './bundle-CMLImr6T.js';\nimport { R as RESET_MESSAGES, M as MESSAGE_LIST_PARAMS_CHANGED, F as FETCH_INITIAL_MESSAGES_START, a as FETCH_INITIAL_MESSAGES_SUCCESS, b as FETCH_INITIAL_MESSAGES_FAILURE } from './bundle-CpjASiz4.js';\nimport './bundle-CveCFQYP.js';\nimport { c as SCROLL_BOTTOM_DELAY_FOR_FETCH } from './bundle-DCMGp6rH.js';\n\n// For legacy\n// These are not used for collections(GroupChannel)\nvar PREV_RESULT_SIZE = 30;\nvar NEXT_RESULT_SIZE = 15;\n\nfunction useInitialMessagesFetch(_a, _b) {\n    var currentGroupChannel = _a.currentGroupChannel, initialTimeStamp = _a.initialTimeStamp, userFilledMessageListQuery = _a.userFilledMessageListQuery, replyType = _a.replyType, setIsScrolled = _a.setIsScrolled;\n    var logger = _b.logger, scrollRef = _b.scrollRef, messagesDispatcher = _b.messagesDispatcher;\n    var channelUrl = currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url;\n    /**\n     * useCallback(() => {}, [currentGroupChannel]) was buggy, that is why we did\n     * const channelUrl = currentGroupChannel && currentGroupChannel.url;\n     * useCallback(() => {}, [channelUrl])\n     * Again, this hook is supposed to execute when currentGroupChannel changes\n     * The 'channelUrl' here is not the same memory reference from Conversation.props\n     */\n    var fetchMessages = useCallback(function () {\n        logger.info('Channel useInitialMessagesFetch: Setup started', currentGroupChannel);\n        setIsScrolled(false);\n        messagesDispatcher({\n            type: RESET_MESSAGES,\n            payload: null,\n        });\n        if (currentGroupChannel && (currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.getMessagesByTimestamp)) {\n            var messageListParams_1 = {\n                prevResultSize: PREV_RESULT_SIZE,\n                isInclusive: true,\n                includeReactions: true,\n                includeMetaArray: true,\n            };\n            if (initialTimeStamp) {\n                messageListParams_1.nextResultSize = NEXT_RESULT_SIZE;\n            }\n            if (replyType === 'QUOTE_REPLY' || replyType === 'THREAD') {\n                messageListParams_1.includeThreadInfo = true;\n                messageListParams_1.includeParentMessageInfo = true;\n                messageListParams_1.replyType = ReplyType.ONLY_REPLY_TO_CHANNEL;\n            }\n            if (userFilledMessageListQuery) {\n                Object.keys(userFilledMessageListQuery).forEach(function (key) {\n                    // @ts-ignore\n                    messageListParams_1[key] = userFilledMessageListQuery[key];\n                });\n            }\n            if ((replyType\n                && (replyType === 'QUOTE_REPLY' || replyType === 'THREAD'))\n                || userFilledMessageListQuery) {\n                logger.info('Channel useInitialMessagesFetch: Setup messageListParams', messageListParams_1);\n                messagesDispatcher({\n                    type: MESSAGE_LIST_PARAMS_CHANGED,\n                    payload: messageListParams_1,\n                });\n            }\n            logger.info('Channel: Fetching messages', { currentGroupChannel: currentGroupChannel, userFilledMessageListQuery: userFilledMessageListQuery });\n            messagesDispatcher({\n                type: FETCH_INITIAL_MESSAGES_START,\n                payload: null,\n            });\n            currentGroupChannel\n                .getMessagesByTimestamp(initialTimeStamp || new Date().getTime(), messageListParams_1)\n                .then(function (messages) {\n                messagesDispatcher({\n                    type: FETCH_INITIAL_MESSAGES_SUCCESS,\n                    payload: {\n                        currentGroupChannel: currentGroupChannel,\n                        messages: messages,\n                    },\n                });\n            })\n                .catch(function (error) {\n                logger.error('Channel: Fetching messages failed', error);\n                messagesDispatcher({\n                    type: FETCH_INITIAL_MESSAGES_FAILURE,\n                    payload: { currentGroupChannel: currentGroupChannel },\n                });\n            })\n                .finally(function () {\n                if (!initialTimeStamp) {\n                    setTimeout(function () { return scrollIntoLast(0, scrollRef, setIsScrolled); }, SCROLL_BOTTOM_DELAY_FOR_FETCH);\n                }\n                else {\n                    setTimeout(function () {\n                        scrollToRenderedMessage(scrollRef, initialTimeStamp, setIsScrolled);\n                    }, 500);\n                }\n            });\n        }\n    }, [channelUrl, userFilledMessageListQuery, initialTimeStamp]);\n    useEffect(function () {\n        fetchMessages();\n    }, [fetchMessages]);\n    return fetchMessages;\n}\n\nexport { NEXT_RESULT_SIZE as N, PREV_RESULT_SIZE as P, useInitialMessagesFetch as u };\n//# sourceMappingURL=bundle-chiYJ8F8.js.map\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module"}