{"ast":null,"code":"import React__default, { useEffect, useCallback, useReducer, useMemo } from 'react';\nimport { c as compareIds, s as scrollIntoLast, g as getParentMessageFrom, u as useSendMultipleFilesMessage, a as getNicknamesMapFromMembers } from '../chunks/bundle-T6fVCCb7.js';\nimport { U as UserProfileProvider } from '../chunks/bundle-BrTJ5Zbd.js';\nimport { useSendbirdStateContext } from '../useSendbirdStateContext.js';\nimport { _ as __assign, c as __spreadArray, a as __awaiter, b as __generator } from '../chunks/bundle-BQi9-O76.js';\nimport { ChannelStateTypes, ThreadListStateTypes, ParentMessageStateTypes } from './context/types.js';\nimport { ChannelType } from '@sendbird/chat';\nimport { p as pubSubTopics, a as shouldPubSubPublishToThread, b as PUBSUB_TOPICS, P as PublishingModuleType } from '../chunks/bundle-b6TpX_JP.js';\nimport { s as ON_FILE_INFO_UPLOADED, t as ON_TYPING_STATUS_UPDATED } from '../chunks/bundle-CpjASiz4.js';\nimport { GroupChannelHandler } from '@sendbird/chat/groupChannel';\nimport { u as uuidv4 } from '../chunks/bundle-etuaqevl.js';\nimport { c as compareIds$1 } from '../chunks/bundle-CZUYMubi.js';\nimport { MessageType, SendingStatus, MessageMetaArray } from '@sendbird/chat/message';\nimport { d as SCROLL_BOTTOM_DELAY_FOR_SEND, e as VOICE_MESSAGE_FILE_NAME, a as VOICE_MESSAGE_MIME_TYPE, M as META_ARRAY_VOICE_DURATION_KEY, f as META_ARRAY_MESSAGE_TYPE_KEY, g as META_ARRAY_MESSAGE_TYPE_VALUE__VOICE } from '../chunks/bundle-DCMGp6rH.js';\nimport '../chunks/bundle-CMLImr6T.js';\nimport '../utils/message/getOutgoingMessageState.js';\nimport '../withSendbird.js';\nvar PREV_THREADS_FETCH_SIZE = 30;\nvar NEXT_THREADS_FETCH_SIZE = 30;\nvar ThreadContextActionTypes;\n(function (ThreadContextActionTypes) {\n  // initialize\n  ThreadContextActionTypes[\"INIT_USER_ID\"] = \"INIT_USER_ID\";\n  // channel\n  ThreadContextActionTypes[\"GET_CHANNEL_START\"] = \"GET_CHANNEL_START\";\n  ThreadContextActionTypes[\"GET_CHANNEL_SUCCESS\"] = \"GET_CHANNEL_SUCCESS\";\n  ThreadContextActionTypes[\"GET_CHANNEL_FAILURE\"] = \"GET_CHANNEL_FAILURE\";\n  // emojis\n  ThreadContextActionTypes[\"SET_EMOJI_CONTAINER\"] = \"SET_EMOJI_CONTAINER\";\n  // parent message\n  ThreadContextActionTypes[\"GET_PARENT_MESSAGE_START\"] = \"GET_PARENT_MESSAGE_START\";\n  ThreadContextActionTypes[\"GET_PARENT_MESSAGE_SUCCESS\"] = \"GET_PARENT_MESSAGE_SUCCESS\";\n  ThreadContextActionTypes[\"GET_PARENT_MESSAGE_FAILURE\"] = \"GET_PARENT_MESSAGE_FAILURE\";\n  // fetch threads\n  ThreadContextActionTypes[\"INITIALIZE_THREAD_LIST_START\"] = \"INITIALIZE_THREAD_LIST_START\";\n  ThreadContextActionTypes[\"INITIALIZE_THREAD_LIST_SUCCESS\"] = \"INITIALIZE_THREAD_LIST_SUCCESS\";\n  ThreadContextActionTypes[\"INITIALIZE_THREAD_LIST_FAILURE\"] = \"INITIALIZE_THREAD_LIST_FAILURE\";\n  ThreadContextActionTypes[\"GET_PREV_MESSAGES_START\"] = \"GET_PREV_MESSAGES_START\";\n  ThreadContextActionTypes[\"GET_PREV_MESSAGES_SUCESS\"] = \"GET_PREV_MESSAGES_SUCESS\";\n  ThreadContextActionTypes[\"GET_PREV_MESSAGES_FAILURE\"] = \"GET_PREV_MESSAGES_FAILURE\";\n  ThreadContextActionTypes[\"GET_NEXT_MESSAGES_START\"] = \"GET_NEXT_MESSAGES_START\";\n  ThreadContextActionTypes[\"GET_NEXT_MESSAGES_SUCESS\"] = \"GET_NEXT_MESSAGES_SUCESS\";\n  ThreadContextActionTypes[\"GET_NEXT_MESSAGES_FAILURE\"] = \"GET_NEXT_MESSAGES_FAILURE\";\n  // handle messages\n  ThreadContextActionTypes[\"SEND_MESSAGE_START\"] = \"SEND_MESSAGE_START\";\n  ThreadContextActionTypes[\"SEND_MESSAGE_SUCESS\"] = \"SEND_MESSAGE_SUCESS\";\n  ThreadContextActionTypes[\"SEND_MESSAGE_FAILURE\"] = \"SEND_MESSAGE_FAILURE\";\n  ThreadContextActionTypes[\"RESEND_MESSAGE_START\"] = \"RESEND_MESSAGE_START\";\n  ThreadContextActionTypes[\"ON_MESSAGE_DELETED_BY_REQ_ID\"] = \"ON_MESSAGE_DELETED_BY_REQ_ID\";\n  // event handlers - message status change\n  ThreadContextActionTypes[\"ON_MESSAGE_RECEIVED\"] = \"ON_MESSAGE_RECEIVED\";\n  ThreadContextActionTypes[\"ON_MESSAGE_UPDATED\"] = \"ON_MESSAGE_UPDATED\";\n  ThreadContextActionTypes[\"ON_MESSAGE_DELETED\"] = \"ON_MESSAGE_DELETED\";\n  ThreadContextActionTypes[\"ON_REACTION_UPDATED\"] = \"ON_REACTION_UPDATED\";\n  ThreadContextActionTypes[\"ON_FILE_INFO_UPLOADED\"] = \"ON_FILE_INFO_UPLOADED\";\n  // event handlers - user status change\n  ThreadContextActionTypes[\"ON_USER_MUTED\"] = \"ON_USER_MUTED\";\n  ThreadContextActionTypes[\"ON_USER_UNMUTED\"] = \"ON_USER_UNMUTED\";\n  ThreadContextActionTypes[\"ON_USER_BANNED\"] = \"ON_USER_BANNED\";\n  ThreadContextActionTypes[\"ON_USER_UNBANNED\"] = \"ON_USER_UNBANNED\";\n  ThreadContextActionTypes[\"ON_USER_LEFT\"] = \"ON_USER_LEFT\";\n  // event handler - channel status change\n  ThreadContextActionTypes[\"ON_CHANNEL_FROZEN\"] = \"ON_CHANNEL_FROZEN\";\n  ThreadContextActionTypes[\"ON_CHANNEL_UNFROZEN\"] = \"ON_CHANNEL_UNFROZEN\";\n  ThreadContextActionTypes[\"ON_OPERATOR_UPDATED\"] = \"ON_OPERATOR_UPDATED\";\n  // event handler - typing status change\n  ThreadContextActionTypes[\"ON_TYPING_STATUS_UPDATED\"] = \"ON_TYPING_STATUS_UPDATED\";\n})(ThreadContextActionTypes || (ThreadContextActionTypes = {}));\nfunction reducer(state, action) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;\n  switch (action.type) {\n    // initialize\n    case ThreadContextActionTypes.INIT_USER_ID:\n      {\n        return __assign(__assign({}, state), {\n          currentUserId: action.payload\n        });\n      }\n    case ThreadContextActionTypes.GET_CHANNEL_START:\n      {\n        return __assign(__assign({}, state), {\n          channelState: ChannelStateTypes.LOADING,\n          currentChannel: null\n        });\n      }\n    case ThreadContextActionTypes.GET_CHANNEL_SUCCESS:\n      {\n        var groupChannel = action.payload.groupChannel;\n        return __assign(__assign({}, state), {\n          channelState: ChannelStateTypes.INITIALIZED,\n          currentChannel: groupChannel,\n          // only support in normal group channel\n          isMuted: ((_b = (_a = groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.members) === null || _a === void 0 ? void 0 : _a.find(function (member) {\n            return (member === null || member === void 0 ? void 0 : member.userId) === state.currentUserId;\n          })) === null || _b === void 0 ? void 0 : _b.isMuted) || false,\n          isChannelFrozen: (groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.isFrozen) || false\n        });\n      }\n    case ThreadContextActionTypes.GET_CHANNEL_FAILURE:\n      {\n        return __assign(__assign({}, state), {\n          channelState: ChannelStateTypes.INVALID,\n          currentChannel: null\n        });\n      }\n    case ThreadContextActionTypes.SET_EMOJI_CONTAINER:\n      {\n        var emojiContainer = action.payload.emojiContainer;\n        return __assign(__assign({}, state), {\n          emojiContainer: emojiContainer\n        });\n      }\n    case ThreadContextActionTypes.GET_PARENT_MESSAGE_START:\n      {\n        return __assign(__assign({}, state), {\n          parentMessageState: ParentMessageStateTypes.LOADING,\n          parentMessage: null\n        });\n      }\n    case ThreadContextActionTypes.GET_PARENT_MESSAGE_SUCCESS:\n      {\n        return __assign(__assign({}, state), {\n          parentMessageState: ParentMessageStateTypes.INITIALIZED,\n          parentMessage: action.payload.parentMessage\n        });\n      }\n    case ThreadContextActionTypes.GET_PARENT_MESSAGE_FAILURE:\n      {\n        return __assign(__assign({}, state), {\n          parentMessageState: ParentMessageStateTypes.INVALID,\n          parentMessage: null\n        });\n      }\n    // fetch threads\n    case ThreadContextActionTypes.INITIALIZE_THREAD_LIST_START:\n      {\n        return __assign(__assign({}, state), {\n          threadListState: ThreadListStateTypes.LOADING,\n          allThreadMessages: []\n        });\n      }\n    case ThreadContextActionTypes.INITIALIZE_THREAD_LIST_SUCCESS:\n      {\n        var _z = action.payload,\n          parentMessage = _z.parentMessage,\n          anchorMessage = _z.anchorMessage,\n          threadedMessages = _z.threadedMessages;\n        var anchorMessageCreatedAt_1 = !(anchorMessage === null || anchorMessage === void 0 ? void 0 : anchorMessage.messageId) ? parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.createdAt : anchorMessage === null || anchorMessage === void 0 ? void 0 : anchorMessage.createdAt;\n        var anchorIndex = threadedMessages.findIndex(function (message) {\n          return (message === null || message === void 0 ? void 0 : message.createdAt) > anchorMessageCreatedAt_1;\n        });\n        var prevThreadMessages = anchorIndex > -1 ? threadedMessages.slice(0, anchorIndex) : threadedMessages;\n        var anchorThreadMessage = (anchorMessage === null || anchorMessage === void 0 ? void 0 : anchorMessage.messageId) ? [anchorMessage] : [];\n        var nextThreadMessages = anchorIndex > -1 ? threadedMessages.slice(anchorIndex) : [];\n        return __assign(__assign({}, state), {\n          threadListState: ThreadListStateTypes.INITIALIZED,\n          hasMorePrev: anchorIndex === -1 || anchorIndex === PREV_THREADS_FETCH_SIZE,\n          hasMoreNext: threadedMessages.length - anchorIndex === NEXT_THREADS_FETCH_SIZE,\n          allThreadMessages: [prevThreadMessages, anchorThreadMessage, nextThreadMessages].flat()\n        });\n      }\n    case ThreadContextActionTypes.INITIALIZE_THREAD_LIST_FAILURE:\n      {\n        return __assign(__assign({}, state), {\n          threadListState: ThreadListStateTypes.INVALID,\n          allThreadMessages: []\n        });\n      }\n    case ThreadContextActionTypes.GET_NEXT_MESSAGES_START:\n      {\n        return __assign({}, state);\n      }\n    case ThreadContextActionTypes.GET_NEXT_MESSAGES_SUCESS:\n      {\n        var threadedMessages = action.payload.threadedMessages;\n        return __assign(__assign({}, state), {\n          hasMoreNext: threadedMessages.length === NEXT_THREADS_FETCH_SIZE,\n          allThreadMessages: __spreadArray(__spreadArray([], state.allThreadMessages, true), threadedMessages, true)\n        });\n      }\n    case ThreadContextActionTypes.GET_NEXT_MESSAGES_FAILURE:\n      {\n        return __assign(__assign({}, state), {\n          hasMoreNext: false\n        });\n      }\n    case ThreadContextActionTypes.GET_PREV_MESSAGES_START:\n      {\n        return __assign({}, state);\n      }\n    case ThreadContextActionTypes.GET_PREV_MESSAGES_SUCESS:\n      {\n        var threadedMessages = action.payload.threadedMessages;\n        return __assign(__assign({}, state), {\n          hasMorePrev: threadedMessages.length === PREV_THREADS_FETCH_SIZE,\n          allThreadMessages: __spreadArray(__spreadArray([], threadedMessages, true), state.allThreadMessages, true)\n        });\n      }\n    case ThreadContextActionTypes.GET_PREV_MESSAGES_FAILURE:\n      {\n        return __assign(__assign({}, state), {\n          hasMorePrev: false\n        });\n      }\n    // event handlers - message status change\n    case ThreadContextActionTypes.ON_MESSAGE_RECEIVED:\n      {\n        var _0 = action.payload,\n          channel = _0.channel,\n          message_1 = _0.message;\n        if (((_c = state.currentChannel) === null || _c === void 0 ? void 0 : _c.url) !== (channel === null || channel === void 0 ? void 0 : channel.url) || state.hasMoreNext || ((_d = message_1 === null || message_1 === void 0 ? void 0 : message_1.parentMessage) === null || _d === void 0 ? void 0 : _d.messageId) !== ((_e = state === null || state === void 0 ? void 0 : state.parentMessage) === null || _e === void 0 ? void 0 : _e.messageId)) {\n          return state;\n        }\n        var isAlreadyReceived = state.allThreadMessages.findIndex(function (m) {\n          return m.messageId === message_1.messageId;\n        }) > -1;\n        return __assign(__assign({}, state), {\n          parentMessage: ((_f = state.parentMessage) === null || _f === void 0 ? void 0 : _f.messageId) === (message_1 === null || message_1 === void 0 ? void 0 : message_1.messageId) ? message_1 : state.parentMessage,\n          allThreadMessages: isAlreadyReceived ? state.allThreadMessages.map(function (m) {\n            return m.messageId === message_1.messageId ? message_1 : m;\n          }) : __spreadArray(__spreadArray([], state.allThreadMessages.filter(function (m) {\n            return (m === null || m === void 0 ? void 0 : m.reqId) !== (message_1 === null || message_1 === void 0 ? void 0 : message_1.reqId);\n          }), true), [message_1], false)\n        });\n      }\n    case ThreadContextActionTypes.ON_MESSAGE_UPDATED:\n      {\n        var _1 = action.payload,\n          channel = _1.channel,\n          message_2 = _1.message;\n        if (((_g = state.currentChannel) === null || _g === void 0 ? void 0 : _g.url) !== (channel === null || channel === void 0 ? void 0 : channel.url)) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          parentMessage: ((_h = state.parentMessage) === null || _h === void 0 ? void 0 : _h.messageId) === (message_2 === null || message_2 === void 0 ? void 0 : message_2.messageId) ? message_2 : state.parentMessage,\n          allThreadMessages: (_j = state.allThreadMessages) === null || _j === void 0 ? void 0 : _j.map(function (msg) {\n            return (msg === null || msg === void 0 ? void 0 : msg.messageId) === (message_2 === null || message_2 === void 0 ? void 0 : message_2.messageId) ? message_2 : msg;\n          })\n        });\n      }\n    case ThreadContextActionTypes.ON_MESSAGE_DELETED:\n      {\n        var _2 = action.payload,\n          channel = _2.channel,\n          messageId_1 = _2.messageId;\n        if (((_k = state.currentChannel) === null || _k === void 0 ? void 0 : _k.url) !== (channel === null || channel === void 0 ? void 0 : channel.url)) {\n          return state;\n        }\n        if (((_l = state === null || state === void 0 ? void 0 : state.parentMessage) === null || _l === void 0 ? void 0 : _l.messageId) === messageId_1) {\n          return __assign(__assign({}, state), {\n            parentMessage: null,\n            parentMessageState: ParentMessageStateTypes.NIL,\n            allThreadMessages: []\n          });\n        }\n        return __assign(__assign({}, state), {\n          allThreadMessages: (_m = state.allThreadMessages) === null || _m === void 0 ? void 0 : _m.filter(function (msg) {\n            return (msg === null || msg === void 0 ? void 0 : msg.messageId) !== messageId_1;\n          }),\n          localThreadMessages: (_o = state.localThreadMessages) === null || _o === void 0 ? void 0 : _o.filter(function (msg) {\n            return (msg === null || msg === void 0 ? void 0 : msg.messageId) !== messageId_1;\n          })\n        });\n      }\n    case ThreadContextActionTypes.ON_MESSAGE_DELETED_BY_REQ_ID:\n      {\n        return __assign(__assign({}, state), {\n          localThreadMessages: state.localThreadMessages.filter(function (m) {\n            return !compareIds(m.reqId, action.payload);\n          })\n        });\n      }\n    case ThreadContextActionTypes.ON_REACTION_UPDATED:\n      {\n        var reactionEvent_1 = (_p = action.payload) === null || _p === void 0 ? void 0 : _p.reactionEvent;\n        if (((_q = state === null || state === void 0 ? void 0 : state.parentMessage) === null || _q === void 0 ? void 0 : _q.messageId) === (reactionEvent_1 === null || reactionEvent_1 === void 0 ? void 0 : reactionEvent_1.messageId)) {\n          (_s = (_r = state.parentMessage) === null || _r === void 0 ? void 0 : _r.applyReactionEvent) === null || _s === void 0 ? void 0 : _s.call(_r, reactionEvent_1);\n        }\n        return __assign(__assign({}, state), {\n          allThreadMessages: state.allThreadMessages.map(function (m) {\n            var _a;\n            if ((reactionEvent_1 === null || reactionEvent_1 === void 0 ? void 0 : reactionEvent_1.messageId) === (m === null || m === void 0 ? void 0 : m.messageId)) {\n              (_a = m === null || m === void 0 ? void 0 : m.applyReactionEvent) === null || _a === void 0 ? void 0 : _a.call(m, reactionEvent_1);\n              return m;\n            }\n            return m;\n          })\n        });\n      }\n    // event handlers - user status change\n    case ThreadContextActionTypes.ON_USER_MUTED:\n      {\n        var _3 = action.payload,\n          channel = _3.channel,\n          user = _3.user;\n        if (((_t = state.currentChannel) === null || _t === void 0 ? void 0 : _t.url) !== (channel === null || channel === void 0 ? void 0 : channel.url) || state.currentUserId !== (user === null || user === void 0 ? void 0 : user.userId)) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          isMuted: true\n        });\n      }\n    case ThreadContextActionTypes.ON_USER_UNMUTED:\n      {\n        var _4 = action.payload,\n          channel = _4.channel,\n          user = _4.user;\n        if (((_u = state.currentChannel) === null || _u === void 0 ? void 0 : _u.url) !== (channel === null || channel === void 0 ? void 0 : channel.url) || state.currentUserId !== (user === null || user === void 0 ? void 0 : user.userId)) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          isMuted: false\n        });\n      }\n    case ThreadContextActionTypes.ON_USER_BANNED:\n      {\n        return __assign(__assign({}, state), {\n          channelState: ChannelStateTypes.NIL,\n          threadListState: ThreadListStateTypes.NIL,\n          parentMessageState: ParentMessageStateTypes.NIL,\n          currentChannel: null,\n          parentMessage: null,\n          allThreadMessages: [],\n          hasMorePrev: false,\n          hasMoreNext: false\n        });\n      }\n    case ThreadContextActionTypes.ON_USER_UNBANNED:\n      {\n        return __assign({}, state);\n      }\n    case ThreadContextActionTypes.ON_USER_LEFT:\n      {\n        return __assign(__assign({}, state), {\n          channelState: ChannelStateTypes.NIL,\n          threadListState: ThreadListStateTypes.NIL,\n          parentMessageState: ParentMessageStateTypes.NIL,\n          currentChannel: null,\n          parentMessage: null,\n          allThreadMessages: [],\n          hasMorePrev: false,\n          hasMoreNext: false\n        });\n      }\n    // event handler - channel status change\n    case ThreadContextActionTypes.ON_CHANNEL_FROZEN:\n      {\n        return __assign(__assign({}, state), {\n          isChannelFrozen: true\n        });\n      }\n    case ThreadContextActionTypes.ON_CHANNEL_UNFROZEN:\n      {\n        return __assign(__assign({}, state), {\n          isChannelFrozen: false\n        });\n      }\n    case ThreadContextActionTypes.ON_OPERATOR_UPDATED:\n      {\n        var channel = action.payload.channel;\n        if ((channel === null || channel === void 0 ? void 0 : channel.url) === ((_v = state.currentChannel) === null || _v === void 0 ? void 0 : _v.url)) {\n          return __assign(__assign({}, state), {\n            currentChannel: channel\n          });\n        }\n        return state;\n      }\n    // message\n    case ThreadContextActionTypes.SEND_MESSAGE_START:\n      {\n        var message = action.payload.message;\n        return __assign(__assign({}, state), {\n          localThreadMessages: __spreadArray(__spreadArray([], state.localThreadMessages, true), [message], false)\n        });\n      }\n    case ThreadContextActionTypes.SEND_MESSAGE_SUCESS:\n      {\n        var message_3 = action.payload.message;\n        return __assign(__assign({}, state), {\n          allThreadMessages: __spreadArray(__spreadArray([], state.allThreadMessages.filter(function (m) {\n            return !compareIds(m === null || m === void 0 ? void 0 : m.reqId, message_3 === null || message_3 === void 0 ? void 0 : message_3.reqId);\n          }), true), [message_3], false),\n          localThreadMessages: state.localThreadMessages.filter(function (m) {\n            return !compareIds(m === null || m === void 0 ? void 0 : m.reqId, message_3 === null || message_3 === void 0 ? void 0 : message_3.reqId);\n          })\n        });\n      }\n    case ThreadContextActionTypes.SEND_MESSAGE_FAILURE:\n      {\n        var message_4 = action.payload.message;\n        return __assign(__assign({}, state), {\n          localThreadMessages: state.localThreadMessages.map(function (m) {\n            return compareIds(m === null || m === void 0 ? void 0 : m.reqId, message_4 === null || message_4 === void 0 ? void 0 : message_4.reqId) ? message_4 : m;\n          })\n        });\n      }\n    case ThreadContextActionTypes.RESEND_MESSAGE_START:\n      {\n        var message_5 = action.payload.message;\n        return __assign(__assign({}, state), {\n          localThreadMessages: state.localThreadMessages.map(function (m) {\n            return compareIds(m === null || m === void 0 ? void 0 : m.reqId, message_5 === null || message_5 === void 0 ? void 0 : message_5.reqId) ? message_5 : m;\n          })\n        });\n      }\n    case ThreadContextActionTypes.ON_FILE_INFO_UPLOADED:\n      {\n        var _5 = action.payload,\n          channelUrl = _5.channelUrl,\n          requestId_1 = _5.requestId,\n          index = _5.index,\n          uploadableFileInfo = _5.uploadableFileInfo,\n          error = _5.error;\n        if (!compareIds(channelUrl, (_w = state.currentChannel) === null || _w === void 0 ? void 0 : _w.url)) {\n          return state;\n        }\n        /**\n         * We don't have to do anything here because\n         * onFailed() will be called so handle error there instead.\n         */\n        if (error) return state;\n        var localThreadMessages = state.localThreadMessages;\n        var messageToUpdate = localThreadMessages.find(function (message) {\n          return compareIds(hasReqId(message) && message.reqId, requestId_1);\n        });\n        var fileInfoList = (_x = messageToUpdate.messageParams) === null || _x === void 0 ? void 0 : _x.fileInfoList;\n        if (Array.isArray(fileInfoList)) {\n          fileInfoList[index] = uploadableFileInfo;\n        }\n        return __assign(__assign({}, state), {\n          localThreadMessages: localThreadMessages\n        });\n      }\n    case ThreadContextActionTypes.ON_TYPING_STATUS_UPDATED:\n      {\n        var _6 = action.payload,\n          channel = _6.channel,\n          typingMembers = _6.typingMembers;\n        if (!compareIds(channel.url, (_y = state.currentChannel) === null || _y === void 0 ? void 0 : _y.url)) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          typingMembers: typingMembers\n        });\n      }\n    default:\n      {\n        return state;\n      }\n  }\n}\nfunction hasReqId(message) {\n  return 'reqId' in message;\n}\nvar initialState = {\n  currentChannel: null,\n  allThreadMessages: [],\n  localThreadMessages: [],\n  parentMessage: null,\n  channelState: ChannelStateTypes.NIL,\n  parentMessageState: ParentMessageStateTypes.NIL,\n  threadListState: ThreadListStateTypes.NIL,\n  hasMorePrev: false,\n  hasMoreNext: false,\n  emojiContainer: {},\n  isMuted: false,\n  isChannelFrozen: false,\n  currentUserId: '',\n  typingMembers: []\n};\nfunction useGetChannel(_a, _b) {\n  var channelUrl = _a.channelUrl,\n    sdkInit = _a.sdkInit,\n    message = _a.message;\n  var sdk = _b.sdk,\n    logger = _b.logger,\n    threadDispatcher = _b.threadDispatcher;\n  useEffect(function () {\n    var _a, _b;\n    // validation check\n    if (sdkInit && channelUrl && (sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel)) {\n      threadDispatcher({\n        type: ThreadContextActionTypes.GET_CHANNEL_START,\n        payload: null\n      });\n      (_b = (_a = sdk.groupChannel).getChannel) === null || _b === void 0 ? void 0 : _b.call(_a, channelUrl).then(function (groupChannel) {\n        logger.info('Thread | useInitialize: Get channel succeeded', groupChannel);\n        threadDispatcher({\n          type: ThreadContextActionTypes.GET_CHANNEL_SUCCESS,\n          payload: {\n            groupChannel: groupChannel\n          }\n        });\n      }).catch(function (error) {\n        logger.info('Thread | useInitialize: Get channel failed', error);\n        threadDispatcher({\n          type: ThreadContextActionTypes.GET_CHANNEL_FAILURE,\n          payload: error\n        });\n      });\n    }\n  }, [message, sdkInit]);\n  /**\n   * We don't use channelUrl here,\n   * because Thread must operate independently of the channel.\n   */\n}\nfunction useGetAllEmoji(_a, _b) {\n  var sdk = _a.sdk;\n  var logger = _b.logger,\n    threadDispatcher = _b.threadDispatcher;\n  useEffect(function () {\n    if (sdk === null || sdk === void 0 ? void 0 : sdk.getAllEmoji) {\n      // validation check\n      sdk === null || sdk === void 0 ? void 0 : sdk.getAllEmoji().then(function (emojiContainer) {\n        logger.info('Thread | useGetAllEmoji: Getting emojis succeeded.', emojiContainer);\n        threadDispatcher({\n          type: ThreadContextActionTypes.SET_EMOJI_CONTAINER,\n          payload: {\n            emojiContainer: emojiContainer\n          }\n        });\n      }).catch(function (error) {\n        logger.info('Thread | useGetAllEmoji: Getting emojis failed.', error);\n      });\n    }\n  }, [sdk]);\n}\nfunction useGetParentMessage(_a, _b) {\n  var channelUrl = _a.channelUrl,\n    sdkInit = _a.sdkInit,\n    parentMessage = _a.parentMessage;\n  var sdk = _b.sdk,\n    logger = _b.logger,\n    threadDispatcher = _b.threadDispatcher;\n  useEffect(function () {\n    var _a, _b, _c;\n    // validation check\n    if (sdkInit && ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.message) === null || _a === void 0 ? void 0 : _a.getMessage) && parentMessage) {\n      threadDispatcher({\n        type: ThreadContextActionTypes.GET_PARENT_MESSAGE_START,\n        payload: null\n      });\n      var params = {\n        channelUrl: channelUrl,\n        channelType: ChannelType.GROUP,\n        messageId: parentMessage.messageId,\n        includeMetaArray: true,\n        includeReactions: true,\n        includeThreadInfo: true,\n        includeParentMessageInfo: true\n      };\n      logger.info('Thread | useGetParentMessage: Get parent message start.', params);\n      (_c = (_b = sdk.message).getMessage) === null || _c === void 0 ? void 0 : _c.call(_b, params).then(function (parentMsg) {\n        logger.info('Thread | useGetParentMessage: Get parent message succeeded.', parentMessage);\n        // @ts-ignore\n        parentMsg.ogMetaData = (parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.ogMetaData) || null; // ogMetaData is not included for now\n        threadDispatcher({\n          type: ThreadContextActionTypes.GET_PARENT_MESSAGE_SUCCESS,\n          payload: {\n            parentMessage: parentMsg\n          }\n        });\n      }).catch(function (error) {\n        logger.info('Thread | useGetParentMessage: Get parent message failed.', error);\n        threadDispatcher({\n          type: ThreadContextActionTypes.GET_PARENT_MESSAGE_FAILURE,\n          payload: error\n        });\n      });\n    }\n  }, [sdkInit, parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId]);\n  /**\n   * We don't use channelUrl here,\n   * because Thread must operate independently of the channel.\n   */\n}\nfunction useHandleThreadPubsubEvents(_a, _b) {\n  var sdkInit = _a.sdkInit,\n    currentChannel = _a.currentChannel,\n    parentMessage = _a.parentMessage;\n  var pubSub = _b.pubSub,\n    threadDispatcher = _b.threadDispatcher;\n  useEffect(function () {\n    var subscriber = new Map();\n    if (pubSub === null || pubSub === void 0 ? void 0 : pubSub.subscribe) {\n      // TODO: subscribe ON_FILE_INFO_UPLOADED\n      subscriber.set(pubSubTopics.SEND_MESSAGE_START, pubSub.subscribe(pubSubTopics.SEND_MESSAGE_START, function (props) {\n        var _a, _b;\n        var channel = props.channel,\n          message = props.message,\n          publishingModules = props.publishingModules;\n        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url) && (message === null || message === void 0 ? void 0 : message.parentMessageId) === (parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId) && shouldPubSubPublishToThread(publishingModules)) {\n          // TODO: const clonedMessage = cloneMessage(message);\n          var pendingMessage = __assign({}, message);\n          if (message.isMultipleFilesMessage()) {\n            pendingMessage.fileInfoList = (_b = (_a = message === null || message === void 0 ? void 0 : message.messageParams) === null || _a === void 0 ? void 0 : _a.fileInfoList.map(function (fileInfo) {\n              return __assign(__assign({}, fileInfo), {\n                url: URL.createObjectURL(fileInfo.file)\n              });\n            })) !== null && _b !== void 0 ? _b : [];\n          }\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_START,\n            payload: {\n              message: pendingMessage\n            }\n          });\n        }\n        scrollIntoLast === null || scrollIntoLast === void 0 ? void 0 : scrollIntoLast();\n      }));\n      subscriber.set(PUBSUB_TOPICS.ON_FILE_INFO_UPLOADED, pubSub.subscribe(PUBSUB_TOPICS.ON_FILE_INFO_UPLOADED, function (props) {\n        var response = props.response,\n          publishingModules = props.publishingModules;\n        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === response.channelUrl && shouldPubSubPublishToThread(publishingModules)) {\n          threadDispatcher({\n            type: ON_FILE_INFO_UPLOADED,\n            payload: response\n          });\n        }\n      }));\n      subscriber.set(pubSubTopics.SEND_USER_MESSAGE, pubSub.subscribe(pubSubTopics.SEND_USER_MESSAGE, function (props) {\n        var _a = props,\n          channel = _a.channel,\n          message = _a.message;\n        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url) && (message === null || message === void 0 ? void 0 : message.parentMessageId) === (parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId)) {\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n            payload: {\n              message: message\n            }\n          });\n        }\n        scrollIntoLast === null || scrollIntoLast === void 0 ? void 0 : scrollIntoLast();\n      }));\n      subscriber.set(pubSubTopics.SEND_MESSAGE_FAILED, pubSub.subscribe(pubSubTopics.SEND_MESSAGE_FAILED, function (props) {\n        var channel = props.channel,\n          message = props.message,\n          publishingModules = props.publishingModules;\n        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url) && (message === null || message === void 0 ? void 0 : message.parentMessageId) === (parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId) && shouldPubSubPublishToThread(publishingModules)) {\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n            payload: {\n              message: message\n            }\n          });\n        }\n      }));\n      subscriber.set(pubSubTopics.SEND_FILE_MESSAGE, pubSub.subscribe(pubSubTopics.SEND_FILE_MESSAGE, function (props) {\n        var channel = props.channel,\n          message = props.message,\n          publishingModules = props.publishingModules;\n        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url) && shouldPubSubPublishToThread(publishingModules)) {\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n            payload: {\n              message: message\n            }\n          });\n        }\n        scrollIntoLast === null || scrollIntoLast === void 0 ? void 0 : scrollIntoLast();\n      }));\n      subscriber.set(pubSubTopics.UPDATE_USER_MESSAGE, pubSub.subscribe(pubSubTopics.UPDATE_USER_MESSAGE, function (props) {\n        var _a = props,\n          channel = _a.channel,\n          message = _a.message;\n        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_MESSAGE_UPDATED,\n            payload: {\n              channel: channel,\n              message: message\n            }\n          });\n        }\n      }));\n      subscriber.set(pubSubTopics.DELETE_MESSAGE, pubSub.subscribe(pubSubTopics.DELETE_MESSAGE, function (props) {\n        var _a = props,\n          channel = _a.channel,\n          messageId = _a.messageId;\n        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_MESSAGE_DELETED,\n            payload: {\n              messageId: messageId\n            }\n          });\n        }\n      }));\n    }\n    return function () {\n      subscriber === null || subscriber === void 0 ? void 0 : subscriber.forEach(function (s) {\n        try {\n          s === null || s === void 0 ? void 0 : s.remove();\n        } catch (_a) {\n          //\n        }\n      });\n    };\n  }, [sdkInit, currentChannel, parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId]);\n}\nfunction useHandleChannelEvents(_a, _b) {\n  var sdk = _a.sdk,\n    currentChannel = _a.currentChannel;\n  var logger = _b.logger,\n    threadDispatcher = _b.threadDispatcher;\n  useEffect(function () {\n    var _a, _b, _c;\n    var handlerId = uuidv4();\n    // validation check\n    if (((_a = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.addGroupChannelHandler) && currentChannel) {\n      var channelHandlerParams = {\n        // message status change\n        onMessageReceived: function (channel, message) {\n          logger.info('Thread | useHandleChannelEvents: onMessageReceived', {\n            channel: channel,\n            message: message\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_MESSAGE_RECEIVED,\n            payload: {\n              channel: channel,\n              message: message\n            }\n          });\n        },\n        onMessageUpdated: function (channel, message) {\n          logger.info('Thread | useHandleChannelEvents: onMessageUpdated', {\n            channel: channel,\n            message: message\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_MESSAGE_UPDATED,\n            payload: {\n              channel: channel,\n              message: message\n            }\n          });\n        },\n        onMessageDeleted: function (channel, messageId) {\n          logger.info('Thread | useHandleChannelEvents: onMessageDeleted', {\n            channel: channel,\n            messageId: messageId\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_MESSAGE_DELETED,\n            payload: {\n              channel: channel,\n              messageId: messageId\n            }\n          });\n        },\n        onReactionUpdated: function (channel, reactionEvent) {\n          logger.info('Thread | useHandleChannelEvents: onReactionUpdated', {\n            channel: channel,\n            reactionEvent: reactionEvent\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_REACTION_UPDATED,\n            payload: {\n              channel: channel,\n              reactionEvent: reactionEvent\n            }\n          });\n        },\n        // user status change\n        onUserMuted: function (channel, user) {\n          logger.info('Thread | useHandleChannelEvents: onUserMuted', {\n            channel: channel,\n            user: user\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_USER_MUTED,\n            payload: {\n              channel: channel,\n              user: user\n            }\n          });\n        },\n        onUserUnmuted: function (channel, user) {\n          logger.info('Thread | useHandleChannelEvents: onUserUnmuted', {\n            channel: channel,\n            user: user\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_USER_UNMUTED,\n            payload: {\n              channel: channel,\n              user: user\n            }\n          });\n        },\n        onUserBanned: function (channel, user) {\n          logger.info('Thread | useHandleChannelEvents: onUserBanned', {\n            channel: channel,\n            user: user\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_USER_BANNED,\n            payload: {\n              channel: channel,\n              user: user\n            }\n          });\n        },\n        onUserUnbanned: function (channel, user) {\n          logger.info('Thread | useHandleChannelEvents: onUserUnbanned', {\n            channel: channel,\n            user: user\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_USER_UNBANNED,\n            payload: {\n              channel: channel,\n              user: user\n            }\n          });\n        },\n        onUserLeft: function (channel, user) {\n          logger.info('Thread | useHandleChannelEvents: onUserLeft', {\n            channel: channel,\n            user: user\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_USER_LEFT,\n            payload: {\n              channel: channel,\n              user: user\n            }\n          });\n        },\n        // channel status change\n        onChannelFrozen: function (channel) {\n          logger.info('Thread | useHandleChannelEvents: onChannelFrozen', {\n            channel: channel\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_CHANNEL_FROZEN,\n            payload: {\n              channel: channel\n            }\n          });\n        },\n        onChannelUnfrozen: function (channel) {\n          logger.info('Thread | useHandleChannelEvents: onChannelUnfrozen', {\n            channel: channel\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_CHANNEL_UNFROZEN,\n            payload: {\n              channel: channel\n            }\n          });\n        },\n        onOperatorUpdated: function (channel, users) {\n          logger.info('Thread | useHandleChannelEvents: onOperatorUpdated', {\n            channel: channel,\n            users: users\n          });\n          threadDispatcher({\n            type: ThreadContextActionTypes.ON_OPERATOR_UPDATED,\n            payload: {\n              channel: channel,\n              users: users\n            }\n          });\n        },\n        onTypingStatusUpdated: function (channel) {\n          if (compareIds$1(channel === null || channel === void 0 ? void 0 : channel.url, currentChannel.url)) {\n            logger.info('Channel | onTypingStatusUpdated', {\n              channel: channel\n            });\n            var typingMembers = channel.getTypingUsers();\n            threadDispatcher({\n              type: ON_TYPING_STATUS_UPDATED,\n              payload: {\n                channel: channel,\n                typingMembers: typingMembers\n              }\n            });\n          }\n        }\n      };\n      var channelHandler = new GroupChannelHandler(channelHandlerParams);\n      (_c = (_b = sdk.groupChannel).addGroupChannelHandler) === null || _c === void 0 ? void 0 : _c.call(_b, handlerId, channelHandler);\n      logger.info('Thread | useHandleChannelEvents: Added channelHandler in Thread', {\n        handlerId: handlerId,\n        channelHandler: channelHandler\n      });\n    }\n    return function () {\n      var _a, _b, _c;\n      // validation check\n      if (handlerId && ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.removeGroupChannelHandler)) {\n        (_c = (_b = sdk.groupChannel).removeGroupChannelHandler) === null || _c === void 0 ? void 0 : _c.call(_b, handlerId);\n        logger.info('Thread | useHandleChannelEvents: Removed channelHandler in Thread.', handlerId);\n      }\n    };\n  }, [sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel, currentChannel]);\n}\nfunction useSendFileMessageCallback(_a, _b) {\n  var currentChannel = _a.currentChannel,\n    onBeforeSendFileMessage = _a.onBeforeSendFileMessage;\n  var logger = _b.logger,\n    pubSub = _b.pubSub,\n    threadDispatcher = _b.threadDispatcher;\n  return useCallback(function (file, quoteMessage) {\n    return new Promise(function (resolve, reject) {\n      var _a;\n      var createParamsDefault = function () {\n        var params = {};\n        params.file = file;\n        if (quoteMessage) {\n          params.isReplyToChannel = true;\n          params.parentMessageId = quoteMessage.messageId;\n        }\n        return params;\n      };\n      var params = (_a = onBeforeSendFileMessage === null || onBeforeSendFileMessage === void 0 ? void 0 : onBeforeSendFileMessage(file, quoteMessage)) !== null && _a !== void 0 ? _a : createParamsDefault();\n      logger.info('Thread | useSendFileMessageCallback: Sending file message start.', params);\n      currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.sendFileMessage(params).onPending(function (pendingMessage) {\n        threadDispatcher({\n          type: ThreadContextActionTypes.SEND_MESSAGE_START,\n          payload: {\n            /* pubSub is used instead of messagesDispatcher\n              to avoid redundantly calling `messageActionTypes.SEND_MESSAGE_START` */\n            // TODO: remove data pollution\n            message: __assign(__assign({}, pendingMessage), {\n              url: URL.createObjectURL(file),\n              // pending thumbnail message seems to be failed\n              requestState: 'pending',\n              isUserMessage: pendingMessage.isUserMessage,\n              isFileMessage: pendingMessage.isFileMessage,\n              isAdminMessage: pendingMessage.isAdminMessage,\n              isMultipleFilesMessage: pendingMessage.isMultipleFilesMessage\n            })\n          }\n        });\n        setTimeout(function () {\n          return scrollIntoLast();\n        }, SCROLL_BOTTOM_DELAY_FOR_SEND);\n      }).onFailed(function (error, message) {\n        message.localUrl = URL.createObjectURL(file);\n        message.file = file;\n        logger.info('Thread | useSendFileMessageCallback: Sending file message failed.', {\n          message: message,\n          error: error\n        });\n        threadDispatcher({\n          type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n          payload: {\n            message: message,\n            error: error\n          }\n        });\n        reject(error);\n      }).onSucceeded(function (message) {\n        logger.info('Thread | useSendFileMessageCallback: Sending file message succeeded.', message);\n        pubSub.publish(pubSubTopics.SEND_FILE_MESSAGE, {\n          channel: currentChannel,\n          message: message,\n          publishingModules: [PublishingModuleType.THREAD]\n        });\n        resolve(message);\n      });\n    });\n  }, [currentChannel]);\n}\nfunction useUpdateMessageCallback(_a, _b) {\n  var currentChannel = _a.currentChannel,\n    isMentionEnabled = _a.isMentionEnabled;\n  var logger = _b.logger,\n    pubSub = _b.pubSub,\n    threadDispatcher = _b.threadDispatcher;\n  // TODO: add type\n  return useCallback(function (props) {\n    var _a;\n    var messageId = props.messageId,\n      message = props.message,\n      mentionedUsers = props.mentionedUsers,\n      mentionTemplate = props.mentionTemplate;\n    var createParamsDefault = function () {\n      var params = {};\n      params.message = message;\n      if (isMentionEnabled && mentionedUsers && (mentionedUsers === null || mentionedUsers === void 0 ? void 0 : mentionedUsers.length) > 0) {\n        params.mentionedUsers = mentionedUsers;\n      }\n      if (isMentionEnabled && mentionTemplate) {\n        params.mentionedMessageTemplate = mentionTemplate;\n      } else {\n        params.mentionedMessageTemplate = message;\n      }\n      return params;\n    };\n    var params = createParamsDefault();\n    logger.info('Thread | useUpdateMessageCallback: Message update start.', params);\n    (_a = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.updateUserMessage) === null || _a === void 0 ? void 0 : _a.call(currentChannel, messageId, params).then(function (message) {\n      logger.info('Thread | useUpdateMessageCallback: Message update succeeded.', message);\n      threadDispatcher({\n        type: ThreadContextActionTypes.ON_MESSAGE_UPDATED,\n        payload: {\n          channel: currentChannel,\n          message: message\n        }\n      });\n      pubSub.publish(pubSubTopics.UPDATE_USER_MESSAGE, {\n        fromSelector: true,\n        channel: currentChannel,\n        message: message,\n        publishingModules: [PublishingModuleType.THREAD]\n      });\n    });\n  }, [currentChannel, isMentionEnabled]);\n}\nfunction useDeleteMessageCallback(_a, _b) {\n  var currentChannel = _a.currentChannel,\n    threadDispatcher = _a.threadDispatcher;\n  var logger = _b.logger;\n  return useCallback(function (message) {\n    logger.info('Thread | useDeleteMessageCallback: Deleting message.', message);\n    var sendingStatus = message.sendingStatus;\n    return new Promise(function (resolve, reject) {\n      var _a;\n      logger.info('Thread | useDeleteMessageCallback: Deleting message requestState:', sendingStatus);\n      // Message is only on local\n      if (sendingStatus === 'failed' || sendingStatus === 'pending') {\n        logger.info('Thread | useDeleteMessageCallback: Deleted message from local:', message);\n        threadDispatcher({\n          type: ThreadContextActionTypes.ON_MESSAGE_DELETED_BY_REQ_ID,\n          payload: message.reqId\n        });\n        resolve();\n      }\n      logger.info('Thread | useDeleteMessageCallback: Deleting message from remote:', sendingStatus);\n      (_a = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.deleteMessage) === null || _a === void 0 ? void 0 : _a.call(currentChannel, message).then(function () {\n        logger.info('Thread | useDeleteMessageCallback: Deleting message success!', message);\n        threadDispatcher({\n          type: ThreadContextActionTypes.ON_MESSAGE_DELETED,\n          payload: {\n            message: message,\n            channel: currentChannel\n          }\n        });\n        resolve();\n      }).catch(function (err) {\n        logger.warning('Thread | useDeleteMessageCallback: Deleting message failed!', err);\n        reject(err);\n      });\n    });\n  }, [currentChannel]);\n}\nfunction useToggleReactionCallback(_a, _b) {\n  var currentChannel = _a.currentChannel;\n  var logger = _b.logger;\n  return useCallback(function (message, key, isReacted) {\n    var _a, _b;\n    if (isReacted) {\n      (_a = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.deleteReaction) === null || _a === void 0 ? void 0 : _a.call(currentChannel, message, key).then(function (res) {\n        logger.info('Thread | useToggleReactionsCallback: Delete reaction succeeded.', res);\n      }).catch(function (err) {\n        logger.warning('Thread | useToggleReactionsCallback: Delete reaction failed.', err);\n      });\n      return;\n    }\n    (_b = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.addReaction) === null || _b === void 0 ? void 0 : _b.call(currentChannel, message, key).then(function (res) {\n      logger.info('Thread | useToggleReactionsCallback: Add reaction succeeded.', res);\n    }).catch(function (err) {\n      logger.warning('Thread | useToggleReactionsCallback: Add reaction failed.', err);\n    });\n  }, [currentChannel]);\n}\nfunction useSendUserMessageCallback(_a, _b) {\n  var isMentionEnabled = _a.isMentionEnabled,\n    currentChannel = _a.currentChannel,\n    onBeforeSendUserMessage = _a.onBeforeSendUserMessage;\n  var logger = _b.logger,\n    pubSub = _b.pubSub,\n    threadDispatcher = _b.threadDispatcher;\n  var sendMessage = useCallback(function (props) {\n    var _a;\n    var message = props.message,\n      quoteMessage = props.quoteMessage,\n      mentionTemplate = props.mentionTemplate,\n      mentionedUsers = props.mentionedUsers;\n    var createDefaultParams = function () {\n      var params = {};\n      params.message = message;\n      var mentionedUsersLength = (mentionedUsers === null || mentionedUsers === void 0 ? void 0 : mentionedUsers.length) || 0;\n      if (isMentionEnabled && mentionedUsersLength) {\n        params.mentionedUsers = mentionedUsers;\n      }\n      if (isMentionEnabled && mentionTemplate && mentionedUsersLength) {\n        params.mentionedMessageTemplate = mentionTemplate;\n      }\n      if (quoteMessage) {\n        params.isReplyToChannel = true;\n        params.parentMessageId = quoteMessage.messageId;\n      }\n      return params;\n    };\n    var params = (_a = onBeforeSendUserMessage === null || onBeforeSendUserMessage === void 0 ? void 0 : onBeforeSendUserMessage(message, quoteMessage)) !== null && _a !== void 0 ? _a : createDefaultParams();\n    logger.info('Thread | useSendUserMessageCallback: Sending user message start.', params);\n    if (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.sendUserMessage) {\n      currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.sendUserMessage(params).onPending(function (pendingMessage) {\n        threadDispatcher({\n          type: ThreadContextActionTypes.SEND_MESSAGE_START,\n          payload: {\n            message: pendingMessage\n          }\n        });\n      }).onFailed(function (error, message) {\n        logger.info('Thread | useSendUserMessageCallback: Sending user message failed.', {\n          message: message,\n          error: error\n        });\n        threadDispatcher({\n          type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n          payload: {\n            error: error,\n            message: message\n          }\n        });\n      }).onSucceeded(function (message) {\n        logger.info('Thread | useSendUserMessageCallback: Sending user message succeeded.', message);\n        // because Thread doesn't subscribe SEND_USER_MESSAGE\n        pubSub.publish(pubSubTopics.SEND_USER_MESSAGE, {\n          channel: currentChannel,\n          message: message,\n          publishingModules: [PublishingModuleType.THREAD]\n        });\n      });\n    }\n  }, [isMentionEnabled, currentChannel]);\n  return sendMessage;\n}\nfunction useResendMessageCallback(_a, _b) {\n  var currentChannel = _a.currentChannel;\n  var logger = _b.logger,\n    pubSub = _b.pubSub,\n    threadDispatcher = _b.threadDispatcher;\n  return useCallback(function (failedMessage) {\n    var _a, _b, _c, _d, _e;\n    if (failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.isResendable) {\n      logger.info('Thread | useResendMessageCallback: Resending failedMessage start.', failedMessage);\n      if (((_a = failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.isUserMessage) === null || _a === void 0 ? void 0 : _a.call(failedMessage)) || (failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.messageType) === MessageType.USER) {\n        try {\n          currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.resendMessage(failedMessage).onPending(function (message) {\n            logger.info('Thread | useResendMessageCallback: Resending user message started.', message);\n            threadDispatcher({\n              type: ThreadContextActionTypes.RESEND_MESSAGE_START,\n              payload: {\n                message: message\n              }\n            });\n          }).onSucceeded(function (message) {\n            logger.info('Thread | useResendMessageCallback: Resending user message succeeded.', message);\n            threadDispatcher({\n              type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n              payload: {\n                message: message\n              }\n            });\n            pubSub.publish(pubSubTopics.SEND_USER_MESSAGE, {\n              channel: currentChannel,\n              message: message,\n              publishingModules: [PublishingModuleType.THREAD]\n            });\n          }).onFailed(function (error) {\n            logger.warning('Thread | useResendMessageCallback: Resending user message failed.', error);\n            failedMessage.sendingStatus = SendingStatus.FAILED;\n            threadDispatcher({\n              type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n              payload: {\n                message: failedMessage\n              }\n            });\n          });\n        } catch (err) {\n          logger.warning('Thread | useResendMessageCallback: Resending user message failed.', err);\n          failedMessage.sendingStatus = SendingStatus.FAILED;\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n            payload: {\n              message: failedMessage\n            }\n          });\n        }\n      } else if ((_b = failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.isFileMessage) === null || _b === void 0 ? void 0 : _b.call(failedMessage)) {\n        try {\n          (_c = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.resendMessage) === null || _c === void 0 ? void 0 : _c.call(currentChannel, failedMessage).onPending(function (message) {\n            logger.info('Thread | useResendMessageCallback: Resending file message started.', message);\n            threadDispatcher({\n              type: ThreadContextActionTypes.RESEND_MESSAGE_START,\n              payload: {\n                message: message\n              }\n            });\n          }).onSucceeded(function (message) {\n            logger.info('Thread | useResendMessageCallback: Resending file message succeeded.', message);\n            threadDispatcher({\n              type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n              payload: {\n                message: message\n              }\n            });\n            pubSub.publish(pubSubTopics.SEND_FILE_MESSAGE, {\n              channel: currentChannel,\n              message: failedMessage,\n              publishingModules: [PublishingModuleType.THREAD]\n            });\n          }).onFailed(function (error) {\n            logger.warning('Thread | useResendMessageCallback: Resending file message failed.', error);\n            failedMessage.sendingStatus = SendingStatus.FAILED;\n            threadDispatcher({\n              type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n              payload: {\n                message: failedMessage\n              }\n            });\n          });\n        } catch (err) {\n          logger.warning('Thread | useResendMessageCallback: Resending file message failed.', err);\n          failedMessage.sendingStatus = SendingStatus.FAILED;\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n            payload: {\n              message: failedMessage\n            }\n          });\n        }\n      } else if ((_d = failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.isMultipleFilesMessage) === null || _d === void 0 ? void 0 : _d.call(failedMessage)) {\n        try {\n          (_e = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.resendMessage) === null || _e === void 0 ? void 0 : _e.call(currentChannel, failedMessage).onPending(function (message) {\n            logger.info('Thread | useResendMessageCallback: Resending multiple files message started.', message);\n            threadDispatcher({\n              type: ThreadContextActionTypes.RESEND_MESSAGE_START,\n              payload: {\n                message: message\n              }\n            });\n          }).onFileUploaded(function (requestId, index, uploadableFileInfo, error) {\n            logger.info('Thread | useResendMessageCallback: onFileUploaded during resending multiple files message.', {\n              requestId: requestId,\n              index: index,\n              error: error,\n              uploadableFileInfo: uploadableFileInfo\n            });\n            pubSub.publish(pubSubTopics.ON_FILE_INFO_UPLOADED, {\n              response: {\n                channelUrl: currentChannel.url,\n                requestId: requestId,\n                index: index,\n                uploadableFileInfo: uploadableFileInfo,\n                error: error\n              },\n              publishingModules: [PublishingModuleType.THREAD]\n            });\n          }).onSucceeded(function (message) {\n            logger.info('Thread | useResendMessageCallback: Resending MFM succeeded.', message);\n            threadDispatcher({\n              type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n              payload: {\n                message: message\n              }\n            });\n            pubSub.publish(pubSubTopics.SEND_FILE_MESSAGE, {\n              channel: currentChannel,\n              message: message,\n              publishingModules: [PublishingModuleType.THREAD]\n            });\n          }).onFailed(function (error, message) {\n            logger.warning('Thread | useResendMessageCallback: Resending MFM failed.', error);\n            threadDispatcher({\n              type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n              payload: {\n                message: message\n              }\n            });\n          });\n        } catch (err) {\n          logger.warning('Thread | useResendMessageCallback: Resending MFM failed.', err);\n          threadDispatcher({\n            type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n            payload: {\n              message: failedMessage\n            }\n          });\n        }\n      } else {\n        logger.warning('Thread | useResendMessageCallback: Message is not resendable.', failedMessage);\n        failedMessage.sendingStatus = SendingStatus.FAILED;\n        threadDispatcher({\n          type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n          payload: {\n            message: failedMessage\n          }\n        });\n      }\n    }\n  }, [currentChannel]);\n}\nvar useSendVoiceMessageCallback = function (_a, _b) {\n  var currentChannel = _a.currentChannel,\n    onBeforeSendVoiceMessage = _a.onBeforeSendVoiceMessage;\n  var logger = _b.logger,\n    pubSub = _b.pubSub,\n    threadDispatcher = _b.threadDispatcher;\n  var sendMessage = useCallback(function (file, duration, quoteMessage) {\n    var messageParams = onBeforeSendVoiceMessage && typeof onBeforeSendVoiceMessage === 'function' ? onBeforeSendVoiceMessage(file, quoteMessage) : {\n      file: file,\n      fileName: VOICE_MESSAGE_FILE_NAME,\n      mimeType: VOICE_MESSAGE_MIME_TYPE,\n      metaArrays: [new MessageMetaArray({\n        key: META_ARRAY_VOICE_DURATION_KEY,\n        value: [\"\".concat(duration)]\n      }), new MessageMetaArray({\n        key: META_ARRAY_MESSAGE_TYPE_KEY,\n        value: [META_ARRAY_MESSAGE_TYPE_VALUE__VOICE]\n      })]\n    };\n    if (quoteMessage) {\n      messageParams.isReplyToChannel = true;\n      messageParams.parentMessageId = quoteMessage.messageId;\n    }\n    logger.info('Thread | useSendVoiceMessageCallback:  Start sending voice message', messageParams);\n    currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.sendFileMessage(messageParams).onPending(function (pendingMessage) {\n      threadDispatcher({\n        type: ThreadContextActionTypes.SEND_MESSAGE_START,\n        payload: {\n          /* pubSub is used instead of messagesDispatcher\n          to avoid redundantly calling `messageActionTypes.SEND_MESSAGE_START` */\n          // TODO: remove data pollution\n          message: __assign(__assign({}, pendingMessage), {\n            url: URL.createObjectURL(file),\n            // pending thumbnail message seems to be failed\n            requestState: 'pending',\n            isUserMessage: pendingMessage.isUserMessage,\n            isFileMessage: pendingMessage.isFileMessage,\n            isAdminMessage: pendingMessage.isAdminMessage,\n            isMultipleFilesMessage: pendingMessage.isMultipleFilesMessage\n          })\n        }\n      });\n      setTimeout(function () {\n        return scrollIntoLast();\n      }, SCROLL_BOTTOM_DELAY_FOR_SEND);\n    }).onFailed(function (error, message) {\n      message.localUrl = URL.createObjectURL(file);\n      message.file = file;\n      logger.info('Thread | useSendVoiceMessageCallback: Sending voice message failed.', {\n        message: message,\n        error: error\n      });\n      threadDispatcher({\n        type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n        payload: {\n          message: message,\n          error: error\n        }\n      });\n    }).onSucceeded(function (message) {\n      logger.info('Thread | useSendVoiceMessageCallback: Sending voice message succeeded.', message);\n      pubSub.publish(pubSubTopics.SEND_FILE_MESSAGE, {\n        channel: currentChannel,\n        message: message,\n        publishingModules: [PublishingModuleType.THREAD]\n      });\n    });\n  }, [currentChannel, onBeforeSendVoiceMessage]);\n  return sendMessage;\n};\nfunction getThreadMessageListParams(params) {\n  return __assign({\n    prevResultSize: PREV_THREADS_FETCH_SIZE,\n    nextResultSize: NEXT_THREADS_FETCH_SIZE,\n    includeMetaArray: true\n  }, params);\n}\nvar useThreadFetchers = function (_a) {\n  var isReactionEnabled = _a.isReactionEnabled,\n    anchorMessage = _a.anchorMessage,\n    staleParentMessage = _a.parentMessage,\n    threadDispatcher = _a.threadDispatcher,\n    logger = _a.logger,\n    oldestMessageTimeStamp = _a.oldestMessageTimeStamp,\n    latestMessageTimeStamp = _a.latestMessageTimeStamp,\n    threadListState = _a.threadListState;\n  var stores = useSendbirdStateContext().stores;\n  var timestamp = (anchorMessage === null || anchorMessage === void 0 ? void 0 : anchorMessage.createdAt) || 0;\n  var initialize = useCallback(function (callback) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var params, _a, threadedMessages_1, parentMessage, error_1;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!stores.sdkStore.initialized || !staleParentMessage) return [2 /*return*/];\n            threadDispatcher({\n              type: ThreadContextActionTypes.INITIALIZE_THREAD_LIST_START,\n              payload: null\n            });\n            _b.label = 1;\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n            params = getThreadMessageListParams({\n              includeReactions: isReactionEnabled\n            });\n            logger.info('Thread | useGetThreadList: Initialize thread list start.', {\n              timestamp: timestamp,\n              params: params\n            });\n            return [4 /*yield*/, staleParentMessage.getThreadedMessagesByTimestamp(timestamp, params)];\n          case 2:\n            _a = _b.sent(), threadedMessages_1 = _a.threadedMessages, parentMessage = _a.parentMessage;\n            logger.info('Thread | useGetThreadList: Initialize thread list succeeded.', {\n              staleParentMessage: staleParentMessage,\n              threadedMessages: threadedMessages_1\n            });\n            threadDispatcher({\n              type: ThreadContextActionTypes.INITIALIZE_THREAD_LIST_SUCCESS,\n              payload: {\n                parentMessage: parentMessage,\n                anchorMessage: anchorMessage,\n                threadedMessages: threadedMessages_1\n              }\n            });\n            setTimeout(function () {\n              return callback === null || callback === void 0 ? void 0 : callback(threadedMessages_1);\n            });\n            return [3 /*break*/, 4];\n          case 3:\n            error_1 = _b.sent();\n            logger.info('Thread | useGetThreadList: Initialize thread list failed.', error_1);\n            threadDispatcher({\n              type: ThreadContextActionTypes.INITIALIZE_THREAD_LIST_FAILURE,\n              payload: error_1\n            });\n            return [3 /*break*/, 4];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  }, [stores.sdkStore.initialized, staleParentMessage, anchorMessage, isReactionEnabled]);\n  var loadPrevious = useCallback(function (callback) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var params, _a, threadedMessages_2, parentMessage, error_2;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (threadListState !== ThreadListStateTypes.INITIALIZED || oldestMessageTimeStamp === 0 || !staleParentMessage) return [2 /*return*/];\n            threadDispatcher({\n              type: ThreadContextActionTypes.GET_PREV_MESSAGES_START,\n              payload: null\n            });\n            _b.label = 1;\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n            params = getThreadMessageListParams({\n              nextResultSize: 0,\n              includeReactions: isReactionEnabled\n            });\n            return [4 /*yield*/, staleParentMessage.getThreadedMessagesByTimestamp(oldestMessageTimeStamp, params)];\n          case 2:\n            _a = _b.sent(), threadedMessages_2 = _a.threadedMessages, parentMessage = _a.parentMessage;\n            logger.info('Thread | useGetPrevThreadsCallback: Fetch prev threads succeeded.', {\n              parentMessage: parentMessage,\n              threadedMessages: threadedMessages_2\n            });\n            threadDispatcher({\n              type: ThreadContextActionTypes.GET_PREV_MESSAGES_SUCESS,\n              payload: {\n                parentMessage: parentMessage,\n                threadedMessages: threadedMessages_2\n              }\n            });\n            setTimeout(function () {\n              return callback === null || callback === void 0 ? void 0 : callback(threadedMessages_2);\n            });\n            return [3 /*break*/, 4];\n          case 3:\n            error_2 = _b.sent();\n            logger.info('Thread | useGetPrevThreadsCallback: Fetch prev threads failed.', error_2);\n            threadDispatcher({\n              type: ThreadContextActionTypes.GET_PREV_MESSAGES_FAILURE,\n              payload: error_2\n            });\n            return [3 /*break*/, 4];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  }, [threadListState, oldestMessageTimeStamp, isReactionEnabled, staleParentMessage]);\n  var loadNext = useCallback(function (callback) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var params, _a, threadedMessages_3, parentMessage, error_3;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (threadListState !== ThreadListStateTypes.INITIALIZED || latestMessageTimeStamp === 0 || !staleParentMessage) return [2 /*return*/];\n            threadDispatcher({\n              type: ThreadContextActionTypes.GET_NEXT_MESSAGES_START,\n              payload: null\n            });\n            _b.label = 1;\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n            params = getThreadMessageListParams({\n              prevResultSize: 0,\n              includeReactions: isReactionEnabled\n            });\n            return [4 /*yield*/, staleParentMessage.getThreadedMessagesByTimestamp(latestMessageTimeStamp, params)];\n          case 2:\n            _a = _b.sent(), threadedMessages_3 = _a.threadedMessages, parentMessage = _a.parentMessage;\n            logger.info('Thread | useGetNextThreadsCallback: Fetch next threads succeeded.', {\n              parentMessage: parentMessage,\n              threadedMessages: threadedMessages_3\n            });\n            threadDispatcher({\n              type: ThreadContextActionTypes.GET_NEXT_MESSAGES_SUCESS,\n              payload: {\n                parentMessage: parentMessage,\n                threadedMessages: threadedMessages_3\n              }\n            });\n            setTimeout(function () {\n              return callback === null || callback === void 0 ? void 0 : callback(threadedMessages_3);\n            });\n            return [3 /*break*/, 4];\n          case 3:\n            error_3 = _b.sent();\n            logger.info('Thread | useGetNextThreadsCallback: Fetch next threads failed.', error_3);\n            threadDispatcher({\n              type: ThreadContextActionTypes.GET_NEXT_MESSAGES_FAILURE,\n              payload: error_3\n            });\n            return [3 /*break*/, 4];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  }, [threadListState, latestMessageTimeStamp, isReactionEnabled, staleParentMessage]);\n  return {\n    initialize: initialize,\n    loadPrevious: loadPrevious,\n    loadNext: loadNext\n  };\n};\nvar ThreadContext = React__default.createContext(null);\nvar ThreadProvider = function (props) {\n  var _a, _b;\n  var children = props.children,\n    channelUrl = props.channelUrl,\n    onHeaderActionClick = props.onHeaderActionClick,\n    onMoveToParentMessage = props.onMoveToParentMessage,\n    onBeforeSendUserMessage = props.onBeforeSendUserMessage,\n    onBeforeSendFileMessage = props.onBeforeSendFileMessage,\n    onBeforeSendVoiceMessage = props.onBeforeSendVoiceMessage,\n    onBeforeSendMultipleFilesMessage = props.onBeforeSendMultipleFilesMessage,\n    onBeforeDownloadFileMessage = props.onBeforeDownloadFileMessage,\n    isMultipleFilesMessageEnabled = props.isMultipleFilesMessageEnabled,\n    // User Profile\n    disableUserProfile = props.disableUserProfile,\n    renderUserProfile = props.renderUserProfile;\n  var propsMessage = props === null || props === void 0 ? void 0 : props.message;\n  var propsParentMessage = getParentMessageFrom(propsMessage);\n  // Context from SendbirdProvider\n  var globalStore = useSendbirdStateContext();\n  var stores = globalStore.stores,\n    config = globalStore.config;\n  // // stores\n  var sdkStore = stores.sdkStore,\n    userStore = stores.userStore;\n  var sdk = sdkStore.sdk;\n  var user = userStore.user;\n  var sdkInit = sdkStore === null || sdkStore === void 0 ? void 0 : sdkStore.initialized;\n  // // config\n  var logger = config.logger,\n    pubSub = config.pubSub,\n    onUserProfileMessage = config.onUserProfileMessage;\n  var isMentionEnabled = config.groupChannel.enableMention;\n  var isReactionEnabled = config.groupChannel.enableReactions;\n  // dux of Thread\n  var _c = useReducer(reducer, initialState),\n    threadStore = _c[0],\n    threadDispatcher = _c[1];\n  var currentChannel = threadStore.currentChannel,\n    allThreadMessages = threadStore.allThreadMessages,\n    localThreadMessages = threadStore.localThreadMessages,\n    parentMessage = threadStore.parentMessage,\n    channelState = threadStore.channelState,\n    threadListState = threadStore.threadListState,\n    parentMessageState = threadStore.parentMessageState,\n    hasMorePrev = threadStore.hasMorePrev,\n    hasMoreNext = threadStore.hasMoreNext,\n    emojiContainer = threadStore.emojiContainer,\n    isMuted = threadStore.isMuted,\n    isChannelFrozen = threadStore.isChannelFrozen,\n    currentUserId = threadStore.currentUserId,\n    typingMembers = threadStore.typingMembers;\n  // Initialization\n  useEffect(function () {\n    threadDispatcher({\n      type: ThreadContextActionTypes.INIT_USER_ID,\n      payload: user === null || user === void 0 ? void 0 : user.userId\n    });\n  }, [user]);\n  useGetChannel({\n    channelUrl: channelUrl,\n    sdkInit: sdkInit,\n    message: propsMessage\n  }, {\n    sdk: sdk,\n    logger: logger,\n    threadDispatcher: threadDispatcher\n  });\n  useGetParentMessage({\n    channelUrl: channelUrl,\n    sdkInit: sdkInit,\n    parentMessage: propsParentMessage\n  }, {\n    sdk: sdk,\n    logger: logger,\n    threadDispatcher: threadDispatcher\n  });\n  useGetAllEmoji({\n    sdk: sdk\n  }, {\n    logger: logger,\n    threadDispatcher: threadDispatcher\n  });\n  // Handle channel events\n  useHandleChannelEvents({\n    sdk: sdk,\n    currentChannel: currentChannel\n  }, {\n    logger: logger,\n    threadDispatcher: threadDispatcher\n  });\n  useHandleThreadPubsubEvents({\n    sdkInit: sdkInit,\n    currentChannel: currentChannel,\n    parentMessage: parentMessage\n  }, {\n    logger: logger,\n    pubSub: pubSub,\n    threadDispatcher: threadDispatcher\n  });\n  var _d = useThreadFetchers({\n      parentMessage: parentMessage,\n      // anchorMessage should be null when parentMessage doesn't exist\n      anchorMessage: (propsMessage === null || propsMessage === void 0 ? void 0 : propsMessage.messageId) !== (propsParentMessage === null || propsParentMessage === void 0 ? void 0 : propsParentMessage.messageId) ? propsMessage || undefined : undefined,\n      logger: logger,\n      isReactionEnabled: isReactionEnabled,\n      threadDispatcher: threadDispatcher,\n      threadListState: threadListState,\n      oldestMessageTimeStamp: ((_a = allThreadMessages[0]) === null || _a === void 0 ? void 0 : _a.createdAt) || 0,\n      latestMessageTimeStamp: ((_b = allThreadMessages[allThreadMessages.length - 1]) === null || _b === void 0 ? void 0 : _b.createdAt) || 0\n    }),\n    initialize = _d.initialize,\n    loadPrevious = _d.loadPrevious,\n    loadNext = _d.loadNext;\n  useEffect(function () {\n    if (stores.sdkStore.initialized && config.isOnline) {\n      initialize();\n    }\n  }, [stores.sdkStore.initialized, config.isOnline, initialize]);\n  var toggleReaction = useToggleReactionCallback({\n    currentChannel: currentChannel\n  }, {\n    logger: logger\n  });\n  // Send Message Hooks\n  var sendMessage = useSendUserMessageCallback({\n    isMentionEnabled: isMentionEnabled,\n    currentChannel: currentChannel,\n    onBeforeSendUserMessage: onBeforeSendUserMessage\n  }, {\n    logger: logger,\n    pubSub: pubSub,\n    threadDispatcher: threadDispatcher\n  });\n  var sendFileMessage = useSendFileMessageCallback({\n    currentChannel: currentChannel,\n    onBeforeSendFileMessage: onBeforeSendFileMessage\n  }, {\n    logger: logger,\n    pubSub: pubSub,\n    threadDispatcher: threadDispatcher\n  });\n  var sendVoiceMessage = useSendVoiceMessageCallback({\n    currentChannel: currentChannel,\n    onBeforeSendVoiceMessage: onBeforeSendVoiceMessage\n  }, {\n    logger: logger,\n    pubSub: pubSub,\n    threadDispatcher: threadDispatcher\n  });\n  var sendMultipleFilesMessage = useSendMultipleFilesMessage({\n    currentChannel: currentChannel,\n    onBeforeSendMultipleFilesMessage: onBeforeSendMultipleFilesMessage,\n    publishingModules: [PublishingModuleType.THREAD]\n  }, {\n    logger: logger,\n    pubSub: pubSub\n  })[0];\n  var resendMessage = useResendMessageCallback({\n    currentChannel: currentChannel\n  }, {\n    logger: logger,\n    pubSub: pubSub,\n    threadDispatcher: threadDispatcher\n  });\n  var updateMessage = useUpdateMessageCallback({\n    currentChannel: currentChannel,\n    isMentionEnabled: isMentionEnabled\n  }, {\n    logger: logger,\n    pubSub: pubSub,\n    threadDispatcher: threadDispatcher\n  });\n  var deleteMessage = useDeleteMessageCallback({\n    currentChannel: currentChannel,\n    threadDispatcher: threadDispatcher\n  }, {\n    logger: logger\n  });\n  // memo\n  var nicknamesMap = useMemo(function () {\n    return config.groupChannel.replyType !== 'none' && currentChannel ? getNicknamesMapFromMembers(currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.members) : new Map();\n  }, [currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.members]);\n  return React__default.createElement(ThreadContext.Provider, {\n    value: {\n      // ThreadProviderProps\n      channelUrl: channelUrl,\n      message: propsMessage,\n      onHeaderActionClick: onHeaderActionClick,\n      onMoveToParentMessage: onMoveToParentMessage,\n      isMultipleFilesMessageEnabled: isMultipleFilesMessageEnabled,\n      onBeforeDownloadFileMessage: onBeforeDownloadFileMessage,\n      // ThreadContextInitialState\n      currentChannel: currentChannel,\n      allThreadMessages: allThreadMessages,\n      localThreadMessages: localThreadMessages,\n      parentMessage: parentMessage,\n      channelState: channelState,\n      threadListState: threadListState,\n      parentMessageState: parentMessageState,\n      hasMorePrev: hasMorePrev,\n      hasMoreNext: hasMoreNext,\n      emojiContainer: emojiContainer,\n      // hooks\n      fetchPrevThreads: loadPrevious,\n      fetchNextThreads: loadNext,\n      toggleReaction: toggleReaction,\n      sendMessage: sendMessage,\n      sendFileMessage: sendFileMessage,\n      sendVoiceMessage: sendVoiceMessage,\n      sendMultipleFilesMessage: sendMultipleFilesMessage,\n      resendMessage: resendMessage,\n      updateMessage: updateMessage,\n      deleteMessage: deleteMessage,\n      // context\n      nicknamesMap: nicknamesMap,\n      isMuted: isMuted,\n      isChannelFrozen: isChannelFrozen,\n      currentUserId: currentUserId,\n      typingMembers: typingMembers\n    }\n  }, React__default.createElement(UserProfileProvider, {\n    disableUserProfile: disableUserProfile !== null && disableUserProfile !== void 0 ? disableUserProfile : !config.common.enableUsingDefaultUserProfile,\n    renderUserProfile: renderUserProfile,\n    onUserProfileMessage: onUserProfileMessage\n  }, children));\n};\nvar useThreadContext = function () {\n  var context = React__default.useContext(ThreadContext);\n  if (!context) throw new Error('ThreadContext not found. Use within the Thread module');\n  return context;\n};\nexport { ThreadProvider, useThreadContext };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import React__default, { useEffect, useCallback, useReducer, useMemo } from 'react';\nimport { c as compareIds, s as scrollIntoLast, g as getParentMessageFrom, u as useSendMultipleFilesMessage, a as getNicknamesMapFromMembers } from '../chunks/bundle-T6fVCCb7.js';\nimport { U as UserProfileProvider } from '../chunks/bundle-BrTJ5Zbd.js';\nimport { useSendbirdStateContext } from '../useSendbirdStateContext.js';\nimport { _ as __assign, c as __spreadArray, a as __awaiter, b as __generator } from '../chunks/bundle-BQi9-O76.js';\nimport { ChannelStateTypes, ThreadListStateTypes, ParentMessageStateTypes } from './context/types.js';\nimport { ChannelType } from '@sendbird/chat';\nimport { p as pubSubTopics, a as shouldPubSubPublishToThread, b as PUBSUB_TOPICS, P as PublishingModuleType } from '../chunks/bundle-b6TpX_JP.js';\nimport { s as ON_FILE_INFO_UPLOADED, t as ON_TYPING_STATUS_UPDATED } from '../chunks/bundle-CpjASiz4.js';\nimport { GroupChannelHandler } from '@sendbird/chat/groupChannel';\nimport { u as uuidv4 } from '../chunks/bundle-etuaqevl.js';\nimport { c as compareIds$1 } from '../chunks/bundle-CZUYMubi.js';\nimport { MessageType, SendingStatus, MessageMetaArray } from '@sendbird/chat/message';\nimport { d as SCROLL_BOTTOM_DELAY_FOR_SEND, e as VOICE_MESSAGE_FILE_NAME, a as VOICE_MESSAGE_MIME_TYPE, M as META_ARRAY_VOICE_DURATION_KEY, f as META_ARRAY_MESSAGE_TYPE_KEY, g as META_ARRAY_MESSAGE_TYPE_VALUE__VOICE } from '../chunks/bundle-DCMGp6rH.js';\nimport '../chunks/bundle-CMLImr6T.js';\nimport '../utils/message/getOutgoingMessageState.js';\nimport '../withSendbird.js';\n\nvar PREV_THREADS_FETCH_SIZE = 30;\nvar NEXT_THREADS_FETCH_SIZE = 30;\n\nvar ThreadContextActionTypes;\n(function (ThreadContextActionTypes) {\n    // initialize\n    ThreadContextActionTypes[\"INIT_USER_ID\"] = \"INIT_USER_ID\";\n    // channel\n    ThreadContextActionTypes[\"GET_CHANNEL_START\"] = \"GET_CHANNEL_START\";\n    ThreadContextActionTypes[\"GET_CHANNEL_SUCCESS\"] = \"GET_CHANNEL_SUCCESS\";\n    ThreadContextActionTypes[\"GET_CHANNEL_FAILURE\"] = \"GET_CHANNEL_FAILURE\";\n    // emojis\n    ThreadContextActionTypes[\"SET_EMOJI_CONTAINER\"] = \"SET_EMOJI_CONTAINER\";\n    // parent message\n    ThreadContextActionTypes[\"GET_PARENT_MESSAGE_START\"] = \"GET_PARENT_MESSAGE_START\";\n    ThreadContextActionTypes[\"GET_PARENT_MESSAGE_SUCCESS\"] = \"GET_PARENT_MESSAGE_SUCCESS\";\n    ThreadContextActionTypes[\"GET_PARENT_MESSAGE_FAILURE\"] = \"GET_PARENT_MESSAGE_FAILURE\";\n    // fetch threads\n    ThreadContextActionTypes[\"INITIALIZE_THREAD_LIST_START\"] = \"INITIALIZE_THREAD_LIST_START\";\n    ThreadContextActionTypes[\"INITIALIZE_THREAD_LIST_SUCCESS\"] = \"INITIALIZE_THREAD_LIST_SUCCESS\";\n    ThreadContextActionTypes[\"INITIALIZE_THREAD_LIST_FAILURE\"] = \"INITIALIZE_THREAD_LIST_FAILURE\";\n    ThreadContextActionTypes[\"GET_PREV_MESSAGES_START\"] = \"GET_PREV_MESSAGES_START\";\n    ThreadContextActionTypes[\"GET_PREV_MESSAGES_SUCESS\"] = \"GET_PREV_MESSAGES_SUCESS\";\n    ThreadContextActionTypes[\"GET_PREV_MESSAGES_FAILURE\"] = \"GET_PREV_MESSAGES_FAILURE\";\n    ThreadContextActionTypes[\"GET_NEXT_MESSAGES_START\"] = \"GET_NEXT_MESSAGES_START\";\n    ThreadContextActionTypes[\"GET_NEXT_MESSAGES_SUCESS\"] = \"GET_NEXT_MESSAGES_SUCESS\";\n    ThreadContextActionTypes[\"GET_NEXT_MESSAGES_FAILURE\"] = \"GET_NEXT_MESSAGES_FAILURE\";\n    // handle messages\n    ThreadContextActionTypes[\"SEND_MESSAGE_START\"] = \"SEND_MESSAGE_START\";\n    ThreadContextActionTypes[\"SEND_MESSAGE_SUCESS\"] = \"SEND_MESSAGE_SUCESS\";\n    ThreadContextActionTypes[\"SEND_MESSAGE_FAILURE\"] = \"SEND_MESSAGE_FAILURE\";\n    ThreadContextActionTypes[\"RESEND_MESSAGE_START\"] = \"RESEND_MESSAGE_START\";\n    ThreadContextActionTypes[\"ON_MESSAGE_DELETED_BY_REQ_ID\"] = \"ON_MESSAGE_DELETED_BY_REQ_ID\";\n    // event handlers - message status change\n    ThreadContextActionTypes[\"ON_MESSAGE_RECEIVED\"] = \"ON_MESSAGE_RECEIVED\";\n    ThreadContextActionTypes[\"ON_MESSAGE_UPDATED\"] = \"ON_MESSAGE_UPDATED\";\n    ThreadContextActionTypes[\"ON_MESSAGE_DELETED\"] = \"ON_MESSAGE_DELETED\";\n    ThreadContextActionTypes[\"ON_REACTION_UPDATED\"] = \"ON_REACTION_UPDATED\";\n    ThreadContextActionTypes[\"ON_FILE_INFO_UPLOADED\"] = \"ON_FILE_INFO_UPLOADED\";\n    // event handlers - user status change\n    ThreadContextActionTypes[\"ON_USER_MUTED\"] = \"ON_USER_MUTED\";\n    ThreadContextActionTypes[\"ON_USER_UNMUTED\"] = \"ON_USER_UNMUTED\";\n    ThreadContextActionTypes[\"ON_USER_BANNED\"] = \"ON_USER_BANNED\";\n    ThreadContextActionTypes[\"ON_USER_UNBANNED\"] = \"ON_USER_UNBANNED\";\n    ThreadContextActionTypes[\"ON_USER_LEFT\"] = \"ON_USER_LEFT\";\n    // event handler - channel status change\n    ThreadContextActionTypes[\"ON_CHANNEL_FROZEN\"] = \"ON_CHANNEL_FROZEN\";\n    ThreadContextActionTypes[\"ON_CHANNEL_UNFROZEN\"] = \"ON_CHANNEL_UNFROZEN\";\n    ThreadContextActionTypes[\"ON_OPERATOR_UPDATED\"] = \"ON_OPERATOR_UPDATED\";\n    // event handler - typing status change\n    ThreadContextActionTypes[\"ON_TYPING_STATUS_UPDATED\"] = \"ON_TYPING_STATUS_UPDATED\";\n})(ThreadContextActionTypes || (ThreadContextActionTypes = {}));\n\nfunction reducer(state, action) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;\n    switch (action.type) {\n        // initialize\n        case ThreadContextActionTypes.INIT_USER_ID: {\n            return __assign(__assign({}, state), { currentUserId: action.payload });\n        }\n        case ThreadContextActionTypes.GET_CHANNEL_START: {\n            return __assign(__assign({}, state), { channelState: ChannelStateTypes.LOADING, currentChannel: null });\n        }\n        case ThreadContextActionTypes.GET_CHANNEL_SUCCESS: {\n            var groupChannel = action.payload.groupChannel;\n            return __assign(__assign({}, state), { channelState: ChannelStateTypes.INITIALIZED, currentChannel: groupChannel, \n                // only support in normal group channel\n                isMuted: ((_b = (_a = groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.members) === null || _a === void 0 ? void 0 : _a.find(function (member) { return (member === null || member === void 0 ? void 0 : member.userId) === state.currentUserId; })) === null || _b === void 0 ? void 0 : _b.isMuted) || false, isChannelFrozen: (groupChannel === null || groupChannel === void 0 ? void 0 : groupChannel.isFrozen) || false });\n        }\n        case ThreadContextActionTypes.GET_CHANNEL_FAILURE: {\n            return __assign(__assign({}, state), { channelState: ChannelStateTypes.INVALID, currentChannel: null });\n        }\n        case ThreadContextActionTypes.SET_EMOJI_CONTAINER: {\n            var emojiContainer = action.payload.emojiContainer;\n            return __assign(__assign({}, state), { emojiContainer: emojiContainer });\n        }\n        case ThreadContextActionTypes.GET_PARENT_MESSAGE_START: {\n            return __assign(__assign({}, state), { parentMessageState: ParentMessageStateTypes.LOADING, parentMessage: null });\n        }\n        case ThreadContextActionTypes.GET_PARENT_MESSAGE_SUCCESS: {\n            return __assign(__assign({}, state), { parentMessageState: ParentMessageStateTypes.INITIALIZED, parentMessage: action.payload.parentMessage });\n        }\n        case ThreadContextActionTypes.GET_PARENT_MESSAGE_FAILURE: {\n            return __assign(__assign({}, state), { parentMessageState: ParentMessageStateTypes.INVALID, parentMessage: null });\n        }\n        // fetch threads\n        case ThreadContextActionTypes.INITIALIZE_THREAD_LIST_START: {\n            return __assign(__assign({}, state), { threadListState: ThreadListStateTypes.LOADING, allThreadMessages: [] });\n        }\n        case ThreadContextActionTypes.INITIALIZE_THREAD_LIST_SUCCESS: {\n            var _z = action.payload, parentMessage = _z.parentMessage, anchorMessage = _z.anchorMessage, threadedMessages = _z.threadedMessages;\n            var anchorMessageCreatedAt_1 = (!(anchorMessage === null || anchorMessage === void 0 ? void 0 : anchorMessage.messageId)) ? parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.createdAt : anchorMessage === null || anchorMessage === void 0 ? void 0 : anchorMessage.createdAt;\n            var anchorIndex = threadedMessages.findIndex(function (message) { return (message === null || message === void 0 ? void 0 : message.createdAt) > anchorMessageCreatedAt_1; });\n            var prevThreadMessages = anchorIndex > -1 ? threadedMessages.slice(0, anchorIndex) : threadedMessages;\n            var anchorThreadMessage = (anchorMessage === null || anchorMessage === void 0 ? void 0 : anchorMessage.messageId) ? [anchorMessage] : [];\n            var nextThreadMessages = anchorIndex > -1 ? threadedMessages.slice(anchorIndex) : [];\n            return __assign(__assign({}, state), { threadListState: ThreadListStateTypes.INITIALIZED, hasMorePrev: anchorIndex === -1 || anchorIndex === PREV_THREADS_FETCH_SIZE, hasMoreNext: threadedMessages.length - anchorIndex === NEXT_THREADS_FETCH_SIZE, allThreadMessages: [prevThreadMessages, anchorThreadMessage, nextThreadMessages].flat() });\n        }\n        case ThreadContextActionTypes.INITIALIZE_THREAD_LIST_FAILURE: {\n            return __assign(__assign({}, state), { threadListState: ThreadListStateTypes.INVALID, allThreadMessages: [] });\n        }\n        case ThreadContextActionTypes.GET_NEXT_MESSAGES_START: {\n            return __assign({}, state);\n        }\n        case ThreadContextActionTypes.GET_NEXT_MESSAGES_SUCESS: {\n            var threadedMessages = action.payload.threadedMessages;\n            return __assign(__assign({}, state), { hasMoreNext: threadedMessages.length === NEXT_THREADS_FETCH_SIZE, allThreadMessages: __spreadArray(__spreadArray([], state.allThreadMessages, true), threadedMessages, true) });\n        }\n        case ThreadContextActionTypes.GET_NEXT_MESSAGES_FAILURE: {\n            return __assign(__assign({}, state), { hasMoreNext: false });\n        }\n        case ThreadContextActionTypes.GET_PREV_MESSAGES_START: {\n            return __assign({}, state);\n        }\n        case ThreadContextActionTypes.GET_PREV_MESSAGES_SUCESS: {\n            var threadedMessages = action.payload.threadedMessages;\n            return __assign(__assign({}, state), { hasMorePrev: threadedMessages.length === PREV_THREADS_FETCH_SIZE, allThreadMessages: __spreadArray(__spreadArray([], threadedMessages, true), state.allThreadMessages, true) });\n        }\n        case ThreadContextActionTypes.GET_PREV_MESSAGES_FAILURE: {\n            return __assign(__assign({}, state), { hasMorePrev: false });\n        }\n        // event handlers - message status change\n        case ThreadContextActionTypes.ON_MESSAGE_RECEIVED: {\n            var _0 = action.payload, channel = _0.channel, message_1 = _0.message;\n            if (((_c = state.currentChannel) === null || _c === void 0 ? void 0 : _c.url) !== (channel === null || channel === void 0 ? void 0 : channel.url)\n                || state.hasMoreNext\n                || ((_d = message_1 === null || message_1 === void 0 ? void 0 : message_1.parentMessage) === null || _d === void 0 ? void 0 : _d.messageId) !== ((_e = state === null || state === void 0 ? void 0 : state.parentMessage) === null || _e === void 0 ? void 0 : _e.messageId)) {\n                return state;\n            }\n            var isAlreadyReceived = state.allThreadMessages.findIndex(function (m) { return (m.messageId === message_1.messageId); }) > -1;\n            return __assign(__assign({}, state), { parentMessage: ((_f = state.parentMessage) === null || _f === void 0 ? void 0 : _f.messageId) === (message_1 === null || message_1 === void 0 ? void 0 : message_1.messageId) ? message_1 : state.parentMessage, allThreadMessages: isAlreadyReceived\n                    ? state.allThreadMessages.map(function (m) { return (m.messageId === message_1.messageId ? message_1 : m); })\n                    : __spreadArray(__spreadArray([], state.allThreadMessages.filter(function (m) { return (m === null || m === void 0 ? void 0 : m.reqId) !== (message_1 === null || message_1 === void 0 ? void 0 : message_1.reqId); }), true), [\n                        message_1,\n                    ], false) });\n        }\n        case ThreadContextActionTypes.ON_MESSAGE_UPDATED: {\n            var _1 = action.payload, channel = _1.channel, message_2 = _1.message;\n            if (((_g = state.currentChannel) === null || _g === void 0 ? void 0 : _g.url) !== (channel === null || channel === void 0 ? void 0 : channel.url)) {\n                return state;\n            }\n            return __assign(__assign({}, state), { parentMessage: ((_h = state.parentMessage) === null || _h === void 0 ? void 0 : _h.messageId) === (message_2 === null || message_2 === void 0 ? void 0 : message_2.messageId)\n                    ? message_2\n                    : state.parentMessage, allThreadMessages: (_j = state.allThreadMessages) === null || _j === void 0 ? void 0 : _j.map(function (msg) { return (((msg === null || msg === void 0 ? void 0 : msg.messageId) === (message_2 === null || message_2 === void 0 ? void 0 : message_2.messageId)) ? message_2 : msg); }) });\n        }\n        case ThreadContextActionTypes.ON_MESSAGE_DELETED: {\n            var _2 = action.payload, channel = _2.channel, messageId_1 = _2.messageId;\n            if (((_k = state.currentChannel) === null || _k === void 0 ? void 0 : _k.url) !== (channel === null || channel === void 0 ? void 0 : channel.url)) {\n                return state;\n            }\n            if (((_l = state === null || state === void 0 ? void 0 : state.parentMessage) === null || _l === void 0 ? void 0 : _l.messageId) === messageId_1) {\n                return __assign(__assign({}, state), { parentMessage: null, parentMessageState: ParentMessageStateTypes.NIL, allThreadMessages: [] });\n            }\n            return __assign(__assign({}, state), { allThreadMessages: (_m = state.allThreadMessages) === null || _m === void 0 ? void 0 : _m.filter(function (msg) { return ((msg === null || msg === void 0 ? void 0 : msg.messageId) !== messageId_1); }), localThreadMessages: (_o = state.localThreadMessages) === null || _o === void 0 ? void 0 : _o.filter(function (msg) { return ((msg === null || msg === void 0 ? void 0 : msg.messageId) !== messageId_1); }) });\n        }\n        case ThreadContextActionTypes.ON_MESSAGE_DELETED_BY_REQ_ID: {\n            return __assign(__assign({}, state), { localThreadMessages: state.localThreadMessages.filter(function (m) { return (!compareIds(m.reqId, action.payload)); }) });\n        }\n        case ThreadContextActionTypes.ON_REACTION_UPDATED: {\n            var reactionEvent_1 = (_p = action.payload) === null || _p === void 0 ? void 0 : _p.reactionEvent;\n            if (((_q = state === null || state === void 0 ? void 0 : state.parentMessage) === null || _q === void 0 ? void 0 : _q.messageId) === (reactionEvent_1 === null || reactionEvent_1 === void 0 ? void 0 : reactionEvent_1.messageId)) {\n                (_s = (_r = state.parentMessage) === null || _r === void 0 ? void 0 : _r.applyReactionEvent) === null || _s === void 0 ? void 0 : _s.call(_r, reactionEvent_1);\n            }\n            return __assign(__assign({}, state), { allThreadMessages: state.allThreadMessages.map(function (m) {\n                    var _a;\n                    if ((reactionEvent_1 === null || reactionEvent_1 === void 0 ? void 0 : reactionEvent_1.messageId) === (m === null || m === void 0 ? void 0 : m.messageId)) {\n                        (_a = m === null || m === void 0 ? void 0 : m.applyReactionEvent) === null || _a === void 0 ? void 0 : _a.call(m, reactionEvent_1);\n                        return m;\n                    }\n                    return m;\n                }) });\n        }\n        // event handlers - user status change\n        case ThreadContextActionTypes.ON_USER_MUTED: {\n            var _3 = action.payload, channel = _3.channel, user = _3.user;\n            if (((_t = state.currentChannel) === null || _t === void 0 ? void 0 : _t.url) !== (channel === null || channel === void 0 ? void 0 : channel.url) || state.currentUserId !== (user === null || user === void 0 ? void 0 : user.userId)) {\n                return state;\n            }\n            return __assign(__assign({}, state), { isMuted: true });\n        }\n        case ThreadContextActionTypes.ON_USER_UNMUTED: {\n            var _4 = action.payload, channel = _4.channel, user = _4.user;\n            if (((_u = state.currentChannel) === null || _u === void 0 ? void 0 : _u.url) !== (channel === null || channel === void 0 ? void 0 : channel.url) || state.currentUserId !== (user === null || user === void 0 ? void 0 : user.userId)) {\n                return state;\n            }\n            return __assign(__assign({}, state), { isMuted: false });\n        }\n        case ThreadContextActionTypes.ON_USER_BANNED: {\n            return __assign(__assign({}, state), { channelState: ChannelStateTypes.NIL, threadListState: ThreadListStateTypes.NIL, parentMessageState: ParentMessageStateTypes.NIL, currentChannel: null, parentMessage: null, allThreadMessages: [], hasMorePrev: false, hasMoreNext: false });\n        }\n        case ThreadContextActionTypes.ON_USER_UNBANNED: {\n            return __assign({}, state);\n        }\n        case ThreadContextActionTypes.ON_USER_LEFT: {\n            return __assign(__assign({}, state), { channelState: ChannelStateTypes.NIL, threadListState: ThreadListStateTypes.NIL, parentMessageState: ParentMessageStateTypes.NIL, currentChannel: null, parentMessage: null, allThreadMessages: [], hasMorePrev: false, hasMoreNext: false });\n        }\n        // event handler - channel status change\n        case ThreadContextActionTypes.ON_CHANNEL_FROZEN: {\n            return __assign(__assign({}, state), { isChannelFrozen: true });\n        }\n        case ThreadContextActionTypes.ON_CHANNEL_UNFROZEN: {\n            return __assign(__assign({}, state), { isChannelFrozen: false });\n        }\n        case ThreadContextActionTypes.ON_OPERATOR_UPDATED: {\n            var channel = action.payload.channel;\n            if ((channel === null || channel === void 0 ? void 0 : channel.url) === ((_v = state.currentChannel) === null || _v === void 0 ? void 0 : _v.url)) {\n                return __assign(__assign({}, state), { currentChannel: channel });\n            }\n            return state;\n        }\n        // message\n        case ThreadContextActionTypes.SEND_MESSAGE_START: {\n            var message = action.payload.message;\n            return __assign(__assign({}, state), { localThreadMessages: __spreadArray(__spreadArray([], state.localThreadMessages, true), [\n                    message,\n                ], false) });\n        }\n        case ThreadContextActionTypes.SEND_MESSAGE_SUCESS: {\n            var message_3 = action.payload.message;\n            return __assign(__assign({}, state), { allThreadMessages: __spreadArray(__spreadArray([], state.allThreadMessages.filter(function (m) { return (!compareIds(m === null || m === void 0 ? void 0 : m.reqId, message_3 === null || message_3 === void 0 ? void 0 : message_3.reqId)); }), true), [\n                    message_3,\n                ], false), localThreadMessages: state.localThreadMessages.filter(function (m) { return (!compareIds(m === null || m === void 0 ? void 0 : m.reqId, message_3 === null || message_3 === void 0 ? void 0 : message_3.reqId)); }) });\n        }\n        case ThreadContextActionTypes.SEND_MESSAGE_FAILURE: {\n            var message_4 = action.payload.message;\n            return __assign(__assign({}, state), { localThreadMessages: state.localThreadMessages.map(function (m) { return (compareIds(m === null || m === void 0 ? void 0 : m.reqId, message_4 === null || message_4 === void 0 ? void 0 : message_4.reqId)\n                    ? message_4\n                    : m); }) });\n        }\n        case ThreadContextActionTypes.RESEND_MESSAGE_START: {\n            var message_5 = action.payload.message;\n            return __assign(__assign({}, state), { localThreadMessages: state.localThreadMessages.map(function (m) { return (compareIds(m === null || m === void 0 ? void 0 : m.reqId, message_5 === null || message_5 === void 0 ? void 0 : message_5.reqId)\n                    ? message_5\n                    : m); }) });\n        }\n        case ThreadContextActionTypes.ON_FILE_INFO_UPLOADED: {\n            var _5 = action.payload, channelUrl = _5.channelUrl, requestId_1 = _5.requestId, index = _5.index, uploadableFileInfo = _5.uploadableFileInfo, error = _5.error;\n            if (!compareIds(channelUrl, (_w = state.currentChannel) === null || _w === void 0 ? void 0 : _w.url)) {\n                return state;\n            }\n            /**\n             * We don't have to do anything here because\n             * onFailed() will be called so handle error there instead.\n             */\n            if (error)\n                return state;\n            var localThreadMessages = state.localThreadMessages;\n            var messageToUpdate = localThreadMessages.find(function (message) { return compareIds(hasReqId(message) && message.reqId, requestId_1); });\n            var fileInfoList = (_x = messageToUpdate\n                .messageParams) === null || _x === void 0 ? void 0 : _x.fileInfoList;\n            if (Array.isArray(fileInfoList)) {\n                fileInfoList[index] = uploadableFileInfo;\n            }\n            return __assign(__assign({}, state), { localThreadMessages: localThreadMessages });\n        }\n        case ThreadContextActionTypes.ON_TYPING_STATUS_UPDATED: {\n            var _6 = action.payload, channel = _6.channel, typingMembers = _6.typingMembers;\n            if (!compareIds(channel.url, (_y = state.currentChannel) === null || _y === void 0 ? void 0 : _y.url)) {\n                return state;\n            }\n            return __assign(__assign({}, state), { typingMembers: typingMembers });\n        }\n        default: {\n            return state;\n        }\n    }\n}\nfunction hasReqId(message) {\n    return 'reqId' in message;\n}\n\nvar initialState = {\n    currentChannel: null,\n    allThreadMessages: [],\n    localThreadMessages: [],\n    parentMessage: null,\n    channelState: ChannelStateTypes.NIL,\n    parentMessageState: ParentMessageStateTypes.NIL,\n    threadListState: ThreadListStateTypes.NIL,\n    hasMorePrev: false,\n    hasMoreNext: false,\n    emojiContainer: {},\n    isMuted: false,\n    isChannelFrozen: false,\n    currentUserId: '',\n    typingMembers: [],\n};\n\nfunction useGetChannel(_a, _b) {\n    var channelUrl = _a.channelUrl, sdkInit = _a.sdkInit, message = _a.message;\n    var sdk = _b.sdk, logger = _b.logger, threadDispatcher = _b.threadDispatcher;\n    useEffect(function () {\n        var _a, _b;\n        // validation check\n        if (sdkInit && channelUrl && (sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel)) {\n            threadDispatcher({\n                type: ThreadContextActionTypes.GET_CHANNEL_START,\n                payload: null,\n            });\n            (_b = (_a = sdk.groupChannel).getChannel) === null || _b === void 0 ? void 0 : _b.call(_a, channelUrl).then(function (groupChannel) {\n                logger.info('Thread | useInitialize: Get channel succeeded', groupChannel);\n                threadDispatcher({\n                    type: ThreadContextActionTypes.GET_CHANNEL_SUCCESS,\n                    payload: { groupChannel: groupChannel },\n                });\n            }).catch(function (error) {\n                logger.info('Thread | useInitialize: Get channel failed', error);\n                threadDispatcher({\n                    type: ThreadContextActionTypes.GET_CHANNEL_FAILURE,\n                    payload: error,\n                });\n            });\n        }\n    }, [message, sdkInit]);\n    /**\n     * We don't use channelUrl here,\n     * because Thread must operate independently of the channel.\n     */\n}\n\nfunction useGetAllEmoji(_a, _b) {\n    var sdk = _a.sdk;\n    var logger = _b.logger, threadDispatcher = _b.threadDispatcher;\n    useEffect(function () {\n        if (sdk === null || sdk === void 0 ? void 0 : sdk.getAllEmoji) { // validation check\n            sdk === null || sdk === void 0 ? void 0 : sdk.getAllEmoji().then(function (emojiContainer) {\n                logger.info('Thread | useGetAllEmoji: Getting emojis succeeded.', emojiContainer);\n                threadDispatcher({\n                    type: ThreadContextActionTypes.SET_EMOJI_CONTAINER,\n                    payload: { emojiContainer: emojiContainer },\n                });\n            }).catch(function (error) {\n                logger.info('Thread | useGetAllEmoji: Getting emojis failed.', error);\n            });\n        }\n    }, [sdk]);\n}\n\nfunction useGetParentMessage(_a, _b) {\n    var channelUrl = _a.channelUrl, sdkInit = _a.sdkInit, parentMessage = _a.parentMessage;\n    var sdk = _b.sdk, logger = _b.logger, threadDispatcher = _b.threadDispatcher;\n    useEffect(function () {\n        var _a, _b, _c;\n        // validation check\n        if (sdkInit && ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.message) === null || _a === void 0 ? void 0 : _a.getMessage) && parentMessage) {\n            threadDispatcher({\n                type: ThreadContextActionTypes.GET_PARENT_MESSAGE_START,\n                payload: null,\n            });\n            var params = {\n                channelUrl: channelUrl,\n                channelType: ChannelType.GROUP,\n                messageId: parentMessage.messageId,\n                includeMetaArray: true,\n                includeReactions: true,\n                includeThreadInfo: true,\n                includeParentMessageInfo: true,\n            };\n            logger.info('Thread | useGetParentMessage: Get parent message start.', params);\n            (_c = (_b = sdk.message).getMessage) === null || _c === void 0 ? void 0 : _c.call(_b, params).then(function (parentMsg) {\n                logger.info('Thread | useGetParentMessage: Get parent message succeeded.', parentMessage);\n                // @ts-ignore\n                parentMsg.ogMetaData = (parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.ogMetaData) || null; // ogMetaData is not included for now\n                threadDispatcher({\n                    type: ThreadContextActionTypes.GET_PARENT_MESSAGE_SUCCESS,\n                    payload: { parentMessage: parentMsg },\n                });\n            }).catch(function (error) {\n                logger.info('Thread | useGetParentMessage: Get parent message failed.', error);\n                threadDispatcher({\n                    type: ThreadContextActionTypes.GET_PARENT_MESSAGE_FAILURE,\n                    payload: error,\n                });\n            });\n        }\n    }, [sdkInit, parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId]);\n    /**\n     * We don't use channelUrl here,\n     * because Thread must operate independently of the channel.\n     */\n}\n\nfunction useHandleThreadPubsubEvents(_a, _b) {\n    var sdkInit = _a.sdkInit, currentChannel = _a.currentChannel, parentMessage = _a.parentMessage;\n    var pubSub = _b.pubSub, threadDispatcher = _b.threadDispatcher;\n    useEffect(function () {\n        var subscriber = new Map();\n        if (pubSub === null || pubSub === void 0 ? void 0 : pubSub.subscribe) {\n            // TODO: subscribe ON_FILE_INFO_UPLOADED\n            subscriber.set(pubSubTopics.SEND_MESSAGE_START, pubSub.subscribe(pubSubTopics.SEND_MESSAGE_START, function (props) {\n                var _a, _b;\n                var channel = props.channel, message = props.message, publishingModules = props.publishingModules;\n                if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url) && (message === null || message === void 0 ? void 0 : message.parentMessageId) === (parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId) && shouldPubSubPublishToThread(publishingModules)) {\n                    // TODO: const clonedMessage = cloneMessage(message);\n                    var pendingMessage = __assign({}, message);\n                    if (message.isMultipleFilesMessage()) {\n                        pendingMessage.fileInfoList = (_b = (_a = message === null || message === void 0 ? void 0 : message.messageParams) === null || _a === void 0 ? void 0 : _a.fileInfoList.map(function (fileInfo) { return (__assign(__assign({}, fileInfo), { url: URL.createObjectURL(fileInfo.file) })); })) !== null && _b !== void 0 ? _b : [];\n                    }\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.SEND_MESSAGE_START,\n                        payload: {\n                            message: pendingMessage,\n                        },\n                    });\n                }\n                scrollIntoLast === null || scrollIntoLast === void 0 ? void 0 : scrollIntoLast();\n            }));\n            subscriber.set(PUBSUB_TOPICS.ON_FILE_INFO_UPLOADED, pubSub.subscribe(PUBSUB_TOPICS.ON_FILE_INFO_UPLOADED, function (props) {\n                var response = props.response, publishingModules = props.publishingModules;\n                if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === response.channelUrl && shouldPubSubPublishToThread(publishingModules)) {\n                    threadDispatcher({\n                        type: ON_FILE_INFO_UPLOADED,\n                        payload: response,\n                    });\n                }\n            }));\n            subscriber.set(pubSubTopics.SEND_USER_MESSAGE, pubSub.subscribe(pubSubTopics.SEND_USER_MESSAGE, function (props) {\n                var _a = props, channel = _a.channel, message = _a.message;\n                if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url)\n                    && (message === null || message === void 0 ? void 0 : message.parentMessageId) === (parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId)) {\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n                        payload: { message: message },\n                    });\n                }\n                scrollIntoLast === null || scrollIntoLast === void 0 ? void 0 : scrollIntoLast();\n            }));\n            subscriber.set(pubSubTopics.SEND_MESSAGE_FAILED, pubSub.subscribe(pubSubTopics.SEND_MESSAGE_FAILED, function (props) {\n                var channel = props.channel, message = props.message, publishingModules = props.publishingModules;\n                if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url) && (message === null || message === void 0 ? void 0 : message.parentMessageId) === (parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId) && shouldPubSubPublishToThread(publishingModules)) {\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n                        payload: { message: message },\n                    });\n                }\n            }));\n            subscriber.set(pubSubTopics.SEND_FILE_MESSAGE, pubSub.subscribe(pubSubTopics.SEND_FILE_MESSAGE, function (props) {\n                var channel = props.channel, message = props.message, publishingModules = props.publishingModules;\n                if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url) && shouldPubSubPublishToThread(publishingModules)) {\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n                        payload: { message: message },\n                    });\n                }\n                scrollIntoLast === null || scrollIntoLast === void 0 ? void 0 : scrollIntoLast();\n            }));\n            subscriber.set(pubSubTopics.UPDATE_USER_MESSAGE, pubSub.subscribe(pubSubTopics.UPDATE_USER_MESSAGE, function (props) {\n                var _a = props, channel = _a.channel, message = _a.message;\n                if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.ON_MESSAGE_UPDATED,\n                        payload: { channel: channel, message: message },\n                    });\n                }\n            }));\n            subscriber.set(pubSubTopics.DELETE_MESSAGE, pubSub.subscribe(pubSubTopics.DELETE_MESSAGE, function (props) {\n                var _a = props, channel = _a.channel, messageId = _a.messageId;\n                if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.ON_MESSAGE_DELETED,\n                        payload: { messageId: messageId },\n                    });\n                }\n            }));\n        }\n        return function () {\n            subscriber === null || subscriber === void 0 ? void 0 : subscriber.forEach(function (s) {\n                try {\n                    s === null || s === void 0 ? void 0 : s.remove();\n                }\n                catch (_a) {\n                    //\n                }\n            });\n        };\n    }, [sdkInit, currentChannel, parentMessage === null || parentMessage === void 0 ? void 0 : parentMessage.messageId]);\n}\n\nfunction useHandleChannelEvents(_a, _b) {\n    var sdk = _a.sdk, currentChannel = _a.currentChannel;\n    var logger = _b.logger, threadDispatcher = _b.threadDispatcher;\n    useEffect(function () {\n        var _a, _b, _c;\n        var handlerId = uuidv4();\n        // validation check\n        if (((_a = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.addGroupChannelHandler)\n            && currentChannel) {\n            var channelHandlerParams = {\n                // message status change\n                onMessageReceived: function (channel, message) {\n                    logger.info('Thread | useHandleChannelEvents: onMessageReceived', { channel: channel, message: message });\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.ON_MESSAGE_RECEIVED,\n                        payload: { channel: channel, message: message },\n                    });\n                },\n                onMessageUpdated: function (channel, message) {\n                    logger.info('Thread | useHandleChannelEvents: onMessageUpdated', { channel: channel, message: message });\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.ON_MESSAGE_UPDATED,\n                        payload: { channel: channel, message: message },\n                    });\n                },\n                onMessageDeleted: function (channel, messageId) {\n                    logger.info('Thread | useHandleChannelEvents: onMessageDeleted', { channel: channel, messageId: messageId });\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.ON_MESSAGE_DELETED,\n                        payload: { channel: channel, messageId: messageId },\n                    });\n                },\n                onReactionUpdated: function (channel, reactionEvent) {\n                    logger.info('Thread | useHandleChannelEvents: onReactionUpdated', { channel: channel, reactionEvent: reactionEvent });\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.ON_REACTION_UPDATED,\n                        payload: { channel: channel, reactionEvent: reactionEvent },\n                    });\n                },\n                // user status change\n                onUserMuted: function (channel, user) {\n                    logger.info('Thread | useHandleChannelEvents: onUserMuted', { channel: channel, user: user });\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.ON_USER_MUTED,\n                        payload: { channel: channel, user: user },\n                    });\n                },\n                onUserUnmuted: function (channel, user) {\n                    logger.info('Thread | useHandleChannelEvents: onUserUnmuted', { channel: channel, user: user });\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.ON_USER_UNMUTED,\n                        payload: { channel: channel, user: user },\n                    });\n                },\n                onUserBanned: function (channel, user) {\n                    logger.info('Thread | useHandleChannelEvents: onUserBanned', { channel: channel, user: user });\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.ON_USER_BANNED,\n                        payload: { channel: channel, user: user },\n                    });\n                },\n                onUserUnbanned: function (channel, user) {\n                    logger.info('Thread | useHandleChannelEvents: onUserUnbanned', { channel: channel, user: user });\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.ON_USER_UNBANNED,\n                        payload: { channel: channel, user: user },\n                    });\n                },\n                onUserLeft: function (channel, user) {\n                    logger.info('Thread | useHandleChannelEvents: onUserLeft', { channel: channel, user: user });\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.ON_USER_LEFT,\n                        payload: { channel: channel, user: user },\n                    });\n                },\n                // channel status change\n                onChannelFrozen: function (channel) {\n                    logger.info('Thread | useHandleChannelEvents: onChannelFrozen', { channel: channel });\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.ON_CHANNEL_FROZEN,\n                        payload: { channel: channel },\n                    });\n                },\n                onChannelUnfrozen: function (channel) {\n                    logger.info('Thread | useHandleChannelEvents: onChannelUnfrozen', { channel: channel });\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.ON_CHANNEL_UNFROZEN,\n                        payload: { channel: channel },\n                    });\n                },\n                onOperatorUpdated: function (channel, users) {\n                    logger.info('Thread | useHandleChannelEvents: onOperatorUpdated', { channel: channel, users: users });\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.ON_OPERATOR_UPDATED,\n                        payload: { channel: channel, users: users },\n                    });\n                },\n                onTypingStatusUpdated: function (channel) {\n                    if (compareIds$1(channel === null || channel === void 0 ? void 0 : channel.url, currentChannel.url)) {\n                        logger.info('Channel | onTypingStatusUpdated', { channel: channel });\n                        var typingMembers = channel.getTypingUsers();\n                        threadDispatcher({\n                            type: ON_TYPING_STATUS_UPDATED,\n                            payload: {\n                                channel: channel,\n                                typingMembers: typingMembers,\n                            },\n                        });\n                    }\n                },\n            };\n            var channelHandler = new GroupChannelHandler(channelHandlerParams);\n            (_c = (_b = sdk.groupChannel).addGroupChannelHandler) === null || _c === void 0 ? void 0 : _c.call(_b, handlerId, channelHandler);\n            logger.info('Thread | useHandleChannelEvents: Added channelHandler in Thread', { handlerId: handlerId, channelHandler: channelHandler });\n        }\n        return function () {\n            var _a, _b, _c;\n            // validation check\n            if (handlerId && ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.removeGroupChannelHandler)) {\n                (_c = (_b = sdk.groupChannel).removeGroupChannelHandler) === null || _c === void 0 ? void 0 : _c.call(_b, handlerId);\n                logger.info('Thread | useHandleChannelEvents: Removed channelHandler in Thread.', handlerId);\n            }\n        };\n    }, [\n        sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel,\n        currentChannel,\n    ]);\n}\n\nfunction useSendFileMessageCallback(_a, _b) {\n    var currentChannel = _a.currentChannel, onBeforeSendFileMessage = _a.onBeforeSendFileMessage;\n    var logger = _b.logger, pubSub = _b.pubSub, threadDispatcher = _b.threadDispatcher;\n    return useCallback(function (file, quoteMessage) {\n        return new Promise(function (resolve, reject) {\n            var _a;\n            var createParamsDefault = function () {\n                var params = {};\n                params.file = file;\n                if (quoteMessage) {\n                    params.isReplyToChannel = true;\n                    params.parentMessageId = quoteMessage.messageId;\n                }\n                return params;\n            };\n            var params = (_a = onBeforeSendFileMessage === null || onBeforeSendFileMessage === void 0 ? void 0 : onBeforeSendFileMessage(file, quoteMessage)) !== null && _a !== void 0 ? _a : createParamsDefault();\n            logger.info('Thread | useSendFileMessageCallback: Sending file message start.', params);\n            currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.sendFileMessage(params).onPending(function (pendingMessage) {\n                threadDispatcher({\n                    type: ThreadContextActionTypes.SEND_MESSAGE_START,\n                    payload: {\n                        /* pubSub is used instead of messagesDispatcher\n                          to avoid redundantly calling `messageActionTypes.SEND_MESSAGE_START` */\n                        // TODO: remove data pollution\n                        message: __assign(__assign({}, pendingMessage), { url: URL.createObjectURL(file), \n                            // pending thumbnail message seems to be failed\n                            requestState: 'pending', isUserMessage: pendingMessage.isUserMessage, isFileMessage: pendingMessage.isFileMessage, isAdminMessage: pendingMessage.isAdminMessage, isMultipleFilesMessage: pendingMessage.isMultipleFilesMessage }),\n                    },\n                });\n                setTimeout(function () { return scrollIntoLast(); }, SCROLL_BOTTOM_DELAY_FOR_SEND);\n            }).onFailed(function (error, message) {\n                message.localUrl = URL.createObjectURL(file);\n                message.file = file;\n                logger.info('Thread | useSendFileMessageCallback: Sending file message failed.', { message: message, error: error });\n                threadDispatcher({\n                    type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n                    payload: { message: message, error: error },\n                });\n                reject(error);\n            }).onSucceeded(function (message) {\n                logger.info('Thread | useSendFileMessageCallback: Sending file message succeeded.', message);\n                pubSub.publish(pubSubTopics.SEND_FILE_MESSAGE, {\n                    channel: currentChannel,\n                    message: message,\n                    publishingModules: [PublishingModuleType.THREAD],\n                });\n                resolve(message);\n            });\n        });\n    }, [currentChannel]);\n}\n\nfunction useUpdateMessageCallback(_a, _b) {\n    var currentChannel = _a.currentChannel, isMentionEnabled = _a.isMentionEnabled;\n    var logger = _b.logger, pubSub = _b.pubSub, threadDispatcher = _b.threadDispatcher;\n    // TODO: add type\n    return useCallback(function (props) {\n        var _a;\n        var messageId = props.messageId, message = props.message, mentionedUsers = props.mentionedUsers, mentionTemplate = props.mentionTemplate;\n        var createParamsDefault = function () {\n            var params = {};\n            params.message = message;\n            if (isMentionEnabled && mentionedUsers && (mentionedUsers === null || mentionedUsers === void 0 ? void 0 : mentionedUsers.length) > 0) {\n                params.mentionedUsers = mentionedUsers;\n            }\n            if (isMentionEnabled && mentionTemplate) {\n                params.mentionedMessageTemplate = mentionTemplate;\n            }\n            else {\n                params.mentionedMessageTemplate = message;\n            }\n            return params;\n        };\n        var params = createParamsDefault();\n        logger.info('Thread | useUpdateMessageCallback: Message update start.', params);\n        (_a = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.updateUserMessage) === null || _a === void 0 ? void 0 : _a.call(currentChannel, messageId, params).then(function (message) {\n            logger.info('Thread | useUpdateMessageCallback: Message update succeeded.', message);\n            threadDispatcher({\n                type: ThreadContextActionTypes.ON_MESSAGE_UPDATED,\n                payload: {\n                    channel: currentChannel,\n                    message: message,\n                },\n            });\n            pubSub.publish(pubSubTopics.UPDATE_USER_MESSAGE, {\n                fromSelector: true,\n                channel: currentChannel,\n                message: message,\n                publishingModules: [PublishingModuleType.THREAD],\n            });\n        });\n    }, [currentChannel, isMentionEnabled]);\n}\n\nfunction useDeleteMessageCallback(_a, _b) {\n    var currentChannel = _a.currentChannel, threadDispatcher = _a.threadDispatcher;\n    var logger = _b.logger;\n    return useCallback(function (message) {\n        logger.info('Thread | useDeleteMessageCallback: Deleting message.', message);\n        var sendingStatus = message.sendingStatus;\n        return new Promise(function (resolve, reject) {\n            var _a;\n            logger.info('Thread | useDeleteMessageCallback: Deleting message requestState:', sendingStatus);\n            // Message is only on local\n            if (sendingStatus === 'failed' || sendingStatus === 'pending') {\n                logger.info('Thread | useDeleteMessageCallback: Deleted message from local:', message);\n                threadDispatcher({\n                    type: ThreadContextActionTypes.ON_MESSAGE_DELETED_BY_REQ_ID,\n                    payload: message.reqId,\n                });\n                resolve();\n            }\n            logger.info('Thread | useDeleteMessageCallback: Deleting message from remote:', sendingStatus);\n            (_a = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.deleteMessage) === null || _a === void 0 ? void 0 : _a.call(currentChannel, message).then(function () {\n                logger.info('Thread | useDeleteMessageCallback: Deleting message success!', message);\n                threadDispatcher({\n                    type: ThreadContextActionTypes.ON_MESSAGE_DELETED,\n                    payload: { message: message, channel: currentChannel },\n                });\n                resolve();\n            }).catch(function (err) {\n                logger.warning('Thread | useDeleteMessageCallback: Deleting message failed!', err);\n                reject(err);\n            });\n        });\n    }, [currentChannel]);\n}\n\nfunction useToggleReactionCallback(_a, _b) {\n    var currentChannel = _a.currentChannel;\n    var logger = _b.logger;\n    return useCallback(function (message, key, isReacted) {\n        var _a, _b;\n        if (isReacted) {\n            (_a = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.deleteReaction) === null || _a === void 0 ? void 0 : _a.call(currentChannel, message, key).then(function (res) {\n                logger.info('Thread | useToggleReactionsCallback: Delete reaction succeeded.', res);\n            }).catch(function (err) {\n                logger.warning('Thread | useToggleReactionsCallback: Delete reaction failed.', err);\n            });\n            return;\n        }\n        (_b = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.addReaction) === null || _b === void 0 ? void 0 : _b.call(currentChannel, message, key).then(function (res) {\n            logger.info('Thread | useToggleReactionsCallback: Add reaction succeeded.', res);\n        }).catch(function (err) {\n            logger.warning('Thread | useToggleReactionsCallback: Add reaction failed.', err);\n        });\n    }, [currentChannel]);\n}\n\nfunction useSendUserMessageCallback(_a, _b) {\n    var isMentionEnabled = _a.isMentionEnabled, currentChannel = _a.currentChannel, onBeforeSendUserMessage = _a.onBeforeSendUserMessage;\n    var logger = _b.logger, pubSub = _b.pubSub, threadDispatcher = _b.threadDispatcher;\n    var sendMessage = useCallback(function (props) {\n        var _a;\n        var message = props.message, quoteMessage = props.quoteMessage, mentionTemplate = props.mentionTemplate, mentionedUsers = props.mentionedUsers;\n        var createDefaultParams = function () {\n            var params = {};\n            params.message = message;\n            var mentionedUsersLength = (mentionedUsers === null || mentionedUsers === void 0 ? void 0 : mentionedUsers.length) || 0;\n            if (isMentionEnabled && mentionedUsersLength) {\n                params.mentionedUsers = mentionedUsers;\n            }\n            if (isMentionEnabled && mentionTemplate && mentionedUsersLength) {\n                params.mentionedMessageTemplate = mentionTemplate;\n            }\n            if (quoteMessage) {\n                params.isReplyToChannel = true;\n                params.parentMessageId = quoteMessage.messageId;\n            }\n            return params;\n        };\n        var params = (_a = onBeforeSendUserMessage === null || onBeforeSendUserMessage === void 0 ? void 0 : onBeforeSendUserMessage(message, quoteMessage)) !== null && _a !== void 0 ? _a : createDefaultParams();\n        logger.info('Thread | useSendUserMessageCallback: Sending user message start.', params);\n        if (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.sendUserMessage) {\n            currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.sendUserMessage(params).onPending(function (pendingMessage) {\n                threadDispatcher({\n                    type: ThreadContextActionTypes.SEND_MESSAGE_START,\n                    payload: { message: pendingMessage },\n                });\n            }).onFailed(function (error, message) {\n                logger.info('Thread | useSendUserMessageCallback: Sending user message failed.', { message: message, error: error });\n                threadDispatcher({\n                    type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n                    payload: { error: error, message: message },\n                });\n            }).onSucceeded(function (message) {\n                logger.info('Thread | useSendUserMessageCallback: Sending user message succeeded.', message);\n                // because Thread doesn't subscribe SEND_USER_MESSAGE\n                pubSub.publish(pubSubTopics.SEND_USER_MESSAGE, {\n                    channel: currentChannel,\n                    message: message,\n                    publishingModules: [PublishingModuleType.THREAD],\n                });\n            });\n        }\n    }, [isMentionEnabled, currentChannel]);\n    return sendMessage;\n}\n\nfunction useResendMessageCallback(_a, _b) {\n    var currentChannel = _a.currentChannel;\n    var logger = _b.logger, pubSub = _b.pubSub, threadDispatcher = _b.threadDispatcher;\n    return useCallback(function (failedMessage) {\n        var _a, _b, _c, _d, _e;\n        if (failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.isResendable) {\n            logger.info('Thread | useResendMessageCallback: Resending failedMessage start.', failedMessage);\n            if (((_a = failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.isUserMessage) === null || _a === void 0 ? void 0 : _a.call(failedMessage)) || (failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.messageType) === MessageType.USER) {\n                try {\n                    currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.resendMessage(failedMessage).onPending(function (message) {\n                        logger.info('Thread | useResendMessageCallback: Resending user message started.', message);\n                        threadDispatcher({\n                            type: ThreadContextActionTypes.RESEND_MESSAGE_START,\n                            payload: { message: message },\n                        });\n                    }).onSucceeded(function (message) {\n                        logger.info('Thread | useResendMessageCallback: Resending user message succeeded.', message);\n                        threadDispatcher({\n                            type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n                            payload: { message: message },\n                        });\n                        pubSub.publish(pubSubTopics.SEND_USER_MESSAGE, {\n                            channel: currentChannel,\n                            message: message,\n                            publishingModules: [PublishingModuleType.THREAD],\n                        });\n                    }).onFailed(function (error) {\n                        logger.warning('Thread | useResendMessageCallback: Resending user message failed.', error);\n                        failedMessage.sendingStatus = SendingStatus.FAILED;\n                        threadDispatcher({\n                            type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n                            payload: { message: failedMessage },\n                        });\n                    });\n                }\n                catch (err) {\n                    logger.warning('Thread | useResendMessageCallback: Resending user message failed.', err);\n                    failedMessage.sendingStatus = SendingStatus.FAILED;\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n                        payload: { message: failedMessage },\n                    });\n                }\n            }\n            else if ((_b = failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.isFileMessage) === null || _b === void 0 ? void 0 : _b.call(failedMessage)) {\n                try {\n                    (_c = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.resendMessage) === null || _c === void 0 ? void 0 : _c.call(currentChannel, failedMessage).onPending(function (message) {\n                        logger.info('Thread | useResendMessageCallback: Resending file message started.', message);\n                        threadDispatcher({\n                            type: ThreadContextActionTypes.RESEND_MESSAGE_START,\n                            payload: { message: message },\n                        });\n                    }).onSucceeded(function (message) {\n                        logger.info('Thread | useResendMessageCallback: Resending file message succeeded.', message);\n                        threadDispatcher({\n                            type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n                            payload: { message: message },\n                        });\n                        pubSub.publish(pubSubTopics.SEND_FILE_MESSAGE, {\n                            channel: currentChannel,\n                            message: failedMessage,\n                            publishingModules: [PublishingModuleType.THREAD],\n                        });\n                    }).onFailed(function (error) {\n                        logger.warning('Thread | useResendMessageCallback: Resending file message failed.', error);\n                        failedMessage.sendingStatus = SendingStatus.FAILED;\n                        threadDispatcher({\n                            type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n                            payload: { message: failedMessage },\n                        });\n                    });\n                }\n                catch (err) {\n                    logger.warning('Thread | useResendMessageCallback: Resending file message failed.', err);\n                    failedMessage.sendingStatus = SendingStatus.FAILED;\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n                        payload: { message: failedMessage },\n                    });\n                }\n            }\n            else if ((_d = failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.isMultipleFilesMessage) === null || _d === void 0 ? void 0 : _d.call(failedMessage)) {\n                try {\n                    (_e = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.resendMessage) === null || _e === void 0 ? void 0 : _e.call(currentChannel, failedMessage).onPending(function (message) {\n                        logger.info('Thread | useResendMessageCallback: Resending multiple files message started.', message);\n                        threadDispatcher({\n                            type: ThreadContextActionTypes.RESEND_MESSAGE_START,\n                            payload: { message: message },\n                        });\n                    }).onFileUploaded(function (requestId, index, uploadableFileInfo, error) {\n                        logger.info('Thread | useResendMessageCallback: onFileUploaded during resending multiple files message.', {\n                            requestId: requestId,\n                            index: index,\n                            error: error,\n                            uploadableFileInfo: uploadableFileInfo,\n                        });\n                        pubSub.publish(pubSubTopics.ON_FILE_INFO_UPLOADED, {\n                            response: {\n                                channelUrl: currentChannel.url,\n                                requestId: requestId,\n                                index: index,\n                                uploadableFileInfo: uploadableFileInfo,\n                                error: error,\n                            },\n                            publishingModules: [PublishingModuleType.THREAD],\n                        });\n                    }).onSucceeded(function (message) {\n                        logger.info('Thread | useResendMessageCallback: Resending MFM succeeded.', message);\n                        threadDispatcher({\n                            type: ThreadContextActionTypes.SEND_MESSAGE_SUCESS,\n                            payload: { message: message },\n                        });\n                        pubSub.publish(pubSubTopics.SEND_FILE_MESSAGE, {\n                            channel: currentChannel,\n                            message: message,\n                            publishingModules: [PublishingModuleType.THREAD],\n                        });\n                    }).onFailed(function (error, message) {\n                        logger.warning('Thread | useResendMessageCallback: Resending MFM failed.', error);\n                        threadDispatcher({\n                            type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n                            payload: { message: message },\n                        });\n                    });\n                }\n                catch (err) {\n                    logger.warning('Thread | useResendMessageCallback: Resending MFM failed.', err);\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n                        payload: { message: failedMessage },\n                    });\n                }\n            }\n            else {\n                logger.warning('Thread | useResendMessageCallback: Message is not resendable.', failedMessage);\n                failedMessage.sendingStatus = SendingStatus.FAILED;\n                threadDispatcher({\n                    type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n                    payload: { message: failedMessage },\n                });\n            }\n        }\n    }, [currentChannel]);\n}\n\nvar useSendVoiceMessageCallback = function (_a, _b) {\n    var currentChannel = _a.currentChannel, onBeforeSendVoiceMessage = _a.onBeforeSendVoiceMessage;\n    var logger = _b.logger, pubSub = _b.pubSub, threadDispatcher = _b.threadDispatcher;\n    var sendMessage = useCallback(function (file, duration, quoteMessage) {\n        var messageParams = (onBeforeSendVoiceMessage\n            && typeof onBeforeSendVoiceMessage === 'function')\n            ? onBeforeSendVoiceMessage(file, quoteMessage)\n            : {\n                file: file,\n                fileName: VOICE_MESSAGE_FILE_NAME,\n                mimeType: VOICE_MESSAGE_MIME_TYPE,\n                metaArrays: [\n                    new MessageMetaArray({\n                        key: META_ARRAY_VOICE_DURATION_KEY,\n                        value: [\"\".concat(duration)],\n                    }),\n                    new MessageMetaArray({\n                        key: META_ARRAY_MESSAGE_TYPE_KEY,\n                        value: [META_ARRAY_MESSAGE_TYPE_VALUE__VOICE],\n                    }),\n                ],\n            };\n        if (quoteMessage) {\n            messageParams.isReplyToChannel = true;\n            messageParams.parentMessageId = quoteMessage.messageId;\n        }\n        logger.info('Thread | useSendVoiceMessageCallback:  Start sending voice message', messageParams);\n        currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.sendFileMessage(messageParams).onPending(function (pendingMessage) {\n            threadDispatcher({\n                type: ThreadContextActionTypes.SEND_MESSAGE_START,\n                payload: {\n                    /* pubSub is used instead of messagesDispatcher\n                    to avoid redundantly calling `messageActionTypes.SEND_MESSAGE_START` */\n                    // TODO: remove data pollution\n                    message: __assign(__assign({}, pendingMessage), { url: URL.createObjectURL(file), \n                        // pending thumbnail message seems to be failed\n                        requestState: 'pending', isUserMessage: pendingMessage.isUserMessage, isFileMessage: pendingMessage.isFileMessage, isAdminMessage: pendingMessage.isAdminMessage, isMultipleFilesMessage: pendingMessage.isMultipleFilesMessage }),\n                },\n            });\n            setTimeout(function () { return scrollIntoLast(); }, SCROLL_BOTTOM_DELAY_FOR_SEND);\n        }).onFailed(function (error, message) {\n            message.localUrl = URL.createObjectURL(file);\n            message.file = file;\n            logger.info('Thread | useSendVoiceMessageCallback: Sending voice message failed.', { message: message, error: error });\n            threadDispatcher({\n                type: ThreadContextActionTypes.SEND_MESSAGE_FAILURE,\n                payload: { message: message, error: error },\n            });\n        }).onSucceeded(function (message) {\n            logger.info('Thread | useSendVoiceMessageCallback: Sending voice message succeeded.', message);\n            pubSub.publish(pubSubTopics.SEND_FILE_MESSAGE, {\n                channel: currentChannel,\n                message: message,\n                publishingModules: [PublishingModuleType.THREAD],\n            });\n        });\n    }, [\n        currentChannel,\n        onBeforeSendVoiceMessage,\n    ]);\n    return sendMessage;\n};\n\nfunction getThreadMessageListParams(params) {\n    return __assign({ prevResultSize: PREV_THREADS_FETCH_SIZE, nextResultSize: NEXT_THREADS_FETCH_SIZE, includeMetaArray: true }, params);\n}\nvar useThreadFetchers = function (_a) {\n    var isReactionEnabled = _a.isReactionEnabled, anchorMessage = _a.anchorMessage, staleParentMessage = _a.parentMessage, threadDispatcher = _a.threadDispatcher, logger = _a.logger, oldestMessageTimeStamp = _a.oldestMessageTimeStamp, latestMessageTimeStamp = _a.latestMessageTimeStamp, threadListState = _a.threadListState;\n    var stores = useSendbirdStateContext().stores;\n    var timestamp = (anchorMessage === null || anchorMessage === void 0 ? void 0 : anchorMessage.createdAt) || 0;\n    var initialize = useCallback(function (callback) { return __awaiter(void 0, void 0, void 0, function () {\n        var params, _a, threadedMessages_1, parentMessage, error_1;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (!stores.sdkStore.initialized || !staleParentMessage)\n                        return [2 /*return*/];\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.INITIALIZE_THREAD_LIST_START,\n                        payload: null,\n                    });\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, 3, , 4]);\n                    params = getThreadMessageListParams({ includeReactions: isReactionEnabled });\n                    logger.info('Thread | useGetThreadList: Initialize thread list start.', { timestamp: timestamp, params: params });\n                    return [4 /*yield*/, staleParentMessage.getThreadedMessagesByTimestamp(timestamp, params)];\n                case 2:\n                    _a = _b.sent(), threadedMessages_1 = _a.threadedMessages, parentMessage = _a.parentMessage;\n                    logger.info('Thread | useGetThreadList: Initialize thread list succeeded.', { staleParentMessage: staleParentMessage, threadedMessages: threadedMessages_1 });\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.INITIALIZE_THREAD_LIST_SUCCESS,\n                        payload: { parentMessage: parentMessage, anchorMessage: anchorMessage, threadedMessages: threadedMessages_1 },\n                    });\n                    setTimeout(function () { return callback === null || callback === void 0 ? void 0 : callback(threadedMessages_1); });\n                    return [3 /*break*/, 4];\n                case 3:\n                    error_1 = _b.sent();\n                    logger.info('Thread | useGetThreadList: Initialize thread list failed.', error_1);\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.INITIALIZE_THREAD_LIST_FAILURE,\n                        payload: error_1,\n                    });\n                    return [3 /*break*/, 4];\n                case 4: return [2 /*return*/];\n            }\n        });\n    }); }, [stores.sdkStore.initialized, staleParentMessage, anchorMessage, isReactionEnabled]);\n    var loadPrevious = useCallback(function (callback) { return __awaiter(void 0, void 0, void 0, function () {\n        var params, _a, threadedMessages_2, parentMessage, error_2;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (threadListState !== ThreadListStateTypes.INITIALIZED || oldestMessageTimeStamp === 0 || !staleParentMessage)\n                        return [2 /*return*/];\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.GET_PREV_MESSAGES_START,\n                        payload: null,\n                    });\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, 3, , 4]);\n                    params = getThreadMessageListParams({ nextResultSize: 0, includeReactions: isReactionEnabled });\n                    return [4 /*yield*/, staleParentMessage.getThreadedMessagesByTimestamp(oldestMessageTimeStamp, params)];\n                case 2:\n                    _a = _b.sent(), threadedMessages_2 = _a.threadedMessages, parentMessage = _a.parentMessage;\n                    logger.info('Thread | useGetPrevThreadsCallback: Fetch prev threads succeeded.', { parentMessage: parentMessage, threadedMessages: threadedMessages_2 });\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.GET_PREV_MESSAGES_SUCESS,\n                        payload: { parentMessage: parentMessage, threadedMessages: threadedMessages_2 },\n                    });\n                    setTimeout(function () { return callback === null || callback === void 0 ? void 0 : callback(threadedMessages_2); });\n                    return [3 /*break*/, 4];\n                case 3:\n                    error_2 = _b.sent();\n                    logger.info('Thread | useGetPrevThreadsCallback: Fetch prev threads failed.', error_2);\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.GET_PREV_MESSAGES_FAILURE,\n                        payload: error_2,\n                    });\n                    return [3 /*break*/, 4];\n                case 4: return [2 /*return*/];\n            }\n        });\n    }); }, [threadListState, oldestMessageTimeStamp, isReactionEnabled, staleParentMessage]);\n    var loadNext = useCallback(function (callback) { return __awaiter(void 0, void 0, void 0, function () {\n        var params, _a, threadedMessages_3, parentMessage, error_3;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (threadListState !== ThreadListStateTypes.INITIALIZED || latestMessageTimeStamp === 0 || !staleParentMessage)\n                        return [2 /*return*/];\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.GET_NEXT_MESSAGES_START,\n                        payload: null,\n                    });\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, 3, , 4]);\n                    params = getThreadMessageListParams({ prevResultSize: 0, includeReactions: isReactionEnabled });\n                    return [4 /*yield*/, staleParentMessage.getThreadedMessagesByTimestamp(latestMessageTimeStamp, params)];\n                case 2:\n                    _a = _b.sent(), threadedMessages_3 = _a.threadedMessages, parentMessage = _a.parentMessage;\n                    logger.info('Thread | useGetNextThreadsCallback: Fetch next threads succeeded.', { parentMessage: parentMessage, threadedMessages: threadedMessages_3 });\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.GET_NEXT_MESSAGES_SUCESS,\n                        payload: { parentMessage: parentMessage, threadedMessages: threadedMessages_3 },\n                    });\n                    setTimeout(function () { return callback === null || callback === void 0 ? void 0 : callback(threadedMessages_3); });\n                    return [3 /*break*/, 4];\n                case 3:\n                    error_3 = _b.sent();\n                    logger.info('Thread | useGetNextThreadsCallback: Fetch next threads failed.', error_3);\n                    threadDispatcher({\n                        type: ThreadContextActionTypes.GET_NEXT_MESSAGES_FAILURE,\n                        payload: error_3,\n                    });\n                    return [3 /*break*/, 4];\n                case 4: return [2 /*return*/];\n            }\n        });\n    }); }, [threadListState, latestMessageTimeStamp, isReactionEnabled, staleParentMessage]);\n    return {\n        initialize: initialize,\n        loadPrevious: loadPrevious,\n        loadNext: loadNext,\n    };\n};\n\nvar ThreadContext = React__default.createContext(null);\nvar ThreadProvider = function (props) {\n    var _a, _b;\n    var children = props.children, channelUrl = props.channelUrl, onHeaderActionClick = props.onHeaderActionClick, onMoveToParentMessage = props.onMoveToParentMessage, onBeforeSendUserMessage = props.onBeforeSendUserMessage, onBeforeSendFileMessage = props.onBeforeSendFileMessage, onBeforeSendVoiceMessage = props.onBeforeSendVoiceMessage, onBeforeSendMultipleFilesMessage = props.onBeforeSendMultipleFilesMessage, onBeforeDownloadFileMessage = props.onBeforeDownloadFileMessage, isMultipleFilesMessageEnabled = props.isMultipleFilesMessageEnabled, \n    // User Profile\n    disableUserProfile = props.disableUserProfile, renderUserProfile = props.renderUserProfile;\n    var propsMessage = props === null || props === void 0 ? void 0 : props.message;\n    var propsParentMessage = getParentMessageFrom(propsMessage);\n    // Context from SendbirdProvider\n    var globalStore = useSendbirdStateContext();\n    var stores = globalStore.stores, config = globalStore.config;\n    // // stores\n    var sdkStore = stores.sdkStore, userStore = stores.userStore;\n    var sdk = sdkStore.sdk;\n    var user = userStore.user;\n    var sdkInit = sdkStore === null || sdkStore === void 0 ? void 0 : sdkStore.initialized;\n    // // config\n    var logger = config.logger, pubSub = config.pubSub, onUserProfileMessage = config.onUserProfileMessage;\n    var isMentionEnabled = config.groupChannel.enableMention;\n    var isReactionEnabled = config.groupChannel.enableReactions;\n    // dux of Thread\n    var _c = useReducer(reducer, initialState), threadStore = _c[0], threadDispatcher = _c[1];\n    var currentChannel = threadStore.currentChannel, allThreadMessages = threadStore.allThreadMessages, localThreadMessages = threadStore.localThreadMessages, parentMessage = threadStore.parentMessage, channelState = threadStore.channelState, threadListState = threadStore.threadListState, parentMessageState = threadStore.parentMessageState, hasMorePrev = threadStore.hasMorePrev, hasMoreNext = threadStore.hasMoreNext, emojiContainer = threadStore.emojiContainer, isMuted = threadStore.isMuted, isChannelFrozen = threadStore.isChannelFrozen, currentUserId = threadStore.currentUserId, typingMembers = threadStore.typingMembers;\n    // Initialization\n    useEffect(function () {\n        threadDispatcher({\n            type: ThreadContextActionTypes.INIT_USER_ID,\n            payload: user === null || user === void 0 ? void 0 : user.userId,\n        });\n    }, [user]);\n    useGetChannel({\n        channelUrl: channelUrl,\n        sdkInit: sdkInit,\n        message: propsMessage,\n    }, { sdk: sdk, logger: logger, threadDispatcher: threadDispatcher });\n    useGetParentMessage({\n        channelUrl: channelUrl,\n        sdkInit: sdkInit,\n        parentMessage: propsParentMessage,\n    }, { sdk: sdk, logger: logger, threadDispatcher: threadDispatcher });\n    useGetAllEmoji({ sdk: sdk }, { logger: logger, threadDispatcher: threadDispatcher });\n    // Handle channel events\n    useHandleChannelEvents({\n        sdk: sdk,\n        currentChannel: currentChannel,\n    }, { logger: logger, threadDispatcher: threadDispatcher });\n    useHandleThreadPubsubEvents({\n        sdkInit: sdkInit,\n        currentChannel: currentChannel,\n        parentMessage: parentMessage,\n    }, { logger: logger, pubSub: pubSub, threadDispatcher: threadDispatcher });\n    var _d = useThreadFetchers({\n        parentMessage: parentMessage,\n        // anchorMessage should be null when parentMessage doesn't exist\n        anchorMessage: (propsMessage === null || propsMessage === void 0 ? void 0 : propsMessage.messageId) !== (propsParentMessage === null || propsParentMessage === void 0 ? void 0 : propsParentMessage.messageId) ? propsMessage || undefined : undefined,\n        logger: logger,\n        isReactionEnabled: isReactionEnabled,\n        threadDispatcher: threadDispatcher,\n        threadListState: threadListState,\n        oldestMessageTimeStamp: ((_a = allThreadMessages[0]) === null || _a === void 0 ? void 0 : _a.createdAt) || 0,\n        latestMessageTimeStamp: ((_b = allThreadMessages[allThreadMessages.length - 1]) === null || _b === void 0 ? void 0 : _b.createdAt) || 0,\n    }), initialize = _d.initialize, loadPrevious = _d.loadPrevious, loadNext = _d.loadNext;\n    useEffect(function () {\n        if (stores.sdkStore.initialized && config.isOnline) {\n            initialize();\n        }\n    }, [stores.sdkStore.initialized, config.isOnline, initialize]);\n    var toggleReaction = useToggleReactionCallback({ currentChannel: currentChannel }, { logger: logger });\n    // Send Message Hooks\n    var sendMessage = useSendUserMessageCallback({\n        isMentionEnabled: isMentionEnabled,\n        currentChannel: currentChannel,\n        onBeforeSendUserMessage: onBeforeSendUserMessage,\n    }, {\n        logger: logger,\n        pubSub: pubSub,\n        threadDispatcher: threadDispatcher,\n    });\n    var sendFileMessage = useSendFileMessageCallback({\n        currentChannel: currentChannel,\n        onBeforeSendFileMessage: onBeforeSendFileMessage,\n    }, {\n        logger: logger,\n        pubSub: pubSub,\n        threadDispatcher: threadDispatcher,\n    });\n    var sendVoiceMessage = useSendVoiceMessageCallback({\n        currentChannel: currentChannel,\n        onBeforeSendVoiceMessage: onBeforeSendVoiceMessage,\n    }, {\n        logger: logger,\n        pubSub: pubSub,\n        threadDispatcher: threadDispatcher,\n    });\n    var sendMultipleFilesMessage = useSendMultipleFilesMessage({\n        currentChannel: currentChannel,\n        onBeforeSendMultipleFilesMessage: onBeforeSendMultipleFilesMessage,\n        publishingModules: [PublishingModuleType.THREAD],\n    }, {\n        logger: logger,\n        pubSub: pubSub,\n    })[0];\n    var resendMessage = useResendMessageCallback({\n        currentChannel: currentChannel,\n    }, { logger: logger, pubSub: pubSub, threadDispatcher: threadDispatcher });\n    var updateMessage = useUpdateMessageCallback({\n        currentChannel: currentChannel,\n        isMentionEnabled: isMentionEnabled,\n    }, { logger: logger, pubSub: pubSub, threadDispatcher: threadDispatcher });\n    var deleteMessage = useDeleteMessageCallback({ currentChannel: currentChannel, threadDispatcher: threadDispatcher }, { logger: logger });\n    // memo\n    var nicknamesMap = useMemo(function () { return ((config.groupChannel.replyType !== 'none' && currentChannel)\n        ? getNicknamesMapFromMembers(currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.members)\n        : new Map()); }, [currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.members]);\n    return (React__default.createElement(ThreadContext.Provider, { value: {\n            // ThreadProviderProps\n            channelUrl: channelUrl,\n            message: propsMessage,\n            onHeaderActionClick: onHeaderActionClick,\n            onMoveToParentMessage: onMoveToParentMessage,\n            isMultipleFilesMessageEnabled: isMultipleFilesMessageEnabled,\n            onBeforeDownloadFileMessage: onBeforeDownloadFileMessage,\n            // ThreadContextInitialState\n            currentChannel: currentChannel,\n            allThreadMessages: allThreadMessages,\n            localThreadMessages: localThreadMessages,\n            parentMessage: parentMessage,\n            channelState: channelState,\n            threadListState: threadListState,\n            parentMessageState: parentMessageState,\n            hasMorePrev: hasMorePrev,\n            hasMoreNext: hasMoreNext,\n            emojiContainer: emojiContainer,\n            // hooks\n            fetchPrevThreads: loadPrevious,\n            fetchNextThreads: loadNext,\n            toggleReaction: toggleReaction,\n            sendMessage: sendMessage,\n            sendFileMessage: sendFileMessage,\n            sendVoiceMessage: sendVoiceMessage,\n            sendMultipleFilesMessage: sendMultipleFilesMessage,\n            resendMessage: resendMessage,\n            updateMessage: updateMessage,\n            deleteMessage: deleteMessage,\n            // context\n            nicknamesMap: nicknamesMap,\n            isMuted: isMuted,\n            isChannelFrozen: isChannelFrozen,\n            currentUserId: currentUserId,\n            typingMembers: typingMembers,\n        } },\n        React__default.createElement(UserProfileProvider, { disableUserProfile: disableUserProfile !== null && disableUserProfile !== void 0 ? disableUserProfile : !config.common.enableUsingDefaultUserProfile, renderUserProfile: renderUserProfile, onUserProfileMessage: onUserProfileMessage }, children)));\n};\nvar useThreadContext = function () {\n    var context = React__default.useContext(ThreadContext);\n    if (!context)\n        throw new Error('ThreadContext not found. Use within the Thread module');\n    return context;\n};\n\nexport { ThreadProvider, useThreadContext };\n//# sourceMappingURL=context.js.map\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module"}