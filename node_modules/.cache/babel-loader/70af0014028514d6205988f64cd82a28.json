{"ast":null,"code":"import React__default, { useEffect, useCallback, useRef, useState, useReducer, useMemo } from 'react';\nimport { U as UserProfileProvider } from '../chunks/bundle-BrTJ5Zbd.js';\nimport { useSendbirdStateContext } from '../useSendbirdStateContext.js';\nimport { T as ThreadReplySelectType } from '../chunks/bundle-CveCFQYP.js';\nimport { m as mergeAndSortMessages, p as passUnsuccessfullMessages, s as scrollIntoLast, d as scrollToRenderedMessage, g as getAllEmojisMapFromEmojiContainer, e as getNicknamesMapFromMembers } from '../chunks/bundle-CMLImr6T.js';\nimport { g as getIsReactionEnabled } from '../chunks/bundle-BNDaXsLn.js';\nimport { _ as __assign, c as __spreadArray } from '../chunks/bundle-BQi9-O76.js';\nimport { f as format } from '../chunks/bundle-CAdqcqOm.js';\nimport { SendingStatus, ReplyType, MessageMetaArray } from '@sendbird/chat/message';\nimport { K, k as isSendableMessage, a1 as S, a3 as filterMessageListParams } from '../chunks/bundle-DxTN4_0p.js';\nimport { R as RESET_MESSAGES, F as FETCH_INITIAL_MESSAGES_START, a as FETCH_INITIAL_MESSAGES_SUCCESS, c as FETCH_PREV_MESSAGES_SUCCESS, d as FETCH_NEXT_MESSAGES_SUCCESS, b as FETCH_INITIAL_MESSAGES_FAILURE, e as FETCH_PREV_MESSAGES_FAILURE, f as FETCH_NEXT_MESSAGES_FAILURE, S as SEND_MESSAGE_START, g as SEND_MESSAGE_SUCCESS, h as SEND_MESSAGE_FAILURE, i as SET_CURRENT_CHANNEL, j as SET_CHANNEL_INVALID, O as ON_MESSAGE_RECEIVED, k as ON_MESSAGE_UPDATED, l as ON_MESSAGE_THREAD_INFO_UPDATED, m as RESEND_MESSAGE_START, n as MARK_AS_READ, o as ON_MESSAGE_DELETED, p as ON_MESSAGE_DELETED_BY_REQ_ID, q as SET_EMOJI_CONTAINER, r as ON_REACTION_UPDATED, M as MESSAGE_LIST_PARAMS_CHANGED, s as ON_FILE_INFO_UPLOADED, t as ON_TYPING_STATUS_UPDATED, u as channelActions } from '../chunks/bundle-CpjASiz4.js';\nimport { c as compareIds } from '../chunks/bundle-CZUYMubi.js';\nimport { P as PREV_RESULT_SIZE, N as NEXT_RESULT_SIZE, u as useInitialMessagesFetch } from '../chunks/bundle-chiYJ8F8.js';\nimport { GroupChannelHandler } from '@sendbird/chat/groupChannel';\nimport { u as uuidv4 } from '../chunks/bundle-etuaqevl.js';\nimport { u as useReconnectOnIdle } from '../chunks/bundle-H8J7tAed.js';\nimport { c as SCROLL_BOTTOM_DELAY_FOR_FETCH, d as SCROLL_BOTTOM_DELAY_FOR_SEND, e as VOICE_MESSAGE_FILE_NAME, a as VOICE_MESSAGE_MIME_TYPE, M as META_ARRAY_VOICE_DURATION_KEY, f as META_ARRAY_MESSAGE_TYPE_KEY, g as META_ARRAY_MESSAGE_TYPE_VALUE__VOICE } from '../chunks/bundle-DCMGp6rH.js';\nimport { p as pubSubTopics, P as PublishingModuleType, b as PUBSUB_TOPICS, s as shouldPubSubPublishToChannel } from '../chunks/bundle-b6TpX_JP.js';\nimport { u as useToggleReactionCallback } from '../chunks/bundle-y29vL7zu.js';\nimport { g as getCaseResolvedReplyType, a as getCaseResolvedThreadReplySelectType } from '../chunks/bundle-fHeMHhND.js';\nimport { u as useSendMultipleFilesMessage } from '../chunks/bundle-T6fVCCb7.js';\nimport '../withSendbird.js';\nimport '../chunks/bundle-CA85nVxp.js';\nimport '../chunks/bundle-bdDHjHH6.js';\nimport '../utils/message/getOutgoingMessageState.js';\nimport '../chunks/bundle-CNWAfTVw.js';\nvar initialState = {\n  initialized: false,\n  loading: true,\n  allMessages: [],\n  /**\n   * localMessages: pending & failed messages\n   */\n  localMessages: [],\n  currentGroupChannel: null,\n  // for scrollup\n  hasMorePrev: false,\n  oldestMessageTimeStamp: 0,\n  // for scroll down\n  // onScrollDownCallback is added for navigation to different timestamps on messageSearch\n  // hasMorePrev, onScrollCallback -> scroll up(default behavior)\n  // hasMoreNext, onScrollDownCallback -> scroll down\n  hasMoreNext: false,\n  latestMessageTimeStamp: 0,\n  emojiContainer: {\n    emojiCategories: [],\n    emojiHash: ''\n  },\n  /** @deprecated Please use `unreadSinceDate` instead. * */\n  unreadSince: null,\n  /**\n   * unreadSinceDate is a date information about message unread.\n   * It's used only for the {unreadSinceDate && <UnreadCount unreadSinceDate={unreadSinceDate} />}\n   */\n  unreadSinceDate: null,\n  isInvalid: false,\n  readStatus: null,\n  messageListParams: null,\n  typingMembers: []\n};\nvar getOldestMessageTimeStamp = function (messages) {\n  if (messages === void 0) {\n    messages = [];\n  }\n  var oldestMessage = messages[0];\n  return oldestMessage && oldestMessage.createdAt || null;\n};\nvar getLatestMessageTimeStamp = function (messages) {\n  if (messages === void 0) {\n    messages = [];\n  }\n  var latestMessage = messages[messages.length - 1];\n  return latestMessage && latestMessage.createdAt || null;\n};\nfunction hasReqId(message) {\n  return 'reqId' in message;\n}\nfunction channelReducer(state, action) {\n  return K(action).with({\n    type: RESET_MESSAGES\n  }, function () {\n    return __assign(__assign({}, state), {\n      // when user switches channel, if the previous channel `hasMorePrev`\n      // the onScroll gets called twice, setting hasMorePrev false prevents this\n      hasMorePrev: false,\n      hasMoreNext: false,\n      allMessages: [],\n      localMessages: []\n    });\n  }).with({\n    type: FETCH_INITIAL_MESSAGES_START\n  }, function () {\n    return __assign(__assign({}, state), {\n      loading: true,\n      allMessages: state.allMessages.filter(function (m) {\n        return isSendableMessage(m) ? m.sendingStatus !== SendingStatus.SUCCEEDED : true;\n      }),\n      localMessages: []\n    });\n  }).with({\n    type: FETCH_INITIAL_MESSAGES_SUCCESS\n  }, function (action) {\n    var _a;\n    var _b = action.payload,\n      currentGroupChannel = _b.currentGroupChannel,\n      messages = _b.messages;\n    if (!((currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) === ((_a = state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url))) {\n      return state;\n    }\n    var oldestMessageTimeStamp = getOldestMessageTimeStamp(messages);\n    var latestMessageTimeStamp = getLatestMessageTimeStamp(messages);\n    return __assign(__assign({}, state), {\n      loading: false,\n      initialized: true,\n      hasMorePrev: true,\n      hasMoreNext: true,\n      oldestMessageTimeStamp: oldestMessageTimeStamp,\n      latestMessageTimeStamp: latestMessageTimeStamp,\n      allMessages: __spreadArray([], messages, true)\n    });\n  }).with({\n    type: FETCH_PREV_MESSAGES_SUCCESS\n  }, function (action) {\n    var _a, _b, _c, _d;\n    var _e = action.payload,\n      currentGroupChannel = _e.currentGroupChannel,\n      messages = _e.messages;\n    if (!((currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) === ((_a = state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url))) {\n      return state;\n    }\n    var hasMorePrev = ((_b = messages === null || messages === void 0 ? void 0 : messages.length) !== null && _b !== void 0 ? _b : 0) >= ((_d = (_c = state === null || state === void 0 ? void 0 : state.messageListParams) === null || _c === void 0 ? void 0 : _c.prevResultSize) !== null && _d !== void 0 ? _d : PREV_RESULT_SIZE) + 1;\n    var oldestMessageTimeStamp = getOldestMessageTimeStamp(messages);\n    // Remove duplicated messages\n    var duplicatedMessageIds = [];\n    var updatedOldMessages = state.allMessages.map(function (msg) {\n      var duplicatedMessage = messages.find(function (_a) {\n        var messageId = _a.messageId;\n        return compareIds(messageId, msg.messageId);\n      });\n      if (!duplicatedMessage) {\n        return msg;\n      }\n      duplicatedMessageIds.push(duplicatedMessage.messageId);\n      return duplicatedMessage.updatedAt > msg.updatedAt ? duplicatedMessage : msg;\n    });\n    var filteredNewMessages = duplicatedMessageIds.length > 0 ? messages.filter(function (msg) {\n      return !duplicatedMessageIds.find(function (messageId) {\n        return compareIds(messageId, msg.messageId);\n      });\n    }) : messages;\n    return __assign(__assign({}, state), {\n      hasMorePrev: hasMorePrev,\n      oldestMessageTimeStamp: oldestMessageTimeStamp,\n      allMessages: __spreadArray(__spreadArray([], filteredNewMessages, true), updatedOldMessages, true)\n    });\n  }).with({\n    type: FETCH_NEXT_MESSAGES_SUCCESS\n  }, function (action) {\n    var _a, _b, _c, _d;\n    var _e = action.payload,\n      currentGroupChannel = _e.currentGroupChannel,\n      messages = _e.messages;\n    if (!((currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) === ((_a = state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url))) {\n      return state;\n    }\n    var hasMoreNext = ((_b = messages === null || messages === void 0 ? void 0 : messages.length) !== null && _b !== void 0 ? _b : 0) === ((_d = (_c = state === null || state === void 0 ? void 0 : state.messageListParams) === null || _c === void 0 ? void 0 : _c.nextResultSize) !== null && _d !== void 0 ? _d : NEXT_RESULT_SIZE) + 1;\n    var latestMessageTimeStamp = getLatestMessageTimeStamp(messages);\n    // sort ~\n    var sortedMessages = mergeAndSortMessages(state.allMessages, messages);\n    return __assign(__assign({}, state), {\n      hasMoreNext: hasMoreNext,\n      latestMessageTimeStamp: latestMessageTimeStamp,\n      allMessages: sortedMessages\n    });\n  }).with({\n    type: S.union(FETCH_INITIAL_MESSAGES_FAILURE, FETCH_PREV_MESSAGES_FAILURE, FETCH_NEXT_MESSAGES_FAILURE)\n  }, function (action) {\n    var _a;\n    var currentGroupChannel = action.payload.currentGroupChannel;\n    if ((currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) !== ((_a = state === null || state === void 0 ? void 0 : state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url)) return state;\n    // It shows something went wrong screen when fetching initial messages failed.\n    var shouldInvalid = [FETCH_INITIAL_MESSAGES_FAILURE].includes(action.type);\n    return __assign(__assign({}, state), {\n      loading: false,\n      isInvalid: shouldInvalid,\n      initialized: false,\n      allMessages: [],\n      hasMorePrev: false,\n      hasMoreNext: false,\n      oldestMessageTimeStamp: null,\n      latestMessageTimeStamp: null\n    });\n  }).with({\n    type: SEND_MESSAGE_START\n  }, function (action) {\n    // Message should not be spread here\n    // it will loose some methods like `isUserMessage`\n    return __assign(__assign({}, state), {\n      localMessages: __spreadArray(__spreadArray([], state.localMessages, true), [action.payload], false)\n    });\n  }).with({\n    type: SEND_MESSAGE_SUCCESS\n  }, function (action) {\n    var message = action.payload;\n    /**\n     * Admin messages do not have reqId. We need to include them.\n     */\n    var filteredMessages = state.allMessages.filter(function (m) {\n      return !hasReqId(m) || (m === null || m === void 0 ? void 0 : m.reqId) !== (message === null || message === void 0 ? void 0 : message.reqId);\n    });\n    // [Policy] Pending messages and failed messages\n    // must always be at the end of the message list\n    return __assign(__assign({}, state), {\n      allMessages: __spreadArray(__spreadArray([], filteredMessages, true), [message], false),\n      localMessages: state.localMessages.filter(function (m) {\n        return hasReqId(m) && (m === null || m === void 0 ? void 0 : m.reqId) !== (message === null || message === void 0 ? void 0 : message.reqId);\n      })\n    });\n  }).with({\n    type: SEND_MESSAGE_FAILURE\n  }, function (action) {\n    // @ts-ignore\n    action.payload.failed = true;\n    return __assign(__assign({}, state), {\n      localMessages: state.localMessages.map(function (m) {\n        return compareIds(hasReqId(m) && m.reqId, action.payload.reqId) ? action.payload : m;\n      })\n    });\n  }).with({\n    type: SET_CURRENT_CHANNEL\n  }, function (action) {\n    return __assign(__assign({}, state), {\n      currentGroupChannel: action.payload,\n      isInvalid: false\n    });\n  }).with({\n    type: SET_CHANNEL_INVALID\n  }, function () {\n    return __assign(__assign({}, state), {\n      currentGroupChannel: null,\n      allMessages: [],\n      localMessages: [],\n      isInvalid: true\n    });\n  }).with({\n    type: ON_MESSAGE_RECEIVED\n  }, function (action) {\n    var _a, _b;\n    var _c = action.payload,\n      channel = _c.channel,\n      message = _c.message;\n    var members = channel.members;\n    var sender = message.sender;\n    var currentGroupChannel = state.currentGroupChannel;\n    var currentGroupChannelUrl = currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url;\n    if (!compareIds(channel === null || channel === void 0 ? void 0 : channel.url, currentGroupChannelUrl)) {\n      return state;\n    }\n    // Excluded overlapping messages\n    if (state.allMessages.some(function (msg) {\n      return msg.messageId === message.messageId;\n    })) {\n      return state;\n    }\n    // Filter by userFilledQuery\n    if (state.messageListParams && !filterMessageListParams(state.messageListParams, message)) {\n      return state;\n    }\n    if (message.isAdminMessage && message.isAdminMessage()) {\n      return __assign(__assign({}, state), {\n        allMessages: passUnsuccessfullMessages(state.allMessages, message)\n      });\n    }\n    // Update members when sender profileUrl, nickname, friendName has been changed\n    var senderMember = members === null || members === void 0 ? void 0 : members.find(function (m) {\n      return (m === null || m === void 0 ? void 0 : m.userId) === (sender === null || sender === void 0 ? void 0 : sender.userId);\n    });\n    if ((senderMember === null || senderMember === void 0 ? void 0 : senderMember.profileUrl) !== (sender === null || sender === void 0 ? void 0 : sender.profileUrl) || (senderMember === null || senderMember === void 0 ? void 0 : senderMember.friendName) !== (sender === null || sender === void 0 ? void 0 : sender.friendName) || (senderMember === null || senderMember === void 0 ? void 0 : senderMember.nickname) !== (sender === null || sender === void 0 ? void 0 : sender.nickname)) {\n      // @ts-ignore\n      channel.members = members.map(function (member) {\n        if (member.userId === sender.userId) {\n          return sender;\n        }\n        return member;\n      });\n    }\n    return __assign(__assign({}, state), {\n      currentGroupChannel: channel,\n      unreadSince: (_a = state.unreadSince) !== null && _a !== void 0 ? _a : format(new Date(), 'p MMM dd'),\n      unreadSinceDate: (_b = state.unreadSinceDate) !== null && _b !== void 0 ? _b : new Date(),\n      allMessages: passUnsuccessfullMessages(state.allMessages, message)\n    });\n  }).with({\n    type: ON_MESSAGE_UPDATED\n  }, function (action) {\n    var _a;\n    var _b = action.payload,\n      channel = _b.channel,\n      message = _b.message;\n    var currentGroupChannelUrl = ((_a = state === null || state === void 0 ? void 0 : state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url) || '';\n    if (!compareIds(channel === null || channel === void 0 ? void 0 : channel.url, currentGroupChannelUrl)) {\n      return state; // Ignore event when it is not for the current channel\n    }\n    if (state.messageListParams && !filterMessageListParams(state.messageListParams, message)) {\n      // Delete the message if it doesn't match to the params anymore\n      return __assign(__assign({}, state), {\n        allMessages: state.allMessages.filter(function (m) {\n          return !compareIds(m.messageId, message === null || message === void 0 ? void 0 : message.messageId);\n        })\n      });\n    }\n    return __assign(__assign({}, state), {\n      allMessages: state.allMessages.map(function (m) {\n        if (compareIds(m.messageId, message.messageId)) {\n          return message;\n        }\n        if (compareIds(m.parentMessageId, message.messageId)) {\n          m.parentMessage = message; // eslint-disable-line no-param-reassign\n        }\n        return m;\n      })\n    });\n  }).with({\n    type: ON_MESSAGE_THREAD_INFO_UPDATED\n  }, function (action) {\n    var _a;\n    var _b = action.payload,\n      channel = _b.channel,\n      event = _b.event;\n    var channelUrl = event.channelUrl,\n      threadInfo = event.threadInfo,\n      targetMessageId = event.targetMessageId;\n    var currentGroupChannelUrl = ((_a = state === null || state === void 0 ? void 0 : state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url) || '';\n    if (!compareIds(channel === null || channel === void 0 ? void 0 : channel.url, currentGroupChannelUrl) || !compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n      return state; // Ignore event when it is not for the current channel\n    }\n    return __assign(__assign({}, state), {\n      allMessages: state.allMessages.map(function (m) {\n        if (compareIds(m.messageId, targetMessageId)) {\n          // eslint-disable-next-line no-param-reassign\n          m.threadInfo = threadInfo; // Upsert threadInfo to the target message\n        }\n        return m;\n      })\n    });\n  }).with({\n    type: RESEND_MESSAGE_START\n  }, function (action) {\n    return __assign(__assign({}, state), {\n      localMessages: state.localMessages.map(function (m) {\n        return compareIds(hasReqId(m) && m.reqId, action.payload.reqId) ? action.payload : m;\n      })\n    });\n  }).with({\n    type: MARK_AS_READ\n  }, function (action) {\n    var _a, _b, _c;\n    if (((_a = state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url) !== ((_c = (_b = action.payload) === null || _b === void 0 ? void 0 : _b.channel) === null || _c === void 0 ? void 0 : _c.url)) {\n      return state;\n    }\n    return __assign(__assign({}, state), {\n      unreadSince: null,\n      unreadSinceDate: null\n    });\n  }).with({\n    type: ON_MESSAGE_DELETED\n  }, function (action) {\n    return __assign(__assign({}, state), {\n      allMessages: state.allMessages.filter(function (m) {\n        return !compareIds(m.messageId, action.payload);\n      })\n    });\n  }).with({\n    type: ON_MESSAGE_DELETED_BY_REQ_ID\n  }, function (action) {\n    return __assign(__assign({}, state), {\n      localMessages: state.localMessages.filter(function (m) {\n        return !compareIds(hasReqId(m) && m.reqId, action.payload);\n      })\n    });\n  }).with({\n    type: SET_EMOJI_CONTAINER\n  }, function (action) {\n    return __assign(__assign({}, state), {\n      emojiContainer: action.payload\n    });\n  }).with({\n    type: ON_REACTION_UPDATED\n  }, function (action) {\n    return __assign(__assign({}, state), {\n      allMessages: state.allMessages.map(function (m) {\n        if (compareIds(m.messageId, action.payload.messageId)) {\n          if (m.applyReactionEvent && typeof m.applyReactionEvent === 'function') {\n            m.applyReactionEvent(action.payload);\n          }\n          return m;\n        }\n        return m;\n      })\n    });\n  }).with({\n    type: MESSAGE_LIST_PARAMS_CHANGED\n  }, function (action) {\n    return __assign(__assign({}, state), {\n      messageListParams: action.payload\n    });\n  }).with({\n    type: ON_FILE_INFO_UPLOADED\n  }, function (action) {\n    var _a, _b;\n    var _c = action.payload,\n      channelUrl = _c.channelUrl,\n      requestId = _c.requestId,\n      index = _c.index,\n      uploadableFileInfo = _c.uploadableFileInfo,\n      error = _c.error;\n    if (!compareIds(channelUrl, (_a = state === null || state === void 0 ? void 0 : state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url)) {\n      return state;\n    }\n    /**\n     * We don't have to do anything here because\n     * onFailed() will be called so handle error there instead.\n     */\n    if (error) return state;\n    var localMessages = state.localMessages;\n    var messageToUpdate = localMessages.find(function (message) {\n      return compareIds(hasReqId(message) && message.reqId, requestId);\n    });\n    var fileInfoList = (_b = messageToUpdate.messageParams) === null || _b === void 0 ? void 0 : _b.fileInfoList;\n    if (Array.isArray(fileInfoList)) {\n      fileInfoList[index] = uploadableFileInfo;\n    }\n    return __assign(__assign({}, state), {\n      localMessages: localMessages\n    });\n  }).with({\n    type: ON_TYPING_STATUS_UPDATED\n  }, function (action) {\n    var _a;\n    var _b = action.payload,\n      channel = _b.channel,\n      typingMembers = _b.typingMembers;\n    if (!compareIds(channel.url, (_a = state === null || state === void 0 ? void 0 : state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url)) {\n      return state;\n    }\n    return __assign(__assign({}, state), {\n      typingMembers: typingMembers\n    });\n  }).otherwise(function () {\n    return state;\n  });\n}\nvar DELIVERY_RECEIPT = 'delivery_receipt';\nfunction useHandleChannelEvents(_a, _b) {\n  var _c, _d, _e;\n  var sdkInit = _a.sdkInit,\n    currentGroupChannel = _a.currentGroupChannel,\n    disableMarkAsRead = _a.disableMarkAsRead;\n  var sdk = _b.sdk,\n    logger = _b.logger,\n    scrollRef = _b.scrollRef,\n    setQuoteMessage = _b.setQuoteMessage,\n    messagesDispatcher = _b.messagesDispatcher;\n  var store = useSendbirdStateContext();\n  var _f = store.config,\n    markAsReadScheduler = _f.markAsReadScheduler,\n    markAsDeliveredScheduler = _f.markAsDeliveredScheduler,\n    disableMarkAsDelivered = _f.disableMarkAsDelivered;\n  var canSetMarkAsDelivered = (_e = (_d = (_c = store.stores.sdkStore.sdk) === null || _c === void 0 ? void 0 : _c.appInfo) === null || _d === void 0 ? void 0 : _d.premiumFeatureList) === null || _e === void 0 ? void 0 : _e.find(function (feature) {\n    return feature === DELIVERY_RECEIPT;\n  });\n  useEffect(function () {\n    var _a;\n    var channelUrl = currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url;\n    var channelHandlerId = uuidv4();\n    if (channelUrl && sdkInit) {\n      var channelHandler = {\n        onMessageReceived: function (channel, message) {\n          var _a, _b;\n          if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            var scrollToEnd = false;\n            try {\n              var current = scrollRef.current;\n              if (current) {\n                scrollToEnd = current.offsetHeight + current.scrollTop >= current.scrollHeight - 10;\n              }\n              // 10 is a buffer\n            } catch (error) {\n              //\n            }\n            logger.info('Channel | useHandleChannelEvents: onMessageReceived', message);\n            messagesDispatcher({\n              type: ON_MESSAGE_RECEIVED,\n              payload: {\n                channel: channel,\n                message: message\n              }\n            });\n            if (scrollToEnd && ((_a = document.getElementById('sendbird-dropdown-portal')) === null || _a === void 0 ? void 0 : _a.childElementCount) === 0 && ((_b = document.getElementById('sendbird-emoji-list-portal')) === null || _b === void 0 ? void 0 : _b.childElementCount) === 0) {\n              // and !openContextMenu\n              try {\n                setTimeout(function () {\n                  return scrollIntoLast(0, scrollRef);\n                });\n                if (!disableMarkAsRead) {\n                  markAsReadScheduler.push(currentGroupChannel);\n                }\n                if (canSetMarkAsDelivered && !disableMarkAsDelivered) {\n                  markAsDeliveredScheduler.push(currentGroupChannel);\n                }\n              } catch (error) {\n                logger.warning('Channel | onMessageReceived | scroll to end failed');\n              }\n            }\n          }\n        },\n        onUnreadMemberStatusUpdated: function (channel) {\n          logger.info('Channel | useHandleChannelEvents: onUnreadMemberStatusUpdated', channel);\n          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: channel\n            });\n          }\n        },\n        // before(onDeliveryReceiptUpdated)\n        onUndeliveredMemberStatusUpdated: function (channel) {\n          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onDeliveryReceiptUpdated', channel);\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: channel\n            });\n          }\n        },\n        onMessageUpdated: function (channel, message) {\n          if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onMessageUpdated', message);\n            messagesDispatcher({\n              type: ON_MESSAGE_UPDATED,\n              payload: {\n                channel: channel,\n                message: message\n              }\n            });\n          }\n        },\n        onThreadInfoUpdated: function (channel, threadInfoUpdateEvent) {\n          if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onThreadInfoUpdated', {\n              channel: channel,\n              threadInfoUpdateEvent: threadInfoUpdateEvent\n            });\n            messagesDispatcher({\n              type: ON_MESSAGE_THREAD_INFO_UPDATED,\n              payload: {\n                channel: channel,\n                event: threadInfoUpdateEvent\n              }\n            });\n          }\n        },\n        onMessageDeleted: function (channel, messageId) {\n          logger.info('Channel | useHandleChannelEvents: onMessageDeleted', {\n            channel: channel,\n            messageId: messageId\n          });\n          setQuoteMessage(null);\n          messagesDispatcher({\n            type: ON_MESSAGE_DELETED,\n            payload: messageId\n          });\n        },\n        onReactionUpdated: function (channel, reactionEvent) {\n          logger.info('Channel | useHandleChannelEvents: onReactionUpdated', {\n            channel: channel,\n            reactionEvent: reactionEvent\n          });\n          messagesDispatcher({\n            type: ON_REACTION_UPDATED,\n            payload: reactionEvent\n          });\n        },\n        onChannelChanged: function (channel) {\n          if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onChannelChanged', channel);\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: channel\n            });\n          }\n        },\n        onChannelFrozen: function (channel) {\n          if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onChannelFrozen', channel);\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: channel\n            });\n          }\n        },\n        onChannelUnfrozen: function (channel) {\n          if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onChannelUnFrozen', channel);\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: channel\n            });\n          }\n        },\n        onUserMuted: function (channel, user) {\n          if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onUserMuted', {\n              channel: channel,\n              user: user\n            });\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: channel\n            });\n          }\n        },\n        onUserUnmuted: function (channel, user) {\n          if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onUserUnmuted', {\n              channel: channel,\n              user: user\n            });\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: channel\n            });\n          }\n        },\n        onUserBanned: function (channel, user) {\n          var _a;\n          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl) && channel.isGroupChannel()) {\n            logger.info('Channel | useHandleChannelEvents: onUserBanned', {\n              channel: channel,\n              user: user\n            });\n            var isByMe = (user === null || user === void 0 ? void 0 : user.userId) === ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: isByMe ? null : channel\n            });\n          }\n        },\n        onOperatorUpdated: function (channel, users) {\n          if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onOperatorUpdated', {\n              channel: channel,\n              users: users\n            });\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: channel\n            });\n          }\n        },\n        onUserLeft: function (channel, user) {\n          var _a;\n          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | useHandleChannelEvents: onUserLeft', {\n              channel: channel,\n              user: user\n            });\n            var isByMe = (user === null || user === void 0 ? void 0 : user.userId) === ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n            messagesDispatcher({\n              type: SET_CURRENT_CHANNEL,\n              payload: isByMe ? null : channel\n            });\n          }\n        },\n        onTypingStatusUpdated: function (channel) {\n          if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            logger.info('Channel | onTypingStatusUpdated', {\n              channel: channel\n            });\n            var typingMembers = channel.getTypingUsers();\n            messagesDispatcher({\n              type: ON_TYPING_STATUS_UPDATED,\n              payload: {\n                channel: channel,\n                typingMembers: typingMembers\n              }\n            });\n          }\n        }\n      };\n      logger.info('Channel | useHandleChannelEvents: Setup event handler', {\n        channelHandlerId: channelHandlerId,\n        channelHandler: channelHandler\n      });\n      // Add this group channel handler to the Sendbird chat instance\n      (_a = sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.addGroupChannelHandler(channelHandlerId, new GroupChannelHandler(channelHandler));\n    }\n    return function () {\n      var _a;\n      if ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.removeGroupChannelHandler) {\n        logger.info('Channel | useHandleChannelEvents: Removing message reciver handler', channelHandlerId);\n        sdk.groupChannel.removeGroupChannelHandler(channelHandlerId);\n      } else if (sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) {\n        logger.error('Channel | useHandleChannelEvents: Not found the removeGroupChannelHandler');\n      }\n    };\n  }, [currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url, sdkInit]);\n}\nfunction useGetChannel(_a, _b) {\n  var channelUrl = _a.channelUrl,\n    sdkInit = _a.sdkInit,\n    disableMarkAsRead = _a.disableMarkAsRead;\n  var messagesDispatcher = _b.messagesDispatcher,\n    sdk = _b.sdk,\n    logger = _b.logger,\n    markAsReadScheduler = _b.markAsReadScheduler;\n  useEffect(function () {\n    if (channelUrl && sdkInit && sdk && sdk.groupChannel) {\n      logger.info('Channel | useSetChannel fetching channel', channelUrl);\n      sdk.groupChannel.getChannel(channelUrl).then(function (groupChannel) {\n        logger.info('Channel | useSetChannel fetched channel', groupChannel);\n        messagesDispatcher({\n          type: SET_CURRENT_CHANNEL,\n          payload: groupChannel\n        });\n        logger.info('Channel: Mark as read', groupChannel);\n        if (!disableMarkAsRead) {\n          markAsReadScheduler.push(groupChannel);\n        }\n      }).catch(function (e) {\n        logger.warning('Channel | useSetChannel fetch channel failed', {\n          channelUrl: channelUrl,\n          e: e\n        });\n        messagesDispatcher({\n          type: SET_CHANNEL_INVALID\n        });\n      });\n      sdk.getAllEmoji().then(function (emojiContainer_) {\n        logger.info('Channel: Getting emojis success', emojiContainer_);\n        messagesDispatcher({\n          type: SET_EMOJI_CONTAINER,\n          payload: emojiContainer_\n        });\n      }).catch(function (err) {\n        logger.error('Channel: Getting emojis failed', err);\n      });\n    }\n  }, [channelUrl, sdkInit]);\n}\nfunction useHandleReconnect(_a, _b) {\n  var isOnline = _a.isOnline,\n    replyType = _a.replyType,\n    disableMarkAsRead = _a.disableMarkAsRead,\n    reconnectOnIdle = _a.reconnectOnIdle;\n  var logger = _b.logger,\n    sdk = _b.sdk,\n    scrollRef = _b.scrollRef,\n    currentGroupChannel = _b.currentGroupChannel,\n    messagesDispatcher = _b.messagesDispatcher,\n    markAsReadScheduler = _b.markAsReadScheduler,\n    userFilledMessageListQuery = _b.userFilledMessageListQuery;\n  var shouldReconnect = useReconnectOnIdle(isOnline, currentGroupChannel, reconnectOnIdle).shouldReconnect;\n  useEffect(function () {\n    return function () {\n      var _a, _b, _c;\n      // state changed from offline to online AND tab is visible\n      if (shouldReconnect) {\n        logger.info('Refreshing conversation state');\n        var isReactionEnabled = ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) === null || _a === void 0 ? void 0 : _a.useReaction) || false;\n        var messageListParams_1 = {\n          prevResultSize: PREV_RESULT_SIZE,\n          isInclusive: true,\n          includeReactions: isReactionEnabled,\n          includeMetaArray: true,\n          nextResultSize: NEXT_RESULT_SIZE\n        };\n        if (replyType && replyType === 'QUOTE_REPLY') {\n          messageListParams_1.includeThreadInfo = true;\n          messageListParams_1.includeParentMessageInfo = true;\n          messageListParams_1.replyType = ReplyType.ONLY_REPLY_TO_CHANNEL;\n        }\n        if (userFilledMessageListQuery) {\n          Object.keys(userFilledMessageListQuery).forEach(function (key) {\n            // @ts-ignore\n            messageListParams_1[key] = userFilledMessageListQuery[key];\n          });\n        }\n        logger.info('Channel: Fetching messages', {\n          currentGroupChannel: currentGroupChannel,\n          userFilledMessageListQuery: userFilledMessageListQuery\n        });\n        messagesDispatcher({\n          type: FETCH_INITIAL_MESSAGES_START,\n          payload: null\n        });\n        (_b = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _b === void 0 ? void 0 : _b.getChannel((_c = currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) !== null && _c !== void 0 ? _c : '').then(function (groupChannel) {\n          var lastMessageTime = new Date().getTime();\n          groupChannel.getMessagesByTimestamp(lastMessageTime, messageListParams_1).then(function (messages) {\n            messagesDispatcher({\n              type: FETCH_INITIAL_MESSAGES_SUCCESS,\n              payload: {\n                currentGroupChannel: groupChannel,\n                messages: messages\n              }\n            });\n            setTimeout(function () {\n              return scrollIntoLast(0, scrollRef);\n            }, SCROLL_BOTTOM_DELAY_FOR_FETCH);\n          }).catch(function (error) {\n            logger.error('Channel: Fetching messages failed', error);\n            messagesDispatcher({\n              type: FETCH_INITIAL_MESSAGES_FAILURE,\n              payload: {\n                currentGroupChannel: groupChannel\n              }\n            });\n          });\n          if (!disableMarkAsRead) {\n            markAsReadScheduler.push(groupChannel);\n          }\n        });\n      }\n    };\n  }, [shouldReconnect, replyType]);\n}\nfunction useScrollCallback(_a, _b) {\n  var currentGroupChannel = _a.currentGroupChannel,\n    oldestMessageTimeStamp = _a.oldestMessageTimeStamp,\n    userFilledMessageListQuery = _a.userFilledMessageListQuery,\n    replyType = _a.replyType;\n  var hasMorePrev = _b.hasMorePrev,\n    logger = _b.logger,\n    messagesDispatcher = _b.messagesDispatcher,\n    sdk = _b.sdk;\n  return useCallback(function (callback) {\n    var _a, _b;\n    if (!hasMorePrev) {\n      return;\n    }\n    var messageListParams = {\n      prevResultSize: PREV_RESULT_SIZE,\n      isInclusive: true,\n      includeMetaArray: true,\n      includeReactions: (_b = (_a = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) === null || _a === void 0 ? void 0 : _a.useReaction) !== null && _b !== void 0 ? _b : false\n    };\n    if (replyType === 'QUOTE_REPLY' || replyType === 'THREAD') {\n      messageListParams.includeThreadInfo = true;\n      messageListParams.includeParentMessageInfo = true;\n      messageListParams.replyType = ReplyType.ONLY_REPLY_TO_CHANNEL;\n    }\n    if (userFilledMessageListQuery) {\n      Object.keys(userFilledMessageListQuery).forEach(function (key) {\n        // @ts-ignore\n        messageListParams[key] = userFilledMessageListQuery[key];\n      });\n    }\n    logger.info('Channel: Fetching messages', {\n      currentGroupChannel: currentGroupChannel,\n      userFilledMessageListQuery: userFilledMessageListQuery\n    });\n    currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.getMessagesByTimestamp(oldestMessageTimeStamp || new Date().getTime(), messageListParams).then(function (messages) {\n      messagesDispatcher({\n        type: FETCH_PREV_MESSAGES_SUCCESS,\n        payload: {\n          currentGroupChannel: currentGroupChannel,\n          messages: messages\n        }\n      });\n      if (callback) setTimeout(function () {\n        return callback();\n      });\n    }).catch(function () {\n      messagesDispatcher({\n        type: FETCH_PREV_MESSAGES_FAILURE,\n        payload: {\n          currentGroupChannel: currentGroupChannel\n        }\n      });\n    });\n  }, [currentGroupChannel, oldestMessageTimeStamp, replyType]);\n}\nfunction useScrollDownCallback(_a, _b) {\n  var currentGroupChannel = _a.currentGroupChannel,\n    latestMessageTimeStamp = _a.latestMessageTimeStamp,\n    userFilledMessageListQuery = _a.userFilledMessageListQuery,\n    hasMoreNext = _a.hasMoreNext,\n    replyType = _a.replyType;\n  var logger = _b.logger,\n    messagesDispatcher = _b.messagesDispatcher,\n    sdk = _b.sdk;\n  return useCallback(function (cb) {\n    var _a, _b;\n    if (!hasMoreNext) {\n      return;\n    }\n    var isReactionEnabled = (_b = (_a = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) === null || _a === void 0 ? void 0 : _a.useReaction) !== null && _b !== void 0 ? _b : false;\n    var messageListParams = {\n      nextResultSize: NEXT_RESULT_SIZE,\n      isInclusive: true,\n      includeReactions: isReactionEnabled,\n      includeMetaArray: true\n    };\n    if (replyType && (replyType === 'QUOTE_REPLY' || replyType === 'THREAD')) {\n      messageListParams.includeThreadInfo = true;\n      messageListParams.includeParentMessageInfo = true;\n      messageListParams.replyType = ReplyType.ONLY_REPLY_TO_CHANNEL;\n    }\n    if (userFilledMessageListQuery) {\n      Object.keys(userFilledMessageListQuery).forEach(function (key) {\n        // @ts-ignore\n        messageListParams[key] = userFilledMessageListQuery[key];\n      });\n    }\n    logger.info('Channel: Fetching later messages', {\n      currentGroupChannel: currentGroupChannel,\n      userFilledMessageListQuery: userFilledMessageListQuery\n    });\n    currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.getMessagesByTimestamp(latestMessageTimeStamp || new Date().getTime(), messageListParams).then(function (messages) {\n      messagesDispatcher({\n        type: FETCH_NEXT_MESSAGES_SUCCESS,\n        payload: {\n          currentGroupChannel: currentGroupChannel,\n          messages: messages\n        }\n      });\n      setTimeout(function () {\n        return cb([messages, null]);\n      });\n    }).catch(function (error) {\n      logger.error('Channel: Fetching later messages failed', error);\n      messagesDispatcher({\n        type: FETCH_NEXT_MESSAGES_FAILURE,\n        payload: {\n          currentGroupChannel: currentGroupChannel\n        }\n      });\n      setTimeout(function () {\n        return cb([null, error]);\n      });\n    });\n  }, [currentGroupChannel, latestMessageTimeStamp, hasMoreNext, replyType]);\n}\nfunction useDeleteMessageCallback(_a, _b) {\n  var currentGroupChannel = _a.currentGroupChannel,\n    messagesDispatcher = _a.messagesDispatcher;\n  var logger = _b.logger;\n  return useCallback(function (message) {\n    logger.info('Channel | useDeleteMessageCallback: Deleting message', message);\n    var sendingStatus = isSendableMessage(message) ? message.sendingStatus : undefined;\n    return new Promise(function (resolve, reject) {\n      logger.info('Channel | useDeleteMessageCallback: Deleting message requestState:', sendingStatus);\n      // Message is only on local\n      if ((sendingStatus === SendingStatus.FAILED || sendingStatus === SendingStatus.PENDING) && 'reqId' in message) {\n        logger.info('Channel | useDeleteMessageCallback: Deleted message from local:', message);\n        messagesDispatcher({\n          type: ON_MESSAGE_DELETED_BY_REQ_ID,\n          payload: message.reqId\n        });\n        resolve();\n      } else {\n        logger.info('Channel | useDeleteMessageCallback: Deleting message from remote:', sendingStatus);\n        currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.deleteMessage(message).then(function () {\n          logger.info('Channel | useDeleteMessageCallback: Deleting message success!', message);\n          messagesDispatcher({\n            type: ON_MESSAGE_DELETED,\n            payload: message.messageId\n          });\n          resolve();\n        }).catch(function (err) {\n          logger.warning('Channel | useDeleteMessageCallback: Deleting message failed!', err);\n          reject(err);\n        });\n      }\n    });\n  }, [currentGroupChannel, messagesDispatcher]);\n}\nfunction useUpdateMessageCallback(_a, _b) {\n  var currentGroupChannel = _a.currentGroupChannel,\n    messagesDispatcher = _a.messagesDispatcher,\n    onBeforeUpdateUserMessage = _a.onBeforeUpdateUserMessage,\n    isMentionEnabled = _a.isMentionEnabled;\n  var logger = _b.logger,\n    pubSub = _b.pubSub;\n  return useCallback(function (props, callback) {\n    var messageId = props.messageId,\n      message = props.message,\n      mentionedUsers = props.mentionedUsers,\n      mentionTemplate = props.mentionTemplate;\n    var createParamsDefault = function (message) {\n      var params = {\n        message: message\n      };\n      if (isMentionEnabled && mentionedUsers && mentionedUsers.length > 0) {\n        params.mentionedUsers = mentionedUsers;\n      }\n      if (isMentionEnabled && mentionTemplate) {\n        params.mentionedMessageTemplate = mentionTemplate;\n      } else {\n        params.mentionedMessageTemplate = message;\n      }\n      return params;\n    };\n    var shouldCreateCustomParams = onBeforeUpdateUserMessage && typeof onBeforeUpdateUserMessage === 'function';\n    if (shouldCreateCustomParams) {\n      logger.info('Channel: creating params using onBeforeUpdateUserMessage', onBeforeUpdateUserMessage);\n    }\n    var params = shouldCreateCustomParams ? onBeforeUpdateUserMessage(message) : createParamsDefault(message);\n    logger.info('Channel: Updating message!', params);\n    currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.updateUserMessage(messageId, params).then(function (msg) {\n      if (callback) {\n        callback(null, msg);\n      }\n      logger.info('Channel: Updating message success!', msg);\n      messagesDispatcher({\n        type: ON_MESSAGE_UPDATED,\n        payload: {\n          channel: currentGroupChannel,\n          message: msg\n        }\n      });\n      pubSub.publish(pubSubTopics.UPDATE_USER_MESSAGE, {\n        message: msg,\n        channel: currentGroupChannel,\n        publishingModules: [PublishingModuleType.CHANNEL]\n      });\n    }).catch(function (err) {\n      if (callback) {\n        callback(err, null);\n      }\n    });\n  }, [currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url, messagesDispatcher, onBeforeUpdateUserMessage]);\n}\nfunction useResendMessageCallback(_a, _b) {\n  var currentGroupChannel = _a.currentGroupChannel,\n    messagesDispatcher = _a.messagesDispatcher;\n  var logger = _b.logger,\n    pubSub = _b.pubSub;\n  return useCallback(function (failedMessage) {\n    logger.info('Channel: Resending message has started', failedMessage);\n    if (failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.isResendable) {\n      // userMessage\n      if (failedMessage.isUserMessage()) {\n        currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.resendMessage(failedMessage).onPending(function (message) {\n          logger.info('Channel: Resending message start!', message);\n          messagesDispatcher({\n            type: RESEND_MESSAGE_START,\n            payload: message\n          });\n        }).onSucceeded(function (message) {\n          logger.info('Channel: Resending message success!', message);\n          messagesDispatcher({\n            type: SEND_MESSAGE_SUCCESS,\n            payload: message\n          });\n        }).onFailed(function (e, message) {\n          logger.warning('Channel: Resending message failed!', e);\n          messagesDispatcher({\n            type: SEND_MESSAGE_FAILURE,\n            payload: message\n          });\n        });\n      } else if (failedMessage.isFileMessage()) {\n        currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.resendMessage(failedMessage).onPending(function (message) {\n          logger.info('Channel: Resending file message start!', message);\n          messagesDispatcher({\n            type: RESEND_MESSAGE_START,\n            payload: message\n          });\n        }).onSucceeded(function (message) {\n          logger.info('Channel: Resending file message success!', message);\n          messagesDispatcher({\n            type: SEND_MESSAGE_SUCCESS,\n            payload: message\n          });\n        }).onFailed(function (e, message) {\n          logger.warning('Channel: Resending file message failed!', e);\n          messagesDispatcher({\n            type: SEND_MESSAGE_FAILURE,\n            payload: message\n          });\n        });\n      } else if (failedMessage.isMultipleFilesMessage()) {\n        currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.resendMessage(failedMessage).onPending(function (message) {\n          logger.info('Channel: Resending multiple files message start!', message);\n          messagesDispatcher({\n            type: RESEND_MESSAGE_START,\n            payload: message\n          });\n        }).onFileUploaded(function (requestId, index, uploadableFileInfo, error) {\n          var _a;\n          logger.info('Channel: Resending multiple files message file uploaded!', {\n            requestId: requestId,\n            index: index,\n            error: error,\n            uploadableFileInfo: uploadableFileInfo\n          });\n          pubSub.publish(pubSubTopics.ON_FILE_INFO_UPLOADED, {\n            response: {\n              channelUrl: (_a = currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) !== null && _a !== void 0 ? _a : '',\n              requestId: requestId,\n              index: index,\n              uploadableFileInfo: uploadableFileInfo,\n              error: error\n            },\n            publishingModules: [PublishingModuleType.CHANNEL]\n          });\n        }).onSucceeded(function (message) {\n          logger.info('Channel: Resending multiple files message success!', message);\n          messagesDispatcher({\n            type: SEND_MESSAGE_SUCCESS,\n            payload: message\n          });\n        }).onFailed(function (e, message) {\n          logger.warning('Channel: Resending multiple files message failed!', e);\n          messagesDispatcher({\n            type: SEND_MESSAGE_FAILURE,\n            payload: message\n          });\n        });\n      }\n    } else {\n      logger.error('Message is not resendable', failedMessage);\n    }\n  }, [currentGroupChannel, messagesDispatcher]);\n}\nfunction useSendMessageCallback(_a, _b) {\n  var isMentionEnabled = _a.isMentionEnabled,\n    currentGroupChannel = _a.currentGroupChannel,\n    onBeforeSendUserMessage = _a.onBeforeSendUserMessage;\n  var logger = _b.logger,\n    pubSub = _b.pubSub,\n    scrollRef = _b.scrollRef,\n    messagesDispatcher = _b.messagesDispatcher;\n  var messageInputRef = useRef(null);\n  var sendMessage = useCallback(function (_a) {\n    var quoteMessage = _a.quoteMessage,\n      message = _a.message,\n      mentionTemplate = _a.mentionTemplate,\n      // mentionedUserIds,\n      mentionedUsers = _a.mentionedUsers;\n    var createParamsDefault = function () {\n      var params = {\n        message: message\n      };\n      // if (isMentionEnabled && mentionedUserIds?.length > 0) {\n      if (isMentionEnabled && mentionedUsers && mentionedUsers.length > 0) {\n        // params.mentionedUserIds = mentionedUserIds;\n        params.mentionedUsers = mentionedUsers;\n      }\n      // if (isMentionEnabled && mentionTemplate && mentionedUserIds?.length > 0) {\n      if (isMentionEnabled && mentionTemplate && mentionedUsers && mentionedUsers.length > 0) {\n        params.mentionedMessageTemplate = mentionTemplate;\n      }\n      if (quoteMessage) {\n        params.isReplyToChannel = true;\n        params.parentMessageId = quoteMessage.messageId;\n      }\n      return params;\n    };\n    var shouldCreateCustomParams = onBeforeSendUserMessage && typeof onBeforeSendUserMessage === 'function';\n    if (shouldCreateCustomParams) {\n      logger.info('Channel: creating params using onBeforeSendUserMessage', onBeforeSendUserMessage);\n    }\n    var params = shouldCreateCustomParams ? onBeforeSendUserMessage(message, quoteMessage) : createParamsDefault();\n    logger.info('Channel: Sending message has started', params);\n    currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.sendUserMessage(params).onPending(function (pendingMsg) {\n      pubSub.publish(pubSubTopics.SEND_MESSAGE_START, {\n        /* pubSub is used instead of messagesDispatcher\n          to avoid redundantly calling `messageActionTypes.SEND_MESSAGE_START` */\n        message: pendingMsg,\n        channel: currentGroupChannel,\n        publishingModules: [PublishingModuleType.CHANNEL]\n      });\n      setTimeout(function () {\n        return scrollIntoLast(0, scrollRef);\n      }, SCROLL_BOTTOM_DELAY_FOR_SEND);\n    }).onFailed(function (err, msg) {\n      logger.warning('Channel: Sending message failed!', {\n        message: msg,\n        error: err\n      });\n      messagesDispatcher({\n        type: SEND_MESSAGE_FAILURE,\n        payload: msg\n      });\n    }).onSucceeded(function (msg) {\n      logger.info('Channel: Sending message success!', msg);\n      messagesDispatcher({\n        type: SEND_MESSAGE_SUCCESS,\n        payload: msg\n      });\n    });\n  }, [currentGroupChannel, onBeforeSendUserMessage]);\n  return [messageInputRef, sendMessage];\n}\nfunction useSendFileMessageCallback(_a, _b) {\n  var currentGroupChannel = _a.currentGroupChannel,\n    onBeforeSendFileMessage = _a.onBeforeSendFileMessage,\n    imageCompression = _a.imageCompression;\n  var logger = _b.logger,\n    pubSub = _b.pubSub,\n    scrollRef = _b.scrollRef,\n    messagesDispatcher = _b.messagesDispatcher;\n  var sendMessage = useCallback(function (compressedFile, quoteMessage) {\n    return new Promise(function (resolve, reject) {\n      // Create FileMessageParams\n      var params = onBeforeSendFileMessage === null || onBeforeSendFileMessage === void 0 ? void 0 : onBeforeSendFileMessage(compressedFile, quoteMessage);\n      if (!params) {\n        params = {\n          file: compressedFile\n        };\n        if (quoteMessage) {\n          params.isReplyToChannel = true;\n          params.parentMessageId = quoteMessage.messageId;\n        }\n      }\n      // Send FileMessage\n      logger.info('Channel: Uploading file message start!', params);\n      currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.sendFileMessage(params).onPending(function (pendingMessage) {\n        pubSub.publish(pubSubTopics.SEND_MESSAGE_START, {\n          /* pubSub is used instead of messagesDispatcher\n            to avoid redundantly calling `messageActionTypes.SEND_MESSAGE_START` */\n          // TODO: remove data pollution\n          message: __assign(__assign({}, pendingMessage), {\n            url: URL.createObjectURL(compressedFile),\n            // pending thumbnail message seems to be failed\n            requestState: 'pending',\n            isUserMessage: pendingMessage.isUserMessage,\n            isFileMessage: pendingMessage.isFileMessage,\n            isAdminMessage: pendingMessage.isAdminMessage,\n            isMultipleFilesMessage: pendingMessage.isMultipleFilesMessage\n          }),\n          channel: currentGroupChannel,\n          publishingModules: [PublishingModuleType.CHANNEL]\n        });\n        setTimeout(function () {\n          return scrollIntoLast(0, scrollRef);\n        }, SCROLL_BOTTOM_DELAY_FOR_SEND);\n      }).onFailed(function (err, failedMessage) {\n        logger.error('Channel: Sending file message failed!', {\n          failedMessage: failedMessage,\n          err: err\n        });\n        // TODO: v4 - remove logic that modifies the original object.\n        //  It makes the code difficult to track, likely causing unpredictable side effects.\n        // @ts-ignore eslint-disable-next-line no-param-reassign\n        failedMessage.localUrl = URL.createObjectURL(compressedFile);\n        // @ts-ignore eslint-disable-next-line no-param-reassign\n        failedMessage.file = compressedFile;\n        messagesDispatcher({\n          type: SEND_MESSAGE_FAILURE,\n          payload: failedMessage\n        });\n        reject(err);\n      }).onSucceeded(function (succeededMessage) {\n        logger.info('Channel: Sending file message success!', succeededMessage);\n        messagesDispatcher({\n          type: SEND_MESSAGE_SUCCESS,\n          payload: succeededMessage\n        });\n        resolve(succeededMessage);\n      });\n    });\n  }, [currentGroupChannel, onBeforeSendFileMessage, imageCompression]);\n  return [sendMessage];\n}\n\n// To prevent multiple clicks on the message in the channel while scrolling\nfunction deactivateClick(scrollRef) {\n  var element = scrollRef.current;\n  var parentNode = element === null || element === void 0 ? void 0 : element.parentNode;\n  if (element && parentNode) {\n    element.style.pointerEvents = 'none';\n    parentNode.style.cursor = 'wait';\n  }\n}\nfunction activateClick(scrollRef) {\n  var element = scrollRef.current;\n  var parentNode = element === null || element === void 0 ? void 0 : element.parentNode;\n  if (element && parentNode) {\n    element.style.pointerEvents = 'auto';\n    parentNode.style.cursor = 'auto';\n  }\n}\nfunction useScrollToMessage(_a, _b) {\n  var setInitialTimeStamp = _a.setInitialTimeStamp,\n    setAnimatedMessageId = _a.setAnimatedMessageId,\n    allMessages = _a.allMessages,\n    scrollRef = _a.scrollRef;\n  var logger = _b.logger;\n  return useCallback(function (createdAt, messageId) {\n    var isPresent = allMessages.find(function (m) {\n      return m.messageId === messageId;\n    });\n    setAnimatedMessageId(null);\n    setTimeout(function () {\n      try {\n        logger.info('Channel: scroll to message - disabling mouse events');\n        deactivateClick(scrollRef);\n        if (isPresent) {\n          logger.info('Channel: scroll to message - message is present');\n          setAnimatedMessageId(messageId);\n          scrollToRenderedMessage(scrollRef, createdAt);\n        } else {\n          logger.info('Channel: scroll to message - fetching older messages');\n          setInitialTimeStamp(null);\n          setInitialTimeStamp(createdAt);\n          setAnimatedMessageId(messageId);\n        }\n      } finally {\n        logger.info('Channel: scroll to message - enabled mouse events');\n        activateClick(scrollRef);\n      }\n    });\n  }, [setInitialTimeStamp, setAnimatedMessageId, allMessages]);\n}\nvar useSendVoiceMessageCallback = function (_a, _b) {\n  var currentGroupChannel = _a.currentGroupChannel,\n    onBeforeSendVoiceMessage = _a.onBeforeSendVoiceMessage;\n  var logger = _b.logger,\n    pubSub = _b.pubSub,\n    scrollRef = _b.scrollRef,\n    messagesDispatcher = _b.messagesDispatcher;\n  var sendMessage = useCallback(function (file, duration, quoteMessage) {\n    return new Promise(function (resolve, reject) {\n      if (!currentGroupChannel) {\n        return;\n      }\n      var messageParams = onBeforeSendVoiceMessage && typeof onBeforeSendVoiceMessage === 'function' ? onBeforeSendVoiceMessage(file, quoteMessage) : {\n        file: file,\n        fileName: VOICE_MESSAGE_FILE_NAME,\n        mimeType: VOICE_MESSAGE_MIME_TYPE,\n        metaArrays: [new MessageMetaArray({\n          key: META_ARRAY_VOICE_DURATION_KEY,\n          value: [\"\".concat(duration)]\n        }), new MessageMetaArray({\n          key: META_ARRAY_MESSAGE_TYPE_KEY,\n          value: [META_ARRAY_MESSAGE_TYPE_VALUE__VOICE]\n        })]\n      };\n      if (quoteMessage) {\n        messageParams.isReplyToChannel = true;\n        messageParams.parentMessageId = quoteMessage.messageId;\n      }\n      logger.info('Channel: Start sending voice message', messageParams);\n      currentGroupChannel.sendFileMessage(messageParams).onPending(function (pendingMessage) {\n        pubSub.publish(pubSubTopics.SEND_MESSAGE_START, {\n          /* pubSub is used instead of messagesDispatcher\n            to avoid redundantly calling `messageActionTypes.SEND_MESSAGE_START` */\n          message: pendingMessage,\n          channel: currentGroupChannel,\n          publishingModules: [PublishingModuleType.CHANNEL]\n        });\n        setTimeout(function () {\n          return scrollIntoLast(0, scrollRef);\n        }, SCROLL_BOTTOM_DELAY_FOR_SEND);\n      }).onFailed(function (err, failedMessage) {\n        logger.error('Channel: Sending voice message failed!', {\n          failedMessage: failedMessage,\n          err: err\n        });\n        messagesDispatcher({\n          type: SEND_MESSAGE_FAILURE,\n          payload: failedMessage\n        });\n        reject(err);\n      }).onSucceeded(function (succeededMessage) {\n        logger.info('Channel: Sending voice message success!', succeededMessage);\n        messagesDispatcher({\n          type: SEND_MESSAGE_SUCCESS,\n          payload: succeededMessage\n        });\n        resolve(succeededMessage);\n      });\n    });\n  }, [currentGroupChannel, onBeforeSendVoiceMessage]);\n  return [sendMessage];\n};\nvar useHandleChannelPubsubEvents = function (_a) {\n  var channelUrl = _a.channelUrl,\n    sdkInit = _a.sdkInit,\n    pubSub = _a.pubSub,\n    dispatcher = _a.dispatcher,\n    scrollRef = _a.scrollRef;\n  useEffect(function () {\n    var subscriber = new Map();\n    if (pubSub === null || pubSub === void 0 ? void 0 : pubSub.subscribe) {\n      subscriber.set(PUBSUB_TOPICS.SEND_USER_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.SEND_USER_MESSAGE, function (props) {\n        var channel = props.channel,\n          message = props.message;\n        if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n          dispatcher({\n            type: SEND_MESSAGE_SUCCESS,\n            payload: message\n          });\n          setTimeout(function () {\n            return scrollIntoLast(0, scrollRef);\n          }, SCROLL_BOTTOM_DELAY_FOR_SEND);\n        }\n      }));\n      subscriber.set(PUBSUB_TOPICS.SEND_MESSAGE_START, pubSub.subscribe(PUBSUB_TOPICS.SEND_MESSAGE_START, function (props) {\n        var channel = props.channel,\n          message = props.message,\n          publishingModules = props.publishingModules;\n        if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url) && shouldPubSubPublishToChannel(publishingModules)) {\n          dispatcher({\n            type: SEND_MESSAGE_START,\n            payload: message\n          });\n        }\n      }));\n      subscriber.set(PUBSUB_TOPICS.ON_FILE_INFO_UPLOADED, pubSub.subscribe(PUBSUB_TOPICS.ON_FILE_INFO_UPLOADED, function (props) {\n        var response = props.response,\n          publishingModules = props.publishingModules;\n        if (channelUrl === response.channelUrl && shouldPubSubPublishToChannel(publishingModules)) {\n          dispatcher({\n            type: ON_FILE_INFO_UPLOADED,\n            payload: response\n          });\n        }\n      }));\n      subscriber.set(PUBSUB_TOPICS.SEND_MESSAGE_FAILED, pubSub.subscribe(PUBSUB_TOPICS.SEND_MESSAGE_FAILED, function (props) {\n        var channel = props.channel,\n          message = props.message,\n          publishingModules = props.publishingModules;\n        if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url) && shouldPubSubPublishToChannel(publishingModules)) {\n          dispatcher({\n            type: SEND_MESSAGE_FAILURE,\n            payload: message\n          });\n        }\n      }));\n      subscriber.set(PUBSUB_TOPICS.SEND_FILE_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.SEND_FILE_MESSAGE, function (props) {\n        var channel = props.channel,\n          message = props.message;\n        if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n          dispatcher({\n            type: SEND_MESSAGE_SUCCESS,\n            payload: message\n          });\n          setTimeout(function () {\n            return scrollIntoLast(0, scrollRef);\n          }, SCROLL_BOTTOM_DELAY_FOR_SEND);\n        }\n      }));\n      subscriber.set(PUBSUB_TOPICS.UPDATE_USER_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.UPDATE_USER_MESSAGE, function (props) {\n        var channel = props.channel,\n          message = props.message,\n          fromSelector = props.fromSelector;\n        if (fromSelector && channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url) && channel.isGroupChannel()) {\n          dispatcher({\n            type: ON_MESSAGE_UPDATED,\n            payload: {\n              channel: channel,\n              message: message\n            }\n          });\n        }\n      }));\n      subscriber.set(PUBSUB_TOPICS.DELETE_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.DELETE_MESSAGE, function (props) {\n        var channel = props.channel,\n          messageId = props.messageId;\n        if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n          dispatcher({\n            type: ON_MESSAGE_DELETED,\n            payload: messageId\n          });\n        }\n      }));\n    }\n    return function () {\n      subscriber.forEach(function (s) {\n        try {\n          s.remove();\n        } catch (_a) {\n          //\n        }\n      });\n    };\n  }, [channelUrl, sdkInit]);\n};\nvar ChannelContext = React__default.createContext(null);\n/**\n * @deprecated This provider is deprecated and will be removed in the next major update.\n * Please use the `GroupChannelProvider` from '@sendbird/uikit-react/GroupChannel' instead.\n * For more information, please refer to the migration guide:\n * https://docs.sendbird.com/docs/chat/uikit/v3/react/introduction/group-channel-migration-guide\n */\nvar ChannelProvider = function (props) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  var channelUrl = props.channelUrl,\n    children = props.children,\n    isReactionEnabled = props.isReactionEnabled,\n    _h = props.isMessageGroupingEnabled,\n    isMessageGroupingEnabled = _h === void 0 ? true : _h,\n    isMultipleFilesMessageEnabled = props.isMultipleFilesMessageEnabled,\n    showSearchIcon = props.showSearchIcon,\n    animatedMessage = props.animatedMessage,\n    highlightedMessage = props.highlightedMessage,\n    startingPoint = props.startingPoint,\n    onBeforeSendUserMessage = props.onBeforeSendUserMessage,\n    onBeforeSendFileMessage = props.onBeforeSendFileMessage,\n    onBeforeUpdateUserMessage = props.onBeforeUpdateUserMessage,\n    onBeforeSendVoiceMessage = props.onBeforeSendVoiceMessage,\n    onBeforeSendMultipleFilesMessage = props.onBeforeSendMultipleFilesMessage,\n    onChatHeaderActionClick = props.onChatHeaderActionClick,\n    onSearchClick = props.onSearchClick,\n    onBackClick = props.onBackClick,\n    threadReplySelectType = props.threadReplySelectType,\n    queries = props.queries,\n    filterMessageList = props.filterMessageList,\n    _j = props.disableMarkAsRead,\n    disableMarkAsRead = _j === void 0 ? false : _j,\n    onReplyInThread = props.onReplyInThread,\n    onQuoteMessageClick = props.onQuoteMessageClick,\n    onMessageAnimated = props.onMessageAnimated,\n    onMessageHighlighted = props.onMessageHighlighted,\n    _k = props.scrollBehavior,\n    scrollBehavior = _k === void 0 ? 'auto' : _k,\n    _l = props.reconnectOnIdle,\n    reconnectOnIdle = _l === void 0 ? true : _l;\n  var globalStore = useSendbirdStateContext();\n  var config = globalStore.config;\n  var replyType = (_a = props.replyType) !== null && _a !== void 0 ? _a : getCaseResolvedReplyType(config.groupChannel.replyType).upperCase;\n  var pubSub = config.pubSub,\n    logger = config.logger,\n    userId = config.userId,\n    isOnline = config.isOnline,\n    imageCompression = config.imageCompression,\n    onUserProfileMessage = config.onUserProfileMessage,\n    markAsReadScheduler = config.markAsReadScheduler,\n    groupChannel = config.groupChannel;\n  var sdk = (_c = (_b = globalStore === null || globalStore === void 0 ? void 0 : globalStore.stores) === null || _b === void 0 ? void 0 : _b.sdkStore) === null || _c === void 0 ? void 0 : _c.sdk;\n  var sdkInit = (_e = (_d = globalStore === null || globalStore === void 0 ? void 0 : globalStore.stores) === null || _d === void 0 ? void 0 : _d.sdkStore) === null || _e === void 0 ? void 0 : _e.initialized;\n  var globalConfigs = globalStore === null || globalStore === void 0 ? void 0 : globalStore.config;\n  var _m = useState(startingPoint),\n    initialTimeStamp = _m[0],\n    setInitialTimeStamp = _m[1];\n  useEffect(function () {\n    setInitialTimeStamp(startingPoint);\n  }, [startingPoint, channelUrl]);\n  var _o = useState(null),\n    animatedMessageId = _o[0],\n    setAnimatedMessageId = _o[1];\n  var _p = useState(highlightedMessage),\n    highLightedMessageId = _p[0],\n    setHighLightedMessageId = _p[1];\n  useEffect(function () {\n    setHighLightedMessageId(highlightedMessage);\n  }, [highlightedMessage]);\n  var userFilledMessageListQuery = queries === null || queries === void 0 ? void 0 : queries.messageListParams;\n  var _q = useState(null),\n    quoteMessage = _q[0],\n    setQuoteMessage = _q[1];\n  var _r = useState(false),\n    isScrolled = _r[0],\n    setIsScrolled = _r[1];\n  var _s = useReducer(channelReducer, initialState),\n    messagesStore = _s[0],\n    messagesDispatcher = _s[1];\n  var scrollRef = useRef(null);\n  var isMentionEnabled = groupChannel.enableMention;\n  var allMessages = messagesStore.allMessages,\n    localMessages = messagesStore.localMessages,\n    loading = messagesStore.loading,\n    initialized = messagesStore.initialized,\n    unreadSince = messagesStore.unreadSince,\n    unreadSinceDate = messagesStore.unreadSinceDate,\n    isInvalid = messagesStore.isInvalid,\n    currentGroupChannel = messagesStore.currentGroupChannel,\n    hasMorePrev = messagesStore.hasMorePrev,\n    oldestMessageTimeStamp = messagesStore.oldestMessageTimeStamp,\n    hasMoreNext = messagesStore.hasMoreNext,\n    latestMessageTimeStamp = messagesStore.latestMessageTimeStamp,\n    emojiContainer = messagesStore.emojiContainer,\n    readStatus = messagesStore.readStatus,\n    typingMembers = messagesStore.typingMembers;\n  var usingReaction = getIsReactionEnabled({\n    channel: currentGroupChannel,\n    config: config,\n    moduleLevel: isReactionEnabled\n  });\n  var emojiAllMap = useMemo(function () {\n    return usingReaction ? getAllEmojisMapFromEmojiContainer(emojiContainer) : new Map();\n  }, [emojiContainer]);\n  var nicknamesMap = useMemo(function () {\n    return usingReaction && currentGroupChannel ? getNicknamesMapFromMembers(currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.members) : new Map();\n  }, [currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.members]);\n  // Animate message\n  useEffect(function () {\n    if (animatedMessage) {\n      setAnimatedMessageId(animatedMessage);\n    }\n  }, [animatedMessage]);\n  // Scrollup is default scroll for channel\n  var onScrollCallback = useScrollCallback({\n    currentGroupChannel: currentGroupChannel,\n    oldestMessageTimeStamp: oldestMessageTimeStamp,\n    userFilledMessageListQuery: userFilledMessageListQuery,\n    replyType: replyType\n  }, {\n    hasMorePrev: hasMorePrev,\n    logger: logger,\n    messagesDispatcher: messagesDispatcher,\n    sdk: sdk\n  });\n  var scrollToMessage = useScrollToMessage({\n    setInitialTimeStamp: setInitialTimeStamp,\n    setAnimatedMessageId: setAnimatedMessageId,\n    allMessages: allMessages,\n    scrollRef: scrollRef\n  }, {\n    logger: logger\n  });\n  // onScrollDownCallback is added for navigation to different timestamps on messageSearch\n  // hasMorePrev, onScrollCallback -> scroll up(default behavior)\n  // hasMoreNext, onScrollDownCallback -> scroll down\n  var onScrollDownCallback = useScrollDownCallback({\n    currentGroupChannel: currentGroupChannel,\n    latestMessageTimeStamp: latestMessageTimeStamp,\n    userFilledMessageListQuery: userFilledMessageListQuery,\n    hasMoreNext: hasMoreNext,\n    replyType: replyType\n  }, {\n    logger: logger,\n    messagesDispatcher: messagesDispatcher,\n    sdk: sdk\n  });\n  var toggleReaction = useToggleReactionCallback(currentGroupChannel, logger);\n  // to create message-datasource\n  // this hook sets currentGroupChannel asynchronously\n  useGetChannel({\n    channelUrl: channelUrl,\n    sdkInit: sdkInit,\n    disableMarkAsRead: disableMarkAsRead\n  }, {\n    messagesDispatcher: messagesDispatcher,\n    sdk: sdk,\n    logger: logger,\n    markAsReadScheduler: markAsReadScheduler\n  });\n  // to set quote message as null\n  useEffect(function () {\n    setQuoteMessage(null);\n  }, [channelUrl]);\n  // Hook to handle ChannelEvents and send values to useReducer using messagesDispatcher\n  useHandleChannelEvents({\n    currentGroupChannel: currentGroupChannel,\n    sdkInit: sdkInit,\n    currentUserId: userId,\n    disableMarkAsRead: disableMarkAsRead\n  }, {\n    messagesDispatcher: messagesDispatcher,\n    sdk: sdk,\n    logger: logger,\n    scrollRef: scrollRef,\n    setQuoteMessage: setQuoteMessage\n  });\n  // hook that fetches messages when channel changes\n  // to be clear here useGetChannel sets currentGroupChannel\n  // and useInitialMessagesFetch executes when currentGroupChannel changes\n  // p.s This one executes on initialTimeStamp change too\n  useInitialMessagesFetch({\n    currentGroupChannel: currentGroupChannel,\n    userFilledMessageListQuery: userFilledMessageListQuery,\n    initialTimeStamp: initialTimeStamp,\n    replyType: replyType,\n    setIsScrolled: setIsScrolled\n  }, {\n    logger: logger,\n    scrollRef: scrollRef,\n    messagesDispatcher: messagesDispatcher\n  });\n  // handles API calls from withSendbird\n  useHandleChannelPubsubEvents({\n    channelUrl: channelUrl,\n    sdkInit: sdkInit,\n    pubSub: pubSub,\n    dispatcher: messagesDispatcher,\n    scrollRef: scrollRef\n  });\n  // handling connection breaks\n  useHandleReconnect({\n    isOnline: isOnline,\n    replyType: replyType,\n    disableMarkAsRead: disableMarkAsRead,\n    reconnectOnIdle: reconnectOnIdle\n  }, {\n    logger: logger,\n    sdk: sdk,\n    scrollRef: scrollRef,\n    currentGroupChannel: currentGroupChannel,\n    messagesDispatcher: messagesDispatcher,\n    userFilledMessageListQuery: userFilledMessageListQuery,\n    markAsReadScheduler: markAsReadScheduler\n  });\n  // callbacks for Message CURD actions\n  var deleteMessage = useDeleteMessageCallback({\n    currentGroupChannel: currentGroupChannel,\n    messagesDispatcher: messagesDispatcher\n  }, {\n    logger: logger\n  });\n  var updateMessage = useUpdateMessageCallback({\n    currentGroupChannel: currentGroupChannel,\n    messagesDispatcher: messagesDispatcher,\n    onBeforeUpdateUserMessage: onBeforeUpdateUserMessage,\n    isMentionEnabled: isMentionEnabled\n  }, {\n    logger: logger,\n    pubSub: pubSub\n  });\n  var resendMessage = useResendMessageCallback({\n    currentGroupChannel: currentGroupChannel,\n    messagesDispatcher: messagesDispatcher\n  }, {\n    logger: logger,\n    pubSub: pubSub\n  });\n  var _t = useSendMessageCallback({\n      currentGroupChannel: currentGroupChannel,\n      isMentionEnabled: isMentionEnabled,\n      onBeforeSendUserMessage: onBeforeSendUserMessage\n    }, {\n      logger: logger,\n      pubSub: pubSub,\n      scrollRef: scrollRef,\n      messagesDispatcher: messagesDispatcher\n    }),\n    messageInputRef = _t[0],\n    sendMessage = _t[1];\n  var sendFileMessage = useSendFileMessageCallback({\n    currentGroupChannel: currentGroupChannel,\n    imageCompression: imageCompression,\n    onBeforeSendFileMessage: onBeforeSendFileMessage\n  }, {\n    logger: logger,\n    pubSub: pubSub,\n    scrollRef: scrollRef,\n    messagesDispatcher: messagesDispatcher\n  })[0];\n  var sendVoiceMessage = useSendVoiceMessageCallback({\n    currentGroupChannel: currentGroupChannel,\n    onBeforeSendVoiceMessage: onBeforeSendVoiceMessage\n  }, {\n    logger: logger,\n    pubSub: pubSub,\n    scrollRef: scrollRef,\n    messagesDispatcher: messagesDispatcher\n  })[0];\n  var sendMultipleFilesMessage = useSendMultipleFilesMessage({\n    currentChannel: currentGroupChannel,\n    onBeforeSendMultipleFilesMessage: onBeforeSendMultipleFilesMessage,\n    publishingModules: [PublishingModuleType.CHANNEL]\n  }, {\n    logger: logger,\n    pubSub: pubSub,\n    scrollRef: scrollRef\n  })[0];\n  return React__default.createElement(ChannelContext.Provider, {\n    value: {\n      // props\n      channelUrl: channelUrl,\n      isReactionEnabled: usingReaction,\n      isMessageGroupingEnabled: isMessageGroupingEnabled,\n      isMultipleFilesMessageEnabled: isMultipleFilesMessageEnabled,\n      showSearchIcon: showSearchIcon !== null && showSearchIcon !== void 0 ? showSearchIcon : globalConfigs.groupChannelSettings.enableMessageSearch,\n      highlightedMessage: highlightedMessage,\n      startingPoint: startingPoint,\n      onBeforeSendUserMessage: onBeforeSendUserMessage,\n      onBeforeSendFileMessage: onBeforeSendFileMessage,\n      onBeforeUpdateUserMessage: onBeforeUpdateUserMessage,\n      onChatHeaderActionClick: onChatHeaderActionClick,\n      onSearchClick: onSearchClick,\n      onBackClick: onBackClick,\n      replyType: replyType,\n      threadReplySelectType: (_f = threadReplySelectType !== null && threadReplySelectType !== void 0 ? threadReplySelectType : getCaseResolvedThreadReplySelectType(groupChannel.threadReplySelectType).upperCase) !== null && _f !== void 0 ? _f : ThreadReplySelectType.THREAD,\n      queries: queries,\n      filterMessageList: filterMessageList,\n      disableMarkAsRead: disableMarkAsRead,\n      onReplyInThread: onReplyInThread,\n      onQuoteMessageClick: onQuoteMessageClick,\n      onMessageAnimated: onMessageAnimated,\n      onMessageHighlighted: onMessageHighlighted,\n      // messagesStore\n      allMessages: allMessages,\n      localMessages: localMessages,\n      loading: loading,\n      initialized: initialized,\n      unreadSince: unreadSince,\n      unreadSinceDate: unreadSinceDate,\n      isInvalid: isInvalid,\n      currentGroupChannel: currentGroupChannel,\n      hasMorePrev: hasMorePrev,\n      hasMoreNext: hasMoreNext,\n      oldestMessageTimeStamp: oldestMessageTimeStamp,\n      latestMessageTimeStamp: latestMessageTimeStamp,\n      emojiContainer: emojiContainer,\n      readStatus: readStatus,\n      typingMembers: typingMembers,\n      // utils\n      scrollToMessage: scrollToMessage,\n      quoteMessage: quoteMessage,\n      setQuoteMessage: setQuoteMessage,\n      deleteMessage: deleteMessage,\n      updateMessage: updateMessage,\n      resendMessage: resendMessage,\n      messageInputRef: messageInputRef,\n      sendMessage: sendMessage,\n      sendFileMessage: sendFileMessage,\n      sendVoiceMessage: sendVoiceMessage,\n      sendMultipleFilesMessage: sendMultipleFilesMessage,\n      initialTimeStamp: initialTimeStamp,\n      messageActionTypes: channelActions,\n      messagesDispatcher: messagesDispatcher,\n      setInitialTimeStamp: setInitialTimeStamp,\n      setAnimatedMessageId: setAnimatedMessageId,\n      setHighLightedMessageId: setHighLightedMessageId,\n      animatedMessageId: animatedMessageId,\n      highLightedMessageId: highLightedMessageId,\n      nicknamesMap: nicknamesMap,\n      emojiAllMap: emojiAllMap,\n      onScrollCallback: onScrollCallback,\n      onScrollDownCallback: onScrollDownCallback,\n      scrollRef: scrollRef,\n      scrollBehavior: scrollBehavior,\n      toggleReaction: toggleReaction,\n      isScrolled: isScrolled,\n      setIsScrolled: setIsScrolled\n    }\n  }, React__default.createElement(UserProfileProvider, {\n    disableUserProfile: (_g = props === null || props === void 0 ? void 0 : props.disableUserProfile) !== null && _g !== void 0 ? _g : !config.common.enableUsingDefaultUserProfile,\n    renderUserProfile: props === null || props === void 0 ? void 0 : props.renderUserProfile,\n    onUserProfileMessage: onUserProfileMessage\n  }, children));\n};\nvar useChannelContext = function () {\n  var context = React__default.useContext(ChannelContext);\n  if (!context) throw new Error('ChannelContext not found. Use within the Channel module.');\n  return context;\n};\nexport { ChannelProvider, useChannelContext };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import React__default, { useEffect, useCallback, useRef, useState, useReducer, useMemo } from 'react';\nimport { U as UserProfileProvider } from '../chunks/bundle-BrTJ5Zbd.js';\nimport { useSendbirdStateContext } from '../useSendbirdStateContext.js';\nimport { T as ThreadReplySelectType } from '../chunks/bundle-CveCFQYP.js';\nimport { m as mergeAndSortMessages, p as passUnsuccessfullMessages, s as scrollIntoLast, d as scrollToRenderedMessage, g as getAllEmojisMapFromEmojiContainer, e as getNicknamesMapFromMembers } from '../chunks/bundle-CMLImr6T.js';\nimport { g as getIsReactionEnabled } from '../chunks/bundle-BNDaXsLn.js';\nimport { _ as __assign, c as __spreadArray } from '../chunks/bundle-BQi9-O76.js';\nimport { f as format } from '../chunks/bundle-CAdqcqOm.js';\nimport { SendingStatus, ReplyType, MessageMetaArray } from '@sendbird/chat/message';\nimport { K, k as isSendableMessage, a1 as S, a3 as filterMessageListParams } from '../chunks/bundle-DxTN4_0p.js';\nimport { R as RESET_MESSAGES, F as FETCH_INITIAL_MESSAGES_START, a as FETCH_INITIAL_MESSAGES_SUCCESS, c as FETCH_PREV_MESSAGES_SUCCESS, d as FETCH_NEXT_MESSAGES_SUCCESS, b as FETCH_INITIAL_MESSAGES_FAILURE, e as FETCH_PREV_MESSAGES_FAILURE, f as FETCH_NEXT_MESSAGES_FAILURE, S as SEND_MESSAGE_START, g as SEND_MESSAGE_SUCCESS, h as SEND_MESSAGE_FAILURE, i as SET_CURRENT_CHANNEL, j as SET_CHANNEL_INVALID, O as ON_MESSAGE_RECEIVED, k as ON_MESSAGE_UPDATED, l as ON_MESSAGE_THREAD_INFO_UPDATED, m as RESEND_MESSAGE_START, n as MARK_AS_READ, o as ON_MESSAGE_DELETED, p as ON_MESSAGE_DELETED_BY_REQ_ID, q as SET_EMOJI_CONTAINER, r as ON_REACTION_UPDATED, M as MESSAGE_LIST_PARAMS_CHANGED, s as ON_FILE_INFO_UPLOADED, t as ON_TYPING_STATUS_UPDATED, u as channelActions } from '../chunks/bundle-CpjASiz4.js';\nimport { c as compareIds } from '../chunks/bundle-CZUYMubi.js';\nimport { P as PREV_RESULT_SIZE, N as NEXT_RESULT_SIZE, u as useInitialMessagesFetch } from '../chunks/bundle-chiYJ8F8.js';\nimport { GroupChannelHandler } from '@sendbird/chat/groupChannel';\nimport { u as uuidv4 } from '../chunks/bundle-etuaqevl.js';\nimport { u as useReconnectOnIdle } from '../chunks/bundle-H8J7tAed.js';\nimport { c as SCROLL_BOTTOM_DELAY_FOR_FETCH, d as SCROLL_BOTTOM_DELAY_FOR_SEND, e as VOICE_MESSAGE_FILE_NAME, a as VOICE_MESSAGE_MIME_TYPE, M as META_ARRAY_VOICE_DURATION_KEY, f as META_ARRAY_MESSAGE_TYPE_KEY, g as META_ARRAY_MESSAGE_TYPE_VALUE__VOICE } from '../chunks/bundle-DCMGp6rH.js';\nimport { p as pubSubTopics, P as PublishingModuleType, b as PUBSUB_TOPICS, s as shouldPubSubPublishToChannel } from '../chunks/bundle-b6TpX_JP.js';\nimport { u as useToggleReactionCallback } from '../chunks/bundle-y29vL7zu.js';\nimport { g as getCaseResolvedReplyType, a as getCaseResolvedThreadReplySelectType } from '../chunks/bundle-fHeMHhND.js';\nimport { u as useSendMultipleFilesMessage } from '../chunks/bundle-T6fVCCb7.js';\nimport '../withSendbird.js';\nimport '../chunks/bundle-CA85nVxp.js';\nimport '../chunks/bundle-bdDHjHH6.js';\nimport '../utils/message/getOutgoingMessageState.js';\nimport '../chunks/bundle-CNWAfTVw.js';\n\nvar initialState = {\n    initialized: false,\n    loading: true,\n    allMessages: [],\n    /**\n     * localMessages: pending & failed messages\n     */\n    localMessages: [],\n    currentGroupChannel: null,\n    // for scrollup\n    hasMorePrev: false,\n    oldestMessageTimeStamp: 0,\n    // for scroll down\n    // onScrollDownCallback is added for navigation to different timestamps on messageSearch\n    // hasMorePrev, onScrollCallback -> scroll up(default behavior)\n    // hasMoreNext, onScrollDownCallback -> scroll down\n    hasMoreNext: false,\n    latestMessageTimeStamp: 0,\n    emojiContainer: { emojiCategories: [], emojiHash: '' },\n    /** @deprecated Please use `unreadSinceDate` instead. * */\n    unreadSince: null,\n    /**\n     * unreadSinceDate is a date information about message unread.\n     * It's used only for the {unreadSinceDate && <UnreadCount unreadSinceDate={unreadSinceDate} />}\n     */\n    unreadSinceDate: null,\n    isInvalid: false,\n    readStatus: null,\n    messageListParams: null,\n    typingMembers: [],\n};\n\nvar getOldestMessageTimeStamp = function (messages) {\n    if (messages === void 0) { messages = []; }\n    var oldestMessage = messages[0];\n    return (oldestMessage && oldestMessage.createdAt) || null;\n};\nvar getLatestMessageTimeStamp = function (messages) {\n    if (messages === void 0) { messages = []; }\n    var latestMessage = messages[messages.length - 1];\n    return (latestMessage && latestMessage.createdAt) || null;\n};\nfunction hasReqId(message) {\n    return 'reqId' in message;\n}\nfunction channelReducer(state, action) {\n    return K(action)\n        .with({ type: RESET_MESSAGES }, function () {\n        return __assign(__assign({}, state), { \n            // when user switches channel, if the previous channel `hasMorePrev`\n            // the onScroll gets called twice, setting hasMorePrev false prevents this\n            hasMorePrev: false, hasMoreNext: false, allMessages: [], localMessages: [] });\n    })\n        .with({ type: FETCH_INITIAL_MESSAGES_START }, function () {\n        return __assign(__assign({}, state), { loading: true, allMessages: state.allMessages.filter(function (m) { return isSendableMessage(m)\n                ? m.sendingStatus !== SendingStatus.SUCCEEDED\n                : true; }), localMessages: [] });\n    })\n        .with({ type: FETCH_INITIAL_MESSAGES_SUCCESS }, function (action) {\n        var _a;\n        var _b = action.payload, currentGroupChannel = _b.currentGroupChannel, messages = _b.messages;\n        if (!((currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) === ((_a = state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url))) {\n            return state;\n        }\n        var oldestMessageTimeStamp = getOldestMessageTimeStamp(messages);\n        var latestMessageTimeStamp = getLatestMessageTimeStamp(messages);\n        return __assign(__assign({}, state), { loading: false, initialized: true, hasMorePrev: true, hasMoreNext: true, oldestMessageTimeStamp: oldestMessageTimeStamp, latestMessageTimeStamp: latestMessageTimeStamp, allMessages: __spreadArray([], messages, true) });\n    })\n        .with({ type: FETCH_PREV_MESSAGES_SUCCESS }, function (action) {\n        var _a, _b, _c, _d;\n        var _e = action.payload, currentGroupChannel = _e.currentGroupChannel, messages = _e.messages;\n        if (!((currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) === ((_a = state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url))) {\n            return state;\n        }\n        var hasMorePrev = ((_b = messages === null || messages === void 0 ? void 0 : messages.length) !== null && _b !== void 0 ? _b : 0)\n            >= ((_d = (_c = state === null || state === void 0 ? void 0 : state.messageListParams) === null || _c === void 0 ? void 0 : _c.prevResultSize) !== null && _d !== void 0 ? _d : PREV_RESULT_SIZE) + 1;\n        var oldestMessageTimeStamp = getOldestMessageTimeStamp(messages);\n        // Remove duplicated messages\n        var duplicatedMessageIds = [];\n        var updatedOldMessages = state.allMessages.map(function (msg) {\n            var duplicatedMessage = messages.find(function (_a) {\n                var messageId = _a.messageId;\n                return compareIds(messageId, msg.messageId);\n            });\n            if (!duplicatedMessage) {\n                return msg;\n            }\n            duplicatedMessageIds.push(duplicatedMessage.messageId);\n            return duplicatedMessage.updatedAt > msg.updatedAt\n                ? duplicatedMessage\n                : msg;\n        });\n        var filteredNewMessages = duplicatedMessageIds.length > 0\n            ? messages.filter(function (msg) { return !duplicatedMessageIds.find(function (messageId) { return compareIds(messageId, msg.messageId); }); })\n            : messages;\n        return __assign(__assign({}, state), { hasMorePrev: hasMorePrev, oldestMessageTimeStamp: oldestMessageTimeStamp, allMessages: __spreadArray(__spreadArray([], filteredNewMessages, true), updatedOldMessages, true) });\n    })\n        .with({ type: FETCH_NEXT_MESSAGES_SUCCESS }, function (action) {\n        var _a, _b, _c, _d;\n        var _e = action.payload, currentGroupChannel = _e.currentGroupChannel, messages = _e.messages;\n        if (!((currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) === ((_a = state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url))) {\n            return state;\n        }\n        var hasMoreNext = ((_b = messages === null || messages === void 0 ? void 0 : messages.length) !== null && _b !== void 0 ? _b : 0)\n            === ((_d = (_c = state === null || state === void 0 ? void 0 : state.messageListParams) === null || _c === void 0 ? void 0 : _c.nextResultSize) !== null && _d !== void 0 ? _d : NEXT_RESULT_SIZE) + 1;\n        var latestMessageTimeStamp = getLatestMessageTimeStamp(messages);\n        // sort ~\n        var sortedMessages = mergeAndSortMessages(state.allMessages, messages);\n        return __assign(__assign({}, state), { hasMoreNext: hasMoreNext, latestMessageTimeStamp: latestMessageTimeStamp, allMessages: sortedMessages });\n    })\n        .with({\n        type: S.union(FETCH_INITIAL_MESSAGES_FAILURE, FETCH_PREV_MESSAGES_FAILURE, FETCH_NEXT_MESSAGES_FAILURE),\n    }, function (action) {\n        var _a;\n        var currentGroupChannel = action.payload.currentGroupChannel;\n        if ((currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) !== ((_a = state === null || state === void 0 ? void 0 : state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url))\n            return state;\n        // It shows something went wrong screen when fetching initial messages failed.\n        var shouldInvalid = [FETCH_INITIAL_MESSAGES_FAILURE].includes(action.type);\n        return __assign(__assign({}, state), { loading: false, isInvalid: shouldInvalid, initialized: false, allMessages: [], hasMorePrev: false, hasMoreNext: false, oldestMessageTimeStamp: null, latestMessageTimeStamp: null });\n    })\n        .with({ type: SEND_MESSAGE_START }, function (action) {\n        // Message should not be spread here\n        // it will loose some methods like `isUserMessage`\n        return __assign(__assign({}, state), { localMessages: __spreadArray(__spreadArray([], state.localMessages, true), [action.payload], false) });\n    })\n        .with({ type: SEND_MESSAGE_SUCCESS }, function (action) {\n        var message = action.payload;\n        /**\n         * Admin messages do not have reqId. We need to include them.\n         */\n        var filteredMessages = state.allMessages.filter(function (m) { return !hasReqId(m) || (m === null || m === void 0 ? void 0 : m.reqId) !== (message === null || message === void 0 ? void 0 : message.reqId); });\n        // [Policy] Pending messages and failed messages\n        // must always be at the end of the message list\n        return __assign(__assign({}, state), { allMessages: __spreadArray(__spreadArray([], filteredMessages, true), [message], false), localMessages: state.localMessages.filter(function (m) { return hasReqId(m) && (m === null || m === void 0 ? void 0 : m.reqId) !== (message === null || message === void 0 ? void 0 : message.reqId); }) });\n    })\n        .with({ type: SEND_MESSAGE_FAILURE }, function (action) {\n        // @ts-ignore\n        action.payload.failed = true;\n        return __assign(__assign({}, state), { localMessages: state.localMessages.map(function (m) { return compareIds(hasReqId(m) && m.reqId, action.payload.reqId)\n                ? action.payload\n                : m; }) });\n    })\n        .with({ type: SET_CURRENT_CHANNEL }, function (action) {\n        return __assign(__assign({}, state), { currentGroupChannel: action.payload, isInvalid: false });\n    })\n        .with({ type: SET_CHANNEL_INVALID }, function () {\n        return __assign(__assign({}, state), { currentGroupChannel: null, allMessages: [], localMessages: [], isInvalid: true });\n    })\n        .with({ type: ON_MESSAGE_RECEIVED }, function (action) {\n        var _a, _b;\n        var _c = action.payload, channel = _c.channel, message = _c.message;\n        var members = channel.members;\n        var sender = message.sender;\n        var currentGroupChannel = state.currentGroupChannel;\n        var currentGroupChannelUrl = currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url;\n        if (!compareIds(channel === null || channel === void 0 ? void 0 : channel.url, currentGroupChannelUrl)) {\n            return state;\n        }\n        // Excluded overlapping messages\n        if (state.allMessages.some(function (msg) { return msg.messageId === message.messageId; })) {\n            return state;\n        }\n        // Filter by userFilledQuery\n        if (state.messageListParams\n            && !filterMessageListParams(state.messageListParams, message)) {\n            return state;\n        }\n        if (message.isAdminMessage && message.isAdminMessage()) {\n            return __assign(__assign({}, state), { allMessages: passUnsuccessfullMessages(state.allMessages, message) });\n        }\n        // Update members when sender profileUrl, nickname, friendName has been changed\n        var senderMember = members === null || members === void 0 ? void 0 : members.find(function (m) { return (m === null || m === void 0 ? void 0 : m.userId) === (sender === null || sender === void 0 ? void 0 : sender.userId); });\n        if ((senderMember === null || senderMember === void 0 ? void 0 : senderMember.profileUrl) !== (sender === null || sender === void 0 ? void 0 : sender.profileUrl)\n            || (senderMember === null || senderMember === void 0 ? void 0 : senderMember.friendName) !== (sender === null || sender === void 0 ? void 0 : sender.friendName)\n            || (senderMember === null || senderMember === void 0 ? void 0 : senderMember.nickname) !== (sender === null || sender === void 0 ? void 0 : sender.nickname)) {\n            // @ts-ignore\n            channel.members = members.map(function (member) {\n                if (member.userId === sender.userId) {\n                    return sender;\n                }\n                return member;\n            });\n        }\n        return __assign(__assign({}, state), { currentGroupChannel: channel, unreadSince: (_a = state.unreadSince) !== null && _a !== void 0 ? _a : format(new Date(), 'p MMM dd'), unreadSinceDate: (_b = state.unreadSinceDate) !== null && _b !== void 0 ? _b : new Date(), allMessages: passUnsuccessfullMessages(state.allMessages, message) });\n    })\n        .with({ type: ON_MESSAGE_UPDATED }, function (action) {\n        var _a;\n        var _b = action.payload, channel = _b.channel, message = _b.message;\n        var currentGroupChannelUrl = ((_a = state === null || state === void 0 ? void 0 : state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url) || '';\n        if (!compareIds(channel === null || channel === void 0 ? void 0 : channel.url, currentGroupChannelUrl)) {\n            return state; // Ignore event when it is not for the current channel\n        }\n        if (state.messageListParams\n            && !filterMessageListParams(state.messageListParams, message)) {\n            // Delete the message if it doesn't match to the params anymore\n            return __assign(__assign({}, state), { allMessages: state.allMessages.filter(function (m) { return !compareIds(m.messageId, message === null || message === void 0 ? void 0 : message.messageId); }) });\n        }\n        return __assign(__assign({}, state), { allMessages: state.allMessages.map(function (m) {\n                if (compareIds(m.messageId, message.messageId)) {\n                    return message;\n                }\n                if (compareIds(m.parentMessageId, message.messageId)) {\n                    m.parentMessage = message; // eslint-disable-line no-param-reassign\n                }\n                return m;\n            }) });\n    })\n        .with({ type: ON_MESSAGE_THREAD_INFO_UPDATED }, function (action) {\n        var _a;\n        var _b = action.payload, channel = _b.channel, event = _b.event;\n        var channelUrl = event.channelUrl, threadInfo = event.threadInfo, targetMessageId = event.targetMessageId;\n        var currentGroupChannelUrl = ((_a = state === null || state === void 0 ? void 0 : state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url) || '';\n        if (!compareIds(channel === null || channel === void 0 ? void 0 : channel.url, currentGroupChannelUrl)\n            || !compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n            return state; // Ignore event when it is not for the current channel\n        }\n        return __assign(__assign({}, state), { allMessages: state.allMessages.map(function (m) {\n                if (compareIds(m.messageId, targetMessageId)) {\n                    // eslint-disable-next-line no-param-reassign\n                    m.threadInfo = threadInfo; // Upsert threadInfo to the target message\n                }\n                return m;\n            }) });\n    })\n        .with({ type: RESEND_MESSAGE_START }, function (action) {\n        return __assign(__assign({}, state), { localMessages: state.localMessages.map(function (m) { return compareIds(hasReqId(m) && m.reqId, action.payload.reqId)\n                ? action.payload\n                : m; }) });\n    })\n        .with({ type: MARK_AS_READ }, function (action) {\n        var _a, _b, _c;\n        if (((_a = state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url) !== ((_c = (_b = action.payload) === null || _b === void 0 ? void 0 : _b.channel) === null || _c === void 0 ? void 0 : _c.url)) {\n            return state;\n        }\n        return __assign(__assign({}, state), { unreadSince: null, unreadSinceDate: null });\n    })\n        .with({ type: ON_MESSAGE_DELETED }, function (action) {\n        return __assign(__assign({}, state), { allMessages: state.allMessages.filter(function (m) { return !compareIds(m.messageId, action.payload); }) });\n    })\n        .with({ type: ON_MESSAGE_DELETED_BY_REQ_ID }, function (action) {\n        return __assign(__assign({}, state), { localMessages: state.localMessages.filter(function (m) { return !compareIds(hasReqId(m) && m.reqId, action.payload); }) });\n    })\n        .with({ type: SET_EMOJI_CONTAINER }, function (action) {\n        return __assign(__assign({}, state), { emojiContainer: action.payload });\n    })\n        .with({ type: ON_REACTION_UPDATED }, function (action) {\n        return __assign(__assign({}, state), { allMessages: state.allMessages.map(function (m) {\n                if (compareIds(m.messageId, action.payload.messageId)) {\n                    if (m.applyReactionEvent\n                        && typeof m.applyReactionEvent === 'function') {\n                        m.applyReactionEvent(action.payload);\n                    }\n                    return m;\n                }\n                return m;\n            }) });\n    })\n        .with({ type: MESSAGE_LIST_PARAMS_CHANGED }, function (action) {\n        return __assign(__assign({}, state), { messageListParams: action.payload });\n    })\n        .with({ type: ON_FILE_INFO_UPLOADED }, function (action) {\n        var _a, _b;\n        var _c = action.payload, channelUrl = _c.channelUrl, requestId = _c.requestId, index = _c.index, uploadableFileInfo = _c.uploadableFileInfo, error = _c.error;\n        if (!compareIds(channelUrl, (_a = state === null || state === void 0 ? void 0 : state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url)) {\n            return state;\n        }\n        /**\n         * We don't have to do anything here because\n         * onFailed() will be called so handle error there instead.\n         */\n        if (error)\n            return state;\n        var localMessages = state.localMessages;\n        var messageToUpdate = localMessages.find(function (message) { return compareIds(hasReqId(message) && message.reqId, requestId); });\n        var fileInfoList = (_b = messageToUpdate\n            .messageParams) === null || _b === void 0 ? void 0 : _b.fileInfoList;\n        if (Array.isArray(fileInfoList)) {\n            fileInfoList[index] = uploadableFileInfo;\n        }\n        return __assign(__assign({}, state), { localMessages: localMessages });\n    })\n        .with({ type: ON_TYPING_STATUS_UPDATED }, function (action) {\n        var _a;\n        var _b = action.payload, channel = _b.channel, typingMembers = _b.typingMembers;\n        if (!compareIds(channel.url, (_a = state === null || state === void 0 ? void 0 : state.currentGroupChannel) === null || _a === void 0 ? void 0 : _a.url)) {\n            return state;\n        }\n        return __assign(__assign({}, state), { typingMembers: typingMembers });\n    })\n        .otherwise(function () { return state; });\n}\n\nvar DELIVERY_RECEIPT = 'delivery_receipt';\nfunction useHandleChannelEvents(_a, _b) {\n    var _c, _d, _e;\n    var sdkInit = _a.sdkInit, currentGroupChannel = _a.currentGroupChannel, disableMarkAsRead = _a.disableMarkAsRead;\n    var sdk = _b.sdk, logger = _b.logger, scrollRef = _b.scrollRef, setQuoteMessage = _b.setQuoteMessage, messagesDispatcher = _b.messagesDispatcher;\n    var store = useSendbirdStateContext();\n    var _f = store.config, markAsReadScheduler = _f.markAsReadScheduler, markAsDeliveredScheduler = _f.markAsDeliveredScheduler, disableMarkAsDelivered = _f.disableMarkAsDelivered;\n    var canSetMarkAsDelivered = (_e = (_d = (_c = store.stores.sdkStore.sdk) === null || _c === void 0 ? void 0 : _c.appInfo) === null || _d === void 0 ? void 0 : _d.premiumFeatureList) === null || _e === void 0 ? void 0 : _e.find(function (feature) { return (feature === DELIVERY_RECEIPT); });\n    useEffect(function () {\n        var _a;\n        var channelUrl = currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url;\n        var channelHandlerId = uuidv4();\n        if (channelUrl && sdkInit) {\n            var channelHandler = {\n                onMessageReceived: function (channel, message) {\n                    var _a, _b;\n                    if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n                        var scrollToEnd = false;\n                        try {\n                            var current = scrollRef.current;\n                            if (current) {\n                                scrollToEnd = current.offsetHeight + current.scrollTop >= current.scrollHeight - 10;\n                            }\n                            // 10 is a buffer\n                        }\n                        catch (error) {\n                            //\n                        }\n                        logger.info('Channel | useHandleChannelEvents: onMessageReceived', message);\n                        messagesDispatcher({\n                            type: ON_MESSAGE_RECEIVED,\n                            payload: { channel: channel, message: message },\n                        });\n                        if (scrollToEnd\n                            && ((_a = document.getElementById('sendbird-dropdown-portal')) === null || _a === void 0 ? void 0 : _a.childElementCount) === 0\n                            && ((_b = document.getElementById('sendbird-emoji-list-portal')) === null || _b === void 0 ? void 0 : _b.childElementCount) === 0) {\n                            // and !openContextMenu\n                            try {\n                                setTimeout(function () { return scrollIntoLast(0, scrollRef); });\n                                if (!disableMarkAsRead) {\n                                    markAsReadScheduler.push(currentGroupChannel);\n                                }\n                                if (canSetMarkAsDelivered && !disableMarkAsDelivered) {\n                                    markAsDeliveredScheduler.push(currentGroupChannel);\n                                }\n                            }\n                            catch (error) {\n                                logger.warning('Channel | onMessageReceived | scroll to end failed');\n                            }\n                        }\n                    }\n                },\n                onUnreadMemberStatusUpdated: function (channel) {\n                    logger.info('Channel | useHandleChannelEvents: onUnreadMemberStatusUpdated', channel);\n                    if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n                        messagesDispatcher({\n                            type: SET_CURRENT_CHANNEL,\n                            payload: channel,\n                        });\n                    }\n                },\n                // before(onDeliveryReceiptUpdated)\n                onUndeliveredMemberStatusUpdated: function (channel) {\n                    if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n                        logger.info('Channel | useHandleChannelEvents: onDeliveryReceiptUpdated', channel);\n                        messagesDispatcher({\n                            type: SET_CURRENT_CHANNEL,\n                            payload: channel,\n                        });\n                    }\n                },\n                onMessageUpdated: function (channel, message) {\n                    if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n                        logger.info('Channel | useHandleChannelEvents: onMessageUpdated', message);\n                        messagesDispatcher({\n                            type: ON_MESSAGE_UPDATED,\n                            payload: { channel: channel, message: message },\n                        });\n                    }\n                },\n                onThreadInfoUpdated: function (channel, threadInfoUpdateEvent) {\n                    if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n                        logger.info('Channel | useHandleChannelEvents: onThreadInfoUpdated', { channel: channel, threadInfoUpdateEvent: threadInfoUpdateEvent });\n                        messagesDispatcher({\n                            type: ON_MESSAGE_THREAD_INFO_UPDATED,\n                            payload: { channel: channel, event: threadInfoUpdateEvent },\n                        });\n                    }\n                },\n                onMessageDeleted: function (channel, messageId) {\n                    logger.info('Channel | useHandleChannelEvents: onMessageDeleted', { channel: channel, messageId: messageId });\n                    setQuoteMessage(null);\n                    messagesDispatcher({\n                        type: ON_MESSAGE_DELETED,\n                        payload: messageId,\n                    });\n                },\n                onReactionUpdated: function (channel, reactionEvent) {\n                    logger.info('Channel | useHandleChannelEvents: onReactionUpdated', { channel: channel, reactionEvent: reactionEvent });\n                    messagesDispatcher({\n                        type: ON_REACTION_UPDATED,\n                        payload: reactionEvent,\n                    });\n                },\n                onChannelChanged: function (channel) {\n                    if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n                        logger.info('Channel | useHandleChannelEvents: onChannelChanged', channel);\n                        messagesDispatcher({\n                            type: SET_CURRENT_CHANNEL,\n                            payload: channel,\n                        });\n                    }\n                },\n                onChannelFrozen: function (channel) {\n                    if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n                        logger.info('Channel | useHandleChannelEvents: onChannelFrozen', channel);\n                        messagesDispatcher({\n                            type: SET_CURRENT_CHANNEL,\n                            payload: channel,\n                        });\n                    }\n                },\n                onChannelUnfrozen: function (channel) {\n                    if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n                        logger.info('Channel | useHandleChannelEvents: onChannelUnFrozen', channel);\n                        messagesDispatcher({\n                            type: SET_CURRENT_CHANNEL,\n                            payload: channel,\n                        });\n                    }\n                },\n                onUserMuted: function (channel, user) {\n                    if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n                        logger.info('Channel | useHandleChannelEvents: onUserMuted', { channel: channel, user: user });\n                        messagesDispatcher({\n                            type: SET_CURRENT_CHANNEL,\n                            payload: channel,\n                        });\n                    }\n                },\n                onUserUnmuted: function (channel, user) {\n                    if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n                        logger.info('Channel | useHandleChannelEvents: onUserUnmuted', { channel: channel, user: user });\n                        messagesDispatcher({\n                            type: SET_CURRENT_CHANNEL,\n                            payload: channel,\n                        });\n                    }\n                },\n                onUserBanned: function (channel, user) {\n                    var _a;\n                    if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl) && channel.isGroupChannel()) {\n                        logger.info('Channel | useHandleChannelEvents: onUserBanned', { channel: channel, user: user });\n                        var isByMe = (user === null || user === void 0 ? void 0 : user.userId) === ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                        messagesDispatcher({\n                            type: SET_CURRENT_CHANNEL,\n                            payload: isByMe ? null : channel,\n                        });\n                    }\n                },\n                onOperatorUpdated: function (channel, users) {\n                    if (channel.isGroupChannel() && compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n                        logger.info('Channel | useHandleChannelEvents: onOperatorUpdated', { channel: channel, users: users });\n                        messagesDispatcher({\n                            type: SET_CURRENT_CHANNEL,\n                            payload: channel,\n                        });\n                    }\n                },\n                onUserLeft: function (channel, user) {\n                    var _a;\n                    if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n                        logger.info('Channel | useHandleChannelEvents: onUserLeft', { channel: channel, user: user });\n                        var isByMe = (user === null || user === void 0 ? void 0 : user.userId) === ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                        messagesDispatcher({\n                            type: SET_CURRENT_CHANNEL,\n                            payload: isByMe ? null : channel,\n                        });\n                    }\n                },\n                onTypingStatusUpdated: function (channel) {\n                    if (compareIds(channel === null || channel === void 0 ? void 0 : channel.url, channelUrl)) {\n                        logger.info('Channel | onTypingStatusUpdated', { channel: channel });\n                        var typingMembers = channel.getTypingUsers();\n                        messagesDispatcher({\n                            type: ON_TYPING_STATUS_UPDATED,\n                            payload: {\n                                channel: channel,\n                                typingMembers: typingMembers,\n                            },\n                        });\n                    }\n                },\n            };\n            logger.info('Channel | useHandleChannelEvents: Setup event handler', { channelHandlerId: channelHandlerId, channelHandler: channelHandler });\n            // Add this group channel handler to the Sendbird chat instance\n            (_a = sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.addGroupChannelHandler(channelHandlerId, new GroupChannelHandler(channelHandler));\n        }\n        return function () {\n            var _a;\n            if ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.removeGroupChannelHandler) {\n                logger.info('Channel | useHandleChannelEvents: Removing message reciver handler', channelHandlerId);\n                sdk.groupChannel.removeGroupChannelHandler(channelHandlerId);\n            }\n            else if (sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) {\n                logger.error('Channel | useHandleChannelEvents: Not found the removeGroupChannelHandler');\n            }\n        };\n    }, [currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url, sdkInit]);\n}\n\nfunction useGetChannel(_a, _b) {\n    var channelUrl = _a.channelUrl, sdkInit = _a.sdkInit, disableMarkAsRead = _a.disableMarkAsRead;\n    var messagesDispatcher = _b.messagesDispatcher, sdk = _b.sdk, logger = _b.logger, markAsReadScheduler = _b.markAsReadScheduler;\n    useEffect(function () {\n        if (channelUrl && sdkInit && sdk && sdk.groupChannel) {\n            logger.info('Channel | useSetChannel fetching channel', channelUrl);\n            sdk.groupChannel\n                .getChannel(channelUrl)\n                .then(function (groupChannel) {\n                logger.info('Channel | useSetChannel fetched channel', groupChannel);\n                messagesDispatcher({\n                    type: SET_CURRENT_CHANNEL,\n                    payload: groupChannel,\n                });\n                logger.info('Channel: Mark as read', groupChannel);\n                if (!disableMarkAsRead) {\n                    markAsReadScheduler.push(groupChannel);\n                }\n            })\n                .catch(function (e) {\n                logger.warning('Channel | useSetChannel fetch channel failed', { channelUrl: channelUrl, e: e });\n                messagesDispatcher({\n                    type: SET_CHANNEL_INVALID,\n                });\n            });\n            sdk\n                .getAllEmoji()\n                .then(function (emojiContainer_) {\n                logger.info('Channel: Getting emojis success', emojiContainer_);\n                messagesDispatcher({\n                    type: SET_EMOJI_CONTAINER,\n                    payload: emojiContainer_,\n                });\n            })\n                .catch(function (err) {\n                logger.error('Channel: Getting emojis failed', err);\n            });\n        }\n    }, [channelUrl, sdkInit]);\n}\n\nfunction useHandleReconnect(_a, _b) {\n    var isOnline = _a.isOnline, replyType = _a.replyType, disableMarkAsRead = _a.disableMarkAsRead, reconnectOnIdle = _a.reconnectOnIdle;\n    var logger = _b.logger, sdk = _b.sdk, scrollRef = _b.scrollRef, currentGroupChannel = _b.currentGroupChannel, messagesDispatcher = _b.messagesDispatcher, markAsReadScheduler = _b.markAsReadScheduler, userFilledMessageListQuery = _b.userFilledMessageListQuery;\n    var shouldReconnect = useReconnectOnIdle(isOnline, currentGroupChannel, reconnectOnIdle).shouldReconnect;\n    useEffect(function () {\n        return function () {\n            var _a, _b, _c;\n            // state changed from offline to online AND tab is visible\n            if (shouldReconnect) {\n                logger.info('Refreshing conversation state');\n                var isReactionEnabled = ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) === null || _a === void 0 ? void 0 : _a.useReaction) || false;\n                var messageListParams_1 = {\n                    prevResultSize: PREV_RESULT_SIZE,\n                    isInclusive: true,\n                    includeReactions: isReactionEnabled,\n                    includeMetaArray: true,\n                    nextResultSize: NEXT_RESULT_SIZE,\n                };\n                if (replyType && replyType === 'QUOTE_REPLY') {\n                    messageListParams_1.includeThreadInfo = true;\n                    messageListParams_1.includeParentMessageInfo = true;\n                    messageListParams_1.replyType = ReplyType.ONLY_REPLY_TO_CHANNEL;\n                }\n                if (userFilledMessageListQuery) {\n                    Object.keys(userFilledMessageListQuery).forEach(function (key) {\n                        // @ts-ignore\n                        messageListParams_1[key] = userFilledMessageListQuery[key];\n                    });\n                }\n                logger.info('Channel: Fetching messages', { currentGroupChannel: currentGroupChannel, userFilledMessageListQuery: userFilledMessageListQuery });\n                messagesDispatcher({\n                    type: FETCH_INITIAL_MESSAGES_START,\n                    payload: null,\n                });\n                (_b = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _b === void 0 ? void 0 : _b.getChannel((_c = currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) !== null && _c !== void 0 ? _c : '').then(function (groupChannel) {\n                    var lastMessageTime = new Date().getTime();\n                    groupChannel.getMessagesByTimestamp(lastMessageTime, messageListParams_1)\n                        .then(function (messages) {\n                        messagesDispatcher({\n                            type: FETCH_INITIAL_MESSAGES_SUCCESS,\n                            payload: {\n                                currentGroupChannel: groupChannel,\n                                messages: messages,\n                            },\n                        });\n                        setTimeout(function () { return scrollIntoLast(0, scrollRef); }, SCROLL_BOTTOM_DELAY_FOR_FETCH);\n                    })\n                        .catch(function (error) {\n                        logger.error('Channel: Fetching messages failed', error);\n                        messagesDispatcher({\n                            type: FETCH_INITIAL_MESSAGES_FAILURE,\n                            payload: { currentGroupChannel: groupChannel },\n                        });\n                    });\n                    if (!disableMarkAsRead) {\n                        markAsReadScheduler.push(groupChannel);\n                    }\n                });\n            }\n        };\n    }, [shouldReconnect, replyType]);\n}\n\nfunction useScrollCallback(_a, _b) {\n    var currentGroupChannel = _a.currentGroupChannel, oldestMessageTimeStamp = _a.oldestMessageTimeStamp, userFilledMessageListQuery = _a.userFilledMessageListQuery, replyType = _a.replyType;\n    var hasMorePrev = _b.hasMorePrev, logger = _b.logger, messagesDispatcher = _b.messagesDispatcher, sdk = _b.sdk;\n    return useCallback(function (callback) {\n        var _a, _b;\n        if (!hasMorePrev) {\n            return;\n        }\n        var messageListParams = {\n            prevResultSize: PREV_RESULT_SIZE,\n            isInclusive: true,\n            includeMetaArray: true,\n            includeReactions: (_b = (_a = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) === null || _a === void 0 ? void 0 : _a.useReaction) !== null && _b !== void 0 ? _b : false,\n        };\n        if (replyType === 'QUOTE_REPLY' || replyType === 'THREAD') {\n            messageListParams.includeThreadInfo = true;\n            messageListParams.includeParentMessageInfo = true;\n            messageListParams.replyType = ReplyType.ONLY_REPLY_TO_CHANNEL;\n        }\n        if (userFilledMessageListQuery) {\n            Object.keys(userFilledMessageListQuery).forEach(function (key) {\n                // @ts-ignore\n                messageListParams[key] = userFilledMessageListQuery[key];\n            });\n        }\n        logger.info('Channel: Fetching messages', {\n            currentGroupChannel: currentGroupChannel,\n            userFilledMessageListQuery: userFilledMessageListQuery,\n        });\n        currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.getMessagesByTimestamp(oldestMessageTimeStamp || new Date().getTime(), messageListParams).then(function (messages) {\n            messagesDispatcher({\n                type: FETCH_PREV_MESSAGES_SUCCESS,\n                payload: { currentGroupChannel: currentGroupChannel, messages: messages },\n            });\n            if (callback)\n                setTimeout(function () { return callback(); });\n        }).catch(function () {\n            messagesDispatcher({\n                type: FETCH_PREV_MESSAGES_FAILURE,\n                payload: { currentGroupChannel: currentGroupChannel },\n            });\n        });\n    }, [currentGroupChannel, oldestMessageTimeStamp, replyType]);\n}\n\nfunction useScrollDownCallback(_a, _b) {\n    var currentGroupChannel = _a.currentGroupChannel, latestMessageTimeStamp = _a.latestMessageTimeStamp, userFilledMessageListQuery = _a.userFilledMessageListQuery, hasMoreNext = _a.hasMoreNext, replyType = _a.replyType;\n    var logger = _b.logger, messagesDispatcher = _b.messagesDispatcher, sdk = _b.sdk;\n    return useCallback(function (cb) {\n        var _a, _b;\n        if (!hasMoreNext) {\n            return;\n        }\n        var isReactionEnabled = (_b = (_a = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) === null || _a === void 0 ? void 0 : _a.useReaction) !== null && _b !== void 0 ? _b : false;\n        var messageListParams = {\n            nextResultSize: NEXT_RESULT_SIZE,\n            isInclusive: true,\n            includeReactions: isReactionEnabled,\n            includeMetaArray: true,\n        };\n        if (replyType && (replyType === 'QUOTE_REPLY' || replyType === 'THREAD')) {\n            messageListParams.includeThreadInfo = true;\n            messageListParams.includeParentMessageInfo = true;\n            messageListParams.replyType = ReplyType.ONLY_REPLY_TO_CHANNEL;\n        }\n        if (userFilledMessageListQuery) {\n            Object.keys(userFilledMessageListQuery).forEach(function (key) {\n                // @ts-ignore\n                messageListParams[key] = userFilledMessageListQuery[key];\n            });\n        }\n        logger.info('Channel: Fetching later messages', { currentGroupChannel: currentGroupChannel, userFilledMessageListQuery: userFilledMessageListQuery });\n        currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.getMessagesByTimestamp(latestMessageTimeStamp || new Date().getTime(), messageListParams).then(function (messages) {\n            messagesDispatcher({\n                type: FETCH_NEXT_MESSAGES_SUCCESS,\n                payload: { currentGroupChannel: currentGroupChannel, messages: messages },\n            });\n            setTimeout(function () { return cb([messages, null]); });\n        }).catch(function (error) {\n            logger.error('Channel: Fetching later messages failed', error);\n            messagesDispatcher({\n                type: FETCH_NEXT_MESSAGES_FAILURE,\n                payload: { currentGroupChannel: currentGroupChannel },\n            });\n            setTimeout(function () { return cb([null, error]); });\n        });\n    }, [currentGroupChannel, latestMessageTimeStamp, hasMoreNext, replyType]);\n}\n\nfunction useDeleteMessageCallback(_a, _b) {\n    var currentGroupChannel = _a.currentGroupChannel, messagesDispatcher = _a.messagesDispatcher;\n    var logger = _b.logger;\n    return useCallback(function (message) {\n        logger.info('Channel | useDeleteMessageCallback: Deleting message', message);\n        var sendingStatus = isSendableMessage(message) ? message.sendingStatus : undefined;\n        return new Promise(function (resolve, reject) {\n            logger.info('Channel | useDeleteMessageCallback: Deleting message requestState:', sendingStatus);\n            // Message is only on local\n            if ((sendingStatus === SendingStatus.FAILED || sendingStatus === SendingStatus.PENDING) && 'reqId' in message) {\n                logger.info('Channel | useDeleteMessageCallback: Deleted message from local:', message);\n                messagesDispatcher({\n                    type: ON_MESSAGE_DELETED_BY_REQ_ID,\n                    payload: message.reqId,\n                });\n                resolve();\n            }\n            else {\n                logger.info('Channel | useDeleteMessageCallback: Deleting message from remote:', sendingStatus);\n                currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.deleteMessage(message).then(function () {\n                    logger.info('Channel | useDeleteMessageCallback: Deleting message success!', message);\n                    messagesDispatcher({\n                        type: ON_MESSAGE_DELETED,\n                        payload: message.messageId,\n                    });\n                    resolve();\n                }).catch(function (err) {\n                    logger.warning('Channel | useDeleteMessageCallback: Deleting message failed!', err);\n                    reject(err);\n                });\n            }\n        });\n    }, [currentGroupChannel, messagesDispatcher]);\n}\n\nfunction useUpdateMessageCallback(_a, _b) {\n    var currentGroupChannel = _a.currentGroupChannel, messagesDispatcher = _a.messagesDispatcher, onBeforeUpdateUserMessage = _a.onBeforeUpdateUserMessage, isMentionEnabled = _a.isMentionEnabled;\n    var logger = _b.logger, pubSub = _b.pubSub;\n    return useCallback(function (props, callback) {\n        var messageId = props.messageId, message = props.message, mentionedUsers = props.mentionedUsers, mentionTemplate = props.mentionTemplate;\n        var createParamsDefault = function (message) {\n            var params = {\n                message: message,\n            };\n            if (isMentionEnabled && mentionedUsers && mentionedUsers.length > 0) {\n                params.mentionedUsers = mentionedUsers;\n            }\n            if (isMentionEnabled && mentionTemplate) {\n                params.mentionedMessageTemplate = mentionTemplate;\n            }\n            else {\n                params.mentionedMessageTemplate = message;\n            }\n            return params;\n        };\n        var shouldCreateCustomParams = onBeforeUpdateUserMessage && typeof onBeforeUpdateUserMessage === 'function';\n        if (shouldCreateCustomParams) {\n            logger.info('Channel: creating params using onBeforeUpdateUserMessage', onBeforeUpdateUserMessage);\n        }\n        var params = shouldCreateCustomParams ? onBeforeUpdateUserMessage(message) : createParamsDefault(message);\n        logger.info('Channel: Updating message!', params);\n        currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.updateUserMessage(messageId, params).then(function (msg) {\n            if (callback) {\n                callback(null, msg);\n            }\n            logger.info('Channel: Updating message success!', msg);\n            messagesDispatcher({\n                type: ON_MESSAGE_UPDATED,\n                payload: {\n                    channel: currentGroupChannel,\n                    message: msg,\n                },\n            });\n            pubSub.publish(pubSubTopics.UPDATE_USER_MESSAGE, {\n                message: msg,\n                channel: currentGroupChannel,\n                publishingModules: [PublishingModuleType.CHANNEL],\n            });\n        }).catch(function (err) {\n            if (callback) {\n                callback(err, null);\n            }\n        });\n    }, [currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url, messagesDispatcher, onBeforeUpdateUserMessage]);\n}\n\nfunction useResendMessageCallback(_a, _b) {\n    var currentGroupChannel = _a.currentGroupChannel, messagesDispatcher = _a.messagesDispatcher;\n    var logger = _b.logger, pubSub = _b.pubSub;\n    return useCallback(function (failedMessage) {\n        logger.info('Channel: Resending message has started', failedMessage);\n        if (failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.isResendable) {\n            // userMessage\n            if (failedMessage.isUserMessage()) {\n                currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.resendMessage(failedMessage).onPending(function (message) {\n                    logger.info('Channel: Resending message start!', message);\n                    messagesDispatcher({\n                        type: RESEND_MESSAGE_START,\n                        payload: message,\n                    });\n                }).onSucceeded(function (message) {\n                    logger.info('Channel: Resending message success!', message);\n                    messagesDispatcher({\n                        type: SEND_MESSAGE_SUCCESS,\n                        payload: message,\n                    });\n                }).onFailed(function (e, message) {\n                    logger.warning('Channel: Resending message failed!', e);\n                    messagesDispatcher({\n                        type: SEND_MESSAGE_FAILURE,\n                        payload: message,\n                    });\n                });\n            }\n            else if (failedMessage.isFileMessage()) {\n                currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.resendMessage(failedMessage).onPending(function (message) {\n                    logger.info('Channel: Resending file message start!', message);\n                    messagesDispatcher({\n                        type: RESEND_MESSAGE_START,\n                        payload: message,\n                    });\n                }).onSucceeded(function (message) {\n                    logger.info('Channel: Resending file message success!', message);\n                    messagesDispatcher({\n                        type: SEND_MESSAGE_SUCCESS,\n                        payload: message,\n                    });\n                }).onFailed(function (e, message) {\n                    logger.warning('Channel: Resending file message failed!', e);\n                    messagesDispatcher({\n                        type: SEND_MESSAGE_FAILURE,\n                        payload: message,\n                    });\n                });\n            }\n            else if (failedMessage.isMultipleFilesMessage()) {\n                currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.resendMessage(failedMessage).onPending(function (message) {\n                    logger.info('Channel: Resending multiple files message start!', message);\n                    messagesDispatcher({\n                        type: RESEND_MESSAGE_START,\n                        payload: message,\n                    });\n                }).onFileUploaded(function (requestId, index, uploadableFileInfo, error) {\n                    var _a;\n                    logger.info('Channel: Resending multiple files message file uploaded!', {\n                        requestId: requestId,\n                        index: index,\n                        error: error,\n                        uploadableFileInfo: uploadableFileInfo,\n                    });\n                    pubSub.publish(pubSubTopics.ON_FILE_INFO_UPLOADED, {\n                        response: {\n                            channelUrl: (_a = currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) !== null && _a !== void 0 ? _a : '',\n                            requestId: requestId,\n                            index: index,\n                            uploadableFileInfo: uploadableFileInfo,\n                            error: error,\n                        },\n                        publishingModules: [PublishingModuleType.CHANNEL],\n                    });\n                }).onSucceeded(function (message) {\n                    logger.info('Channel: Resending multiple files message success!', message);\n                    messagesDispatcher({\n                        type: SEND_MESSAGE_SUCCESS,\n                        payload: message,\n                    });\n                }).onFailed(function (e, message) {\n                    logger.warning('Channel: Resending multiple files message failed!', e);\n                    messagesDispatcher({\n                        type: SEND_MESSAGE_FAILURE,\n                        payload: message,\n                    });\n                });\n            }\n        }\n        else {\n            logger.error('Message is not resendable', failedMessage);\n        }\n    }, [currentGroupChannel, messagesDispatcher]);\n}\n\nfunction useSendMessageCallback(_a, _b) {\n    var isMentionEnabled = _a.isMentionEnabled, currentGroupChannel = _a.currentGroupChannel, onBeforeSendUserMessage = _a.onBeforeSendUserMessage;\n    var logger = _b.logger, pubSub = _b.pubSub, scrollRef = _b.scrollRef, messagesDispatcher = _b.messagesDispatcher;\n    var messageInputRef = useRef(null);\n    var sendMessage = useCallback(function (_a) {\n        var quoteMessage = _a.quoteMessage, message = _a.message, mentionTemplate = _a.mentionTemplate, \n        // mentionedUserIds,\n        mentionedUsers = _a.mentionedUsers;\n        var createParamsDefault = function () {\n            var params = {\n                message: message,\n            };\n            // if (isMentionEnabled && mentionedUserIds?.length > 0) {\n            if (isMentionEnabled && mentionedUsers && mentionedUsers.length > 0) {\n                // params.mentionedUserIds = mentionedUserIds;\n                params.mentionedUsers = mentionedUsers;\n            }\n            // if (isMentionEnabled && mentionTemplate && mentionedUserIds?.length > 0) {\n            if (isMentionEnabled && mentionTemplate && mentionedUsers && mentionedUsers.length > 0) {\n                params.mentionedMessageTemplate = mentionTemplate;\n            }\n            if (quoteMessage) {\n                params.isReplyToChannel = true;\n                params.parentMessageId = quoteMessage.messageId;\n            }\n            return params;\n        };\n        var shouldCreateCustomParams = onBeforeSendUserMessage && typeof onBeforeSendUserMessage === 'function';\n        if (shouldCreateCustomParams) {\n            logger.info('Channel: creating params using onBeforeSendUserMessage', onBeforeSendUserMessage);\n        }\n        var params = shouldCreateCustomParams ? onBeforeSendUserMessage(message, quoteMessage) : createParamsDefault();\n        logger.info('Channel: Sending message has started', params);\n        currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.sendUserMessage(params).onPending(function (pendingMsg) {\n            pubSub.publish(pubSubTopics.SEND_MESSAGE_START, {\n                /* pubSub is used instead of messagesDispatcher\n                  to avoid redundantly calling `messageActionTypes.SEND_MESSAGE_START` */\n                message: pendingMsg,\n                channel: currentGroupChannel,\n                publishingModules: [PublishingModuleType.CHANNEL],\n            });\n            setTimeout(function () { return scrollIntoLast(0, scrollRef); }, SCROLL_BOTTOM_DELAY_FOR_SEND);\n        }).onFailed(function (err, msg) {\n            logger.warning('Channel: Sending message failed!', { message: msg, error: err });\n            messagesDispatcher({\n                type: SEND_MESSAGE_FAILURE,\n                payload: msg,\n            });\n        }).onSucceeded(function (msg) {\n            logger.info('Channel: Sending message success!', msg);\n            messagesDispatcher({\n                type: SEND_MESSAGE_SUCCESS,\n                payload: msg,\n            });\n        });\n    }, [currentGroupChannel, onBeforeSendUserMessage]);\n    return [messageInputRef, sendMessage];\n}\n\nfunction useSendFileMessageCallback(_a, _b) {\n    var currentGroupChannel = _a.currentGroupChannel, onBeforeSendFileMessage = _a.onBeforeSendFileMessage, imageCompression = _a.imageCompression;\n    var logger = _b.logger, pubSub = _b.pubSub, scrollRef = _b.scrollRef, messagesDispatcher = _b.messagesDispatcher;\n    var sendMessage = useCallback(function (compressedFile, quoteMessage) { return new Promise(function (resolve, reject) {\n        // Create FileMessageParams\n        var params = onBeforeSendFileMessage === null || onBeforeSendFileMessage === void 0 ? void 0 : onBeforeSendFileMessage(compressedFile, quoteMessage);\n        if (!params) {\n            params = { file: compressedFile };\n            if (quoteMessage) {\n                params.isReplyToChannel = true;\n                params.parentMessageId = quoteMessage.messageId;\n            }\n        }\n        // Send FileMessage\n        logger.info('Channel: Uploading file message start!', params);\n        currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.sendFileMessage(params).onPending(function (pendingMessage) {\n            pubSub.publish(pubSubTopics.SEND_MESSAGE_START, {\n                /* pubSub is used instead of messagesDispatcher\n                  to avoid redundantly calling `messageActionTypes.SEND_MESSAGE_START` */\n                // TODO: remove data pollution\n                message: __assign(__assign({}, pendingMessage), { url: URL.createObjectURL(compressedFile), \n                    // pending thumbnail message seems to be failed\n                    requestState: 'pending', isUserMessage: pendingMessage.isUserMessage, isFileMessage: pendingMessage.isFileMessage, isAdminMessage: pendingMessage.isAdminMessage, isMultipleFilesMessage: pendingMessage.isMultipleFilesMessage }),\n                channel: currentGroupChannel,\n                publishingModules: [PublishingModuleType.CHANNEL],\n            });\n            setTimeout(function () { return scrollIntoLast(0, scrollRef); }, SCROLL_BOTTOM_DELAY_FOR_SEND);\n        }).onFailed(function (err, failedMessage) {\n            logger.error('Channel: Sending file message failed!', { failedMessage: failedMessage, err: err });\n            // TODO: v4 - remove logic that modifies the original object.\n            //  It makes the code difficult to track, likely causing unpredictable side effects.\n            // @ts-ignore eslint-disable-next-line no-param-reassign\n            failedMessage.localUrl = URL.createObjectURL(compressedFile);\n            // @ts-ignore eslint-disable-next-line no-param-reassign\n            failedMessage.file = compressedFile;\n            messagesDispatcher({\n                type: SEND_MESSAGE_FAILURE,\n                payload: failedMessage,\n            });\n            reject(err);\n        }).onSucceeded(function (succeededMessage) {\n            logger.info('Channel: Sending file message success!', succeededMessage);\n            messagesDispatcher({\n                type: SEND_MESSAGE_SUCCESS,\n                payload: succeededMessage,\n            });\n            resolve(succeededMessage);\n        });\n    }); }, [currentGroupChannel, onBeforeSendFileMessage, imageCompression]);\n    return [sendMessage];\n}\n\n// To prevent multiple clicks on the message in the channel while scrolling\nfunction deactivateClick(scrollRef) {\n    var element = scrollRef.current;\n    var parentNode = element === null || element === void 0 ? void 0 : element.parentNode;\n    if (element && parentNode) {\n        element.style.pointerEvents = 'none';\n        parentNode.style.cursor = 'wait';\n    }\n}\nfunction activateClick(scrollRef) {\n    var element = scrollRef.current;\n    var parentNode = element === null || element === void 0 ? void 0 : element.parentNode;\n    if (element && parentNode) {\n        element.style.pointerEvents = 'auto';\n        parentNode.style.cursor = 'auto';\n    }\n}\nfunction useScrollToMessage(_a, _b) {\n    var setInitialTimeStamp = _a.setInitialTimeStamp, setAnimatedMessageId = _a.setAnimatedMessageId, allMessages = _a.allMessages, scrollRef = _a.scrollRef;\n    var logger = _b.logger;\n    return useCallback(function (createdAt, messageId) {\n        var isPresent = allMessages.find(function (m) { return (m.messageId === messageId); });\n        setAnimatedMessageId(null);\n        setTimeout(function () {\n            try {\n                logger.info('Channel: scroll to message - disabling mouse events');\n                deactivateClick(scrollRef);\n                if (isPresent) {\n                    logger.info('Channel: scroll to message - message is present');\n                    setAnimatedMessageId(messageId);\n                    scrollToRenderedMessage(scrollRef, createdAt);\n                }\n                else {\n                    logger.info('Channel: scroll to message - fetching older messages');\n                    setInitialTimeStamp(null);\n                    setInitialTimeStamp(createdAt);\n                    setAnimatedMessageId(messageId);\n                }\n            }\n            finally {\n                logger.info('Channel: scroll to message - enabled mouse events');\n                activateClick(scrollRef);\n            }\n        });\n    }, [\n        setInitialTimeStamp,\n        setAnimatedMessageId,\n        allMessages,\n    ]);\n}\n\nvar useSendVoiceMessageCallback = function (_a, _b) {\n    var currentGroupChannel = _a.currentGroupChannel, onBeforeSendVoiceMessage = _a.onBeforeSendVoiceMessage;\n    var logger = _b.logger, pubSub = _b.pubSub, scrollRef = _b.scrollRef, messagesDispatcher = _b.messagesDispatcher;\n    var sendMessage = useCallback(function (file, duration, quoteMessage) { return new Promise(function (resolve, reject) {\n        if (!currentGroupChannel) {\n            return;\n        }\n        var messageParams = (onBeforeSendVoiceMessage && typeof onBeforeSendVoiceMessage === 'function')\n            ? onBeforeSendVoiceMessage(file, quoteMessage)\n            : {\n                file: file,\n                fileName: VOICE_MESSAGE_FILE_NAME,\n                mimeType: VOICE_MESSAGE_MIME_TYPE,\n                metaArrays: [\n                    new MessageMetaArray({\n                        key: META_ARRAY_VOICE_DURATION_KEY,\n                        value: [\"\".concat(duration)],\n                    }),\n                    new MessageMetaArray({\n                        key: META_ARRAY_MESSAGE_TYPE_KEY,\n                        value: [META_ARRAY_MESSAGE_TYPE_VALUE__VOICE],\n                    }),\n                ],\n            };\n        if (quoteMessage) {\n            messageParams.isReplyToChannel = true;\n            messageParams.parentMessageId = quoteMessage.messageId;\n        }\n        logger.info('Channel: Start sending voice message', messageParams);\n        currentGroupChannel.sendFileMessage(messageParams)\n            .onPending(function (pendingMessage) {\n            pubSub.publish(pubSubTopics.SEND_MESSAGE_START, {\n                /* pubSub is used instead of messagesDispatcher\n                  to avoid redundantly calling `messageActionTypes.SEND_MESSAGE_START` */\n                message: pendingMessage,\n                channel: currentGroupChannel,\n                publishingModules: [PublishingModuleType.CHANNEL],\n            });\n            setTimeout(function () { return scrollIntoLast(0, scrollRef); }, SCROLL_BOTTOM_DELAY_FOR_SEND);\n        })\n            .onFailed(function (err, failedMessage) {\n            logger.error('Channel: Sending voice message failed!', { failedMessage: failedMessage, err: err });\n            messagesDispatcher({\n                type: SEND_MESSAGE_FAILURE,\n                payload: failedMessage,\n            });\n            reject(err);\n        })\n            .onSucceeded(function (succeededMessage) {\n            logger.info('Channel: Sending voice message success!', succeededMessage);\n            messagesDispatcher({\n                type: SEND_MESSAGE_SUCCESS,\n                payload: succeededMessage,\n            });\n            resolve(succeededMessage);\n        });\n    }); }, [\n        currentGroupChannel,\n        onBeforeSendVoiceMessage,\n    ]);\n    return [sendMessage];\n};\n\nvar useHandleChannelPubsubEvents = function (_a) {\n    var channelUrl = _a.channelUrl, sdkInit = _a.sdkInit, pubSub = _a.pubSub, dispatcher = _a.dispatcher, scrollRef = _a.scrollRef;\n    useEffect(function () {\n        var subscriber = new Map();\n        if (pubSub === null || pubSub === void 0 ? void 0 : pubSub.subscribe) {\n            subscriber.set(PUBSUB_TOPICS.SEND_USER_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.SEND_USER_MESSAGE, function (props) {\n                var channel = props.channel, message = props.message;\n                if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n                    dispatcher({\n                        type: SEND_MESSAGE_SUCCESS,\n                        payload: message,\n                    });\n                    setTimeout(function () { return scrollIntoLast(0, scrollRef); }, SCROLL_BOTTOM_DELAY_FOR_SEND);\n                }\n            }));\n            subscriber.set(PUBSUB_TOPICS.SEND_MESSAGE_START, pubSub.subscribe(PUBSUB_TOPICS.SEND_MESSAGE_START, function (props) {\n                var channel = props.channel, message = props.message, publishingModules = props.publishingModules;\n                if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url) && shouldPubSubPublishToChannel(publishingModules)) {\n                    dispatcher({\n                        type: SEND_MESSAGE_START,\n                        payload: message,\n                    });\n                }\n            }));\n            subscriber.set(PUBSUB_TOPICS.ON_FILE_INFO_UPLOADED, pubSub.subscribe(PUBSUB_TOPICS.ON_FILE_INFO_UPLOADED, function (props) {\n                var response = props.response, publishingModules = props.publishingModules;\n                if (channelUrl === response.channelUrl && shouldPubSubPublishToChannel(publishingModules)) {\n                    dispatcher({\n                        type: ON_FILE_INFO_UPLOADED,\n                        payload: response,\n                    });\n                }\n            }));\n            subscriber.set(PUBSUB_TOPICS.SEND_MESSAGE_FAILED, pubSub.subscribe(PUBSUB_TOPICS.SEND_MESSAGE_FAILED, function (props) {\n                var channel = props.channel, message = props.message, publishingModules = props.publishingModules;\n                if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url) && shouldPubSubPublishToChannel(publishingModules)) {\n                    dispatcher({\n                        type: SEND_MESSAGE_FAILURE,\n                        payload: message,\n                    });\n                }\n            }));\n            subscriber.set(PUBSUB_TOPICS.SEND_FILE_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.SEND_FILE_MESSAGE, function (props) {\n                var channel = props.channel, message = props.message;\n                if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n                    dispatcher({\n                        type: SEND_MESSAGE_SUCCESS,\n                        payload: message,\n                    });\n                    setTimeout(function () { return scrollIntoLast(0, scrollRef); }, SCROLL_BOTTOM_DELAY_FOR_SEND);\n                }\n            }));\n            subscriber.set(PUBSUB_TOPICS.UPDATE_USER_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.UPDATE_USER_MESSAGE, function (props) {\n                var channel = props.channel, message = props.message, fromSelector = props.fromSelector;\n                if (fromSelector && (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) && channel.isGroupChannel()) {\n                    dispatcher({\n                        type: ON_MESSAGE_UPDATED,\n                        payload: { channel: channel, message: message },\n                    });\n                }\n            }));\n            subscriber.set(PUBSUB_TOPICS.DELETE_MESSAGE, pubSub.subscribe(PUBSUB_TOPICS.DELETE_MESSAGE, function (props) {\n                var channel = props.channel, messageId = props.messageId;\n                if (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n                    dispatcher({\n                        type: ON_MESSAGE_DELETED,\n                        payload: messageId,\n                    });\n                }\n            }));\n        }\n        return function () {\n            subscriber.forEach(function (s) {\n                try {\n                    s.remove();\n                }\n                catch (_a) {\n                    //\n                }\n            });\n        };\n    }, [\n        channelUrl,\n        sdkInit,\n    ]);\n};\n\nvar ChannelContext = React__default.createContext(null);\n/**\n * @deprecated This provider is deprecated and will be removed in the next major update.\n * Please use the `GroupChannelProvider` from '@sendbird/uikit-react/GroupChannel' instead.\n * For more information, please refer to the migration guide:\n * https://docs.sendbird.com/docs/chat/uikit/v3/react/introduction/group-channel-migration-guide\n */\nvar ChannelProvider = function (props) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    var channelUrl = props.channelUrl, children = props.children, isReactionEnabled = props.isReactionEnabled, _h = props.isMessageGroupingEnabled, isMessageGroupingEnabled = _h === void 0 ? true : _h, isMultipleFilesMessageEnabled = props.isMultipleFilesMessageEnabled, showSearchIcon = props.showSearchIcon, animatedMessage = props.animatedMessage, highlightedMessage = props.highlightedMessage, startingPoint = props.startingPoint, onBeforeSendUserMessage = props.onBeforeSendUserMessage, onBeforeSendFileMessage = props.onBeforeSendFileMessage, onBeforeUpdateUserMessage = props.onBeforeUpdateUserMessage, onBeforeSendVoiceMessage = props.onBeforeSendVoiceMessage, onBeforeSendMultipleFilesMessage = props.onBeforeSendMultipleFilesMessage, onChatHeaderActionClick = props.onChatHeaderActionClick, onSearchClick = props.onSearchClick, onBackClick = props.onBackClick, threadReplySelectType = props.threadReplySelectType, queries = props.queries, filterMessageList = props.filterMessageList, _j = props.disableMarkAsRead, disableMarkAsRead = _j === void 0 ? false : _j, onReplyInThread = props.onReplyInThread, onQuoteMessageClick = props.onQuoteMessageClick, onMessageAnimated = props.onMessageAnimated, onMessageHighlighted = props.onMessageHighlighted, _k = props.scrollBehavior, scrollBehavior = _k === void 0 ? 'auto' : _k, _l = props.reconnectOnIdle, reconnectOnIdle = _l === void 0 ? true : _l;\n    var globalStore = useSendbirdStateContext();\n    var config = globalStore.config;\n    var replyType = (_a = props.replyType) !== null && _a !== void 0 ? _a : getCaseResolvedReplyType(config.groupChannel.replyType).upperCase;\n    var pubSub = config.pubSub, logger = config.logger, userId = config.userId, isOnline = config.isOnline, imageCompression = config.imageCompression, onUserProfileMessage = config.onUserProfileMessage, markAsReadScheduler = config.markAsReadScheduler, groupChannel = config.groupChannel;\n    var sdk = (_c = (_b = globalStore === null || globalStore === void 0 ? void 0 : globalStore.stores) === null || _b === void 0 ? void 0 : _b.sdkStore) === null || _c === void 0 ? void 0 : _c.sdk;\n    var sdkInit = (_e = (_d = globalStore === null || globalStore === void 0 ? void 0 : globalStore.stores) === null || _d === void 0 ? void 0 : _d.sdkStore) === null || _e === void 0 ? void 0 : _e.initialized;\n    var globalConfigs = globalStore === null || globalStore === void 0 ? void 0 : globalStore.config;\n    var _m = useState(startingPoint), initialTimeStamp = _m[0], setInitialTimeStamp = _m[1];\n    useEffect(function () {\n        setInitialTimeStamp(startingPoint);\n    }, [startingPoint, channelUrl]);\n    var _o = useState(null), animatedMessageId = _o[0], setAnimatedMessageId = _o[1];\n    var _p = useState(highlightedMessage), highLightedMessageId = _p[0], setHighLightedMessageId = _p[1];\n    useEffect(function () {\n        setHighLightedMessageId(highlightedMessage);\n    }, [highlightedMessage]);\n    var userFilledMessageListQuery = queries === null || queries === void 0 ? void 0 : queries.messageListParams;\n    var _q = useState(null), quoteMessage = _q[0], setQuoteMessage = _q[1];\n    var _r = useState(false), isScrolled = _r[0], setIsScrolled = _r[1];\n    var _s = useReducer(channelReducer, initialState), messagesStore = _s[0], messagesDispatcher = _s[1];\n    var scrollRef = useRef(null);\n    var isMentionEnabled = groupChannel.enableMention;\n    var allMessages = messagesStore.allMessages, localMessages = messagesStore.localMessages, loading = messagesStore.loading, initialized = messagesStore.initialized, unreadSince = messagesStore.unreadSince, unreadSinceDate = messagesStore.unreadSinceDate, isInvalid = messagesStore.isInvalid, currentGroupChannel = messagesStore.currentGroupChannel, hasMorePrev = messagesStore.hasMorePrev, oldestMessageTimeStamp = messagesStore.oldestMessageTimeStamp, hasMoreNext = messagesStore.hasMoreNext, latestMessageTimeStamp = messagesStore.latestMessageTimeStamp, emojiContainer = messagesStore.emojiContainer, readStatus = messagesStore.readStatus, typingMembers = messagesStore.typingMembers;\n    var usingReaction = getIsReactionEnabled({\n        channel: currentGroupChannel,\n        config: config,\n        moduleLevel: isReactionEnabled,\n    });\n    var emojiAllMap = useMemo(function () { return (usingReaction\n        ? getAllEmojisMapFromEmojiContainer(emojiContainer)\n        : new Map()); }, [emojiContainer]);\n    var nicknamesMap = useMemo(function () { return ((usingReaction && currentGroupChannel)\n        ? getNicknamesMapFromMembers(currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.members)\n        : new Map()); }, [currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.members]);\n    // Animate message\n    useEffect(function () {\n        if (animatedMessage) {\n            setAnimatedMessageId(animatedMessage);\n        }\n    }, [animatedMessage]);\n    // Scrollup is default scroll for channel\n    var onScrollCallback = useScrollCallback({\n        currentGroupChannel: currentGroupChannel,\n        oldestMessageTimeStamp: oldestMessageTimeStamp,\n        userFilledMessageListQuery: userFilledMessageListQuery,\n        replyType: replyType,\n    }, {\n        hasMorePrev: hasMorePrev,\n        logger: logger,\n        messagesDispatcher: messagesDispatcher,\n        sdk: sdk,\n    });\n    var scrollToMessage = useScrollToMessage({\n        setInitialTimeStamp: setInitialTimeStamp,\n        setAnimatedMessageId: setAnimatedMessageId,\n        allMessages: allMessages,\n        scrollRef: scrollRef,\n    }, { logger: logger });\n    // onScrollDownCallback is added for navigation to different timestamps on messageSearch\n    // hasMorePrev, onScrollCallback -> scroll up(default behavior)\n    // hasMoreNext, onScrollDownCallback -> scroll down\n    var onScrollDownCallback = useScrollDownCallback({\n        currentGroupChannel: currentGroupChannel,\n        latestMessageTimeStamp: latestMessageTimeStamp,\n        userFilledMessageListQuery: userFilledMessageListQuery,\n        hasMoreNext: hasMoreNext,\n        replyType: replyType,\n    }, {\n        logger: logger,\n        messagesDispatcher: messagesDispatcher,\n        sdk: sdk,\n    });\n    var toggleReaction = useToggleReactionCallback(currentGroupChannel, logger);\n    // to create message-datasource\n    // this hook sets currentGroupChannel asynchronously\n    useGetChannel({ channelUrl: channelUrl, sdkInit: sdkInit, disableMarkAsRead: disableMarkAsRead }, { messagesDispatcher: messagesDispatcher, sdk: sdk, logger: logger, markAsReadScheduler: markAsReadScheduler });\n    // to set quote message as null\n    useEffect(function () {\n        setQuoteMessage(null);\n    }, [channelUrl]);\n    // Hook to handle ChannelEvents and send values to useReducer using messagesDispatcher\n    useHandleChannelEvents({\n        currentGroupChannel: currentGroupChannel,\n        sdkInit: sdkInit,\n        currentUserId: userId,\n        disableMarkAsRead: disableMarkAsRead,\n    }, {\n        messagesDispatcher: messagesDispatcher,\n        sdk: sdk,\n        logger: logger,\n        scrollRef: scrollRef,\n        setQuoteMessage: setQuoteMessage,\n    });\n    // hook that fetches messages when channel changes\n    // to be clear here useGetChannel sets currentGroupChannel\n    // and useInitialMessagesFetch executes when currentGroupChannel changes\n    // p.s This one executes on initialTimeStamp change too\n    useInitialMessagesFetch({\n        currentGroupChannel: currentGroupChannel,\n        userFilledMessageListQuery: userFilledMessageListQuery,\n        initialTimeStamp: initialTimeStamp,\n        replyType: replyType,\n        setIsScrolled: setIsScrolled,\n    }, {\n        logger: logger,\n        scrollRef: scrollRef,\n        messagesDispatcher: messagesDispatcher,\n    });\n    // handles API calls from withSendbird\n    useHandleChannelPubsubEvents({\n        channelUrl: channelUrl,\n        sdkInit: sdkInit,\n        pubSub: pubSub,\n        dispatcher: messagesDispatcher,\n        scrollRef: scrollRef,\n    });\n    // handling connection breaks\n    useHandleReconnect({ isOnline: isOnline, replyType: replyType, disableMarkAsRead: disableMarkAsRead, reconnectOnIdle: reconnectOnIdle }, {\n        logger: logger,\n        sdk: sdk,\n        scrollRef: scrollRef,\n        currentGroupChannel: currentGroupChannel,\n        messagesDispatcher: messagesDispatcher,\n        userFilledMessageListQuery: userFilledMessageListQuery,\n        markAsReadScheduler: markAsReadScheduler,\n    });\n    // callbacks for Message CURD actions\n    var deleteMessage = useDeleteMessageCallback({ currentGroupChannel: currentGroupChannel, messagesDispatcher: messagesDispatcher }, { logger: logger });\n    var updateMessage = useUpdateMessageCallback({ currentGroupChannel: currentGroupChannel, messagesDispatcher: messagesDispatcher, onBeforeUpdateUserMessage: onBeforeUpdateUserMessage, isMentionEnabled: isMentionEnabled }, { logger: logger, pubSub: pubSub });\n    var resendMessage = useResendMessageCallback({ currentGroupChannel: currentGroupChannel, messagesDispatcher: messagesDispatcher }, { logger: logger, pubSub: pubSub });\n    var _t = useSendMessageCallback({\n        currentGroupChannel: currentGroupChannel,\n        isMentionEnabled: isMentionEnabled,\n        onBeforeSendUserMessage: onBeforeSendUserMessage,\n    }, {\n        logger: logger,\n        pubSub: pubSub,\n        scrollRef: scrollRef,\n        messagesDispatcher: messagesDispatcher,\n    }), messageInputRef = _t[0], sendMessage = _t[1];\n    var sendFileMessage = useSendFileMessageCallback({\n        currentGroupChannel: currentGroupChannel,\n        imageCompression: imageCompression,\n        onBeforeSendFileMessage: onBeforeSendFileMessage,\n    }, {\n        logger: logger,\n        pubSub: pubSub,\n        scrollRef: scrollRef,\n        messagesDispatcher: messagesDispatcher,\n    })[0];\n    var sendVoiceMessage = useSendVoiceMessageCallback({\n        currentGroupChannel: currentGroupChannel,\n        onBeforeSendVoiceMessage: onBeforeSendVoiceMessage,\n    }, {\n        logger: logger,\n        pubSub: pubSub,\n        scrollRef: scrollRef,\n        messagesDispatcher: messagesDispatcher,\n    })[0];\n    var sendMultipleFilesMessage = useSendMultipleFilesMessage({\n        currentChannel: currentGroupChannel,\n        onBeforeSendMultipleFilesMessage: onBeforeSendMultipleFilesMessage,\n        publishingModules: [PublishingModuleType.CHANNEL],\n    }, {\n        logger: logger,\n        pubSub: pubSub,\n        scrollRef: scrollRef,\n    })[0];\n    return (React__default.createElement(ChannelContext.Provider, { value: {\n            // props\n            channelUrl: channelUrl,\n            isReactionEnabled: usingReaction,\n            isMessageGroupingEnabled: isMessageGroupingEnabled,\n            isMultipleFilesMessageEnabled: isMultipleFilesMessageEnabled,\n            showSearchIcon: showSearchIcon !== null && showSearchIcon !== void 0 ? showSearchIcon : globalConfigs.groupChannelSettings.enableMessageSearch,\n            highlightedMessage: highlightedMessage,\n            startingPoint: startingPoint,\n            onBeforeSendUserMessage: onBeforeSendUserMessage,\n            onBeforeSendFileMessage: onBeforeSendFileMessage,\n            onBeforeUpdateUserMessage: onBeforeUpdateUserMessage,\n            onChatHeaderActionClick: onChatHeaderActionClick,\n            onSearchClick: onSearchClick,\n            onBackClick: onBackClick,\n            replyType: replyType,\n            threadReplySelectType: (_f = threadReplySelectType !== null && threadReplySelectType !== void 0 ? threadReplySelectType : getCaseResolvedThreadReplySelectType(groupChannel.threadReplySelectType).upperCase) !== null && _f !== void 0 ? _f : ThreadReplySelectType.THREAD,\n            queries: queries,\n            filterMessageList: filterMessageList,\n            disableMarkAsRead: disableMarkAsRead,\n            onReplyInThread: onReplyInThread,\n            onQuoteMessageClick: onQuoteMessageClick,\n            onMessageAnimated: onMessageAnimated,\n            onMessageHighlighted: onMessageHighlighted,\n            // messagesStore\n            allMessages: allMessages,\n            localMessages: localMessages,\n            loading: loading,\n            initialized: initialized,\n            unreadSince: unreadSince,\n            unreadSinceDate: unreadSinceDate,\n            isInvalid: isInvalid,\n            currentGroupChannel: currentGroupChannel,\n            hasMorePrev: hasMorePrev,\n            hasMoreNext: hasMoreNext,\n            oldestMessageTimeStamp: oldestMessageTimeStamp,\n            latestMessageTimeStamp: latestMessageTimeStamp,\n            emojiContainer: emojiContainer,\n            readStatus: readStatus,\n            typingMembers: typingMembers,\n            // utils\n            scrollToMessage: scrollToMessage,\n            quoteMessage: quoteMessage,\n            setQuoteMessage: setQuoteMessage,\n            deleteMessage: deleteMessage,\n            updateMessage: updateMessage,\n            resendMessage: resendMessage,\n            messageInputRef: messageInputRef,\n            sendMessage: sendMessage,\n            sendFileMessage: sendFileMessage,\n            sendVoiceMessage: sendVoiceMessage,\n            sendMultipleFilesMessage: sendMultipleFilesMessage,\n            initialTimeStamp: initialTimeStamp,\n            messageActionTypes: channelActions,\n            messagesDispatcher: messagesDispatcher,\n            setInitialTimeStamp: setInitialTimeStamp,\n            setAnimatedMessageId: setAnimatedMessageId,\n            setHighLightedMessageId: setHighLightedMessageId,\n            animatedMessageId: animatedMessageId,\n            highLightedMessageId: highLightedMessageId,\n            nicknamesMap: nicknamesMap,\n            emojiAllMap: emojiAllMap,\n            onScrollCallback: onScrollCallback,\n            onScrollDownCallback: onScrollDownCallback,\n            scrollRef: scrollRef,\n            scrollBehavior: scrollBehavior,\n            toggleReaction: toggleReaction,\n            isScrolled: isScrolled,\n            setIsScrolled: setIsScrolled,\n        } },\n        React__default.createElement(UserProfileProvider, { disableUserProfile: (_g = props === null || props === void 0 ? void 0 : props.disableUserProfile) !== null && _g !== void 0 ? _g : !config.common.enableUsingDefaultUserProfile, renderUserProfile: props === null || props === void 0 ? void 0 : props.renderUserProfile, onUserProfileMessage: onUserProfileMessage }, children)));\n};\nvar useChannelContext = function () {\n    var context = React__default.useContext(ChannelContext);\n    if (!context)\n        throw new Error('ChannelContext not found. Use within the Channel module.');\n    return context;\n};\n\nexport { ChannelProvider, useChannelContext };\n//# sourceMappingURL=context.js.map\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module"}