{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { useEffect, useLayoutEffect, useRef } from 'react';\nimport { CollectionEventSource } from '@sendbird/chat';\nimport { MessageCollectionInitPolicy, MessageFilter } from '@sendbird/chat/groupChannel';\nimport { sbuConstants } from '../../constants/sbuConstants.js';\nimport { isDifferentChannel } from '../../utils/channel.js';\nimport { isMyMessage, isSendableMessage } from '../../utils/message.js';\nimport { isNotEmptyArray } from '../../utils/validators.js';\nimport { useForceUpdate } from '../useForceUpdate.js';\nimport { useGroupChannelHandler } from '../useGroupChannelHandler.js';\nimport { usePreservedCallback } from '../usePreservedCallback.js';\nimport { useChannelMessagesReducer } from './reducer.js';\nconst createMessageCollection = (channel, limit, options) => {\n  var _a;\n  const basicParams = {\n    prevResultLimit: limit.prev,\n    nextResultLimit: limit.next,\n    startingPoint: options === null || options === void 0 ? void 0 : options.startingPoint,\n    replyType: options === null || options === void 0 ? void 0 : options.replyType\n  };\n  const passedCollection = (_a = options === null || options === void 0 ? void 0 : options.collectionCreator) === null || _a === void 0 ? void 0 : _a.call(options, basicParams);\n  if (passedCollection) return passedCollection;\n  return channel.createMessageCollection(Object.assign(Object.assign({}, basicParams), {\n    filter: new MessageFilter(basicParams)\n  }));\n};\n// NOTE: In React-Native's FlatList, the bidirectional message loading doesn't work reliably, causing a bug\n//  where scrolling jumps to a random position when loading a large number of messages at once.\n//  Therefore, in the message search that explores past messages, a small number of messages is loaded to address this issue.\nfunction getCollectionLimitBy(startingPoint) {\n  return startingPoint < Date.now() ? sbuConstants.collection.message.searchLimit : sbuConstants.collection.message.defaultLimit;\n}\n/**\n * group channel messages hook\n * - Receive new messages from other users & should count new messages -> append to state(newMessages)\n * - onTopReached -> prev() -> fetch prev messages and append to state(messages)\n * - onBottomReached -> next() -> fetch next messages and append to state(messages)\n * */\nexport const useGroupChannelMessages = function (sdk, channel) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a, _b, _c;\n  const internalOptions = useRef(options); // to keep reference of options in event handler\n  internalOptions.current = options;\n  const channelRef = useRef(channel); // to keep reference of channel in event handler\n  channelRef.current = channel;\n  const logger = internalOptions.current.logger;\n  const initialStartingPoint = (_a = internalOptions.current.startingPoint) !== null && _a !== void 0 ? _a : Number.MAX_SAFE_INTEGER;\n  const initialLimit = getCollectionLimitBy(initialStartingPoint);\n  const isFetching = useRef({\n    prev: false,\n    next: false\n  });\n  const forceUpdate = useForceUpdate();\n  const collectionRef = useRef({\n    initialized: false,\n    apiInitialized: false,\n    instance: null\n  });\n  const {\n    initialized,\n    loading,\n    refreshing,\n    messages,\n    newMessages,\n    updateMessages,\n    updateNewMessages,\n    deleteNewMessages,\n    deleteMessages,\n    updateInitialized,\n    updateLoading,\n    updateRefreshing\n  } = useChannelMessagesReducer(options === null || options === void 0 ? void 0 : options.sortComparator);\n  const markAsReadBySource = usePreservedCallback(source => {\n    var _a, _b, _c, _d;\n    if (!channelRef.current || !channelRef.current.url) return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n    try {\n      switch (source) {\n        case CollectionEventSource.EVENT_MESSAGE_RECEIVED:\n        case CollectionEventSource.EVENT_MESSAGE_SENT_SUCCESS:\n        case CollectionEventSource.SYNC_MESSAGE_FILL:\n        case undefined:\n          (_c = (_b = internalOptions.current).markAsRead) === null || _c === void 0 ? void 0 : _c.call(_b, [channelRef.current]);\n          break;\n      }\n    } catch (e) {\n      (_d = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _d === void 0 ? void 0 : _d.call(logger, '[useGroupChannelMessages/markAsReadBySource]', e);\n    }\n  });\n  const updateNewMessagesReceived = usePreservedCallback((source, messages) => {\n    var _a, _b, _c, _d, _e;\n    const incomingMessages = messages.filter(it => {\n      var _a;\n      return !isMyMessage(it, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n    });\n    if (incomingMessages.length > 0) {\n      switch (source) {\n        case CollectionEventSource.EVENT_MESSAGE_RECEIVED:\n        case CollectionEventSource.SYNC_MESSAGE_FILL:\n          {\n            if ((_b = (_a = internalOptions.current).shouldCountNewMessages) === null || _b === void 0 ? void 0 : _b.call(_a)) {\n              updateNewMessages(incomingMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n            }\n            (_e = (_d = internalOptions.current).onMessagesReceived) === null || _e === void 0 ? void 0 : _e.call(_d, incomingMessages);\n            break;\n          }\n      }\n    }\n  });\n  const init = usePreservedCallback((startingPoint, limit) => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise(resolve => {\n      var _a, _b;\n      if (!channelRef.current || !channelRef.current.url) return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n      if (collectionRef.current.instance) collectionRef.current.instance.dispose();\n      markAsReadBySource();\n      updateNewMessages([], true, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId);\n      const updateUnsentMessages = () => {\n        var _a, _b, _c;\n        const {\n          pendingMessages,\n          failedMessages\n        } = (_a = collectionRef.current.instance) !== null && _a !== void 0 ? _a : {};\n        if (isNotEmptyArray(pendingMessages)) updateMessages(pendingMessages, false, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId);\n        if (isNotEmptyArray(failedMessages)) updateMessages(failedMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n      };\n      const collectionInstance = createMessageCollection(channelRef.current, limit, Object.assign(Object.assign({}, internalOptions.current), {\n        startingPoint\n      }));\n      collectionRef.current = {\n        apiInitialized: false,\n        initialized: false,\n        instance: collectionInstance\n      };\n      collectionInstance.setMessageCollectionHandler({\n        onMessagesAdded: (ctx, __, messages) => {\n          var _a;\n          markAsReadBySource(ctx.source);\n          updateNewMessagesReceived(ctx.source, messages);\n          updateMessages(messages, false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        },\n        onMessagesUpdated: (ctx, __, messages) => {\n          var _a, _b, _c;\n          markAsReadBySource(ctx.source);\n          updateNewMessagesReceived(ctx.source, messages); // NOTE: admin message is not added via onMessagesAdded handler, not checked yet is this a bug.\n          updateMessages(messages, false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n          if (ctx.source === CollectionEventSource.EVENT_MESSAGE_UPDATED) {\n            (_c = (_b = internalOptions.current).onMessagesUpdated) === null || _c === void 0 ? void 0 : _c.call(_b, messages);\n          }\n        },\n        onMessagesDeleted: (_, __, ___, messages) => {\n          const msgIds = messages.map(it => it.messageId);\n          const reqIds = messages.filter(isSendableMessage).map(it => it.reqId);\n          deleteMessages(msgIds, reqIds);\n          deleteNewMessages(msgIds, reqIds);\n        },\n        onChannelDeleted: (_, channelUrl) => {\n          var _a, _b;\n          (_b = (_a = internalOptions.current).onChannelDeleted) === null || _b === void 0 ? void 0 : _b.call(_a, channelUrl);\n        },\n        onChannelUpdated: (_, channel) => {\n          var _a, _b;\n          forceUpdate();\n          (_b = (_a = internalOptions.current).onChannelUpdated) === null || _b === void 0 ? void 0 : _b.call(_a, channel);\n        },\n        onHugeGapDetected: () => {\n          init(Number.MAX_SAFE_INTEGER, sbuConstants.collection.message.defaultLimit);\n        }\n      });\n      collectionInstance.initialize(MessageCollectionInitPolicy.CACHE_AND_REPLACE_BY_API).onCacheResult((err, messages) => {\n        var _a, _b, _c;\n        if (err) sdk.isCacheEnabled && ((_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages/onCacheResult]', err));else if (messages) {\n          (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelMessages/onCacheResult]', 'message length:', messages.length);\n          updateMessages(messages, true, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n          updateUnsentMessages();\n          // Note: If there are messages exchanged in the channel but no cached messages have been saved yet,\n          //  to prevent the API-retrieved messages from appearing immediately after the 'no messages' UI is displayed,\n          //  resolve only when there are messages present in the cache\n          if (messages.length > 0) {\n            collectionRef.current.initialized = true;\n            resolve();\n          }\n        }\n      }).onApiResult((err, messages) => {\n        var _a, _b, _c, _d, _e;\n        if (err) (_a = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages/onApiResult]', err);else if (messages) {\n          (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelMessages/onApiResult]', 'message length:', messages.length);\n          updateMessages(messages, true, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n          if (!internalOptions.current.startingPoint) (_e = (_d = internalOptions.current).onMessagesReceived) === null || _e === void 0 ? void 0 : _e.call(_d, messages);\n          if (sdk.isCacheEnabled) updateUnsentMessages();\n        }\n        collectionRef.current.initialized = true;\n        collectionRef.current.apiInitialized = true;\n        resolve();\n      });\n    });\n  }));\n  useGroupChannelHandler(sdk, {\n    onUserBanned(eventChannel, bannedUser) {\n      var _a, _b, _c;\n      if (eventChannel.isGroupChannel() && !isDifferentChannel(eventChannel, channelRef.current)) {\n        if (bannedUser.userId === ((_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId)) {\n          (_c = (_b = internalOptions.current).onCurrentUserBanned) === null || _c === void 0 ? void 0 : _c.call(_b);\n        } else {\n          forceUpdate();\n        }\n      }\n    }\n  });\n  useLayoutEffect(() => {\n    const timeout = setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {\n      if (sdk.currentUser && channelRef.current) {\n        updateInitialized(false);\n        updateLoading(true);\n        yield init(initialStartingPoint, initialLimit);\n        updateLoading(false);\n        updateInitialized(true);\n      }\n    }));\n    return () => clearTimeout(timeout);\n  }, [sdk, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId, (_c = channelRef.current) === null || _c === void 0 ? void 0 : _c.url, internalOptions.current.replyType]);\n  useEffect(() => {\n    return () => {\n      if (collectionRef.current.instance) collectionRef.current.instance.dispose();\n    };\n  }, []);\n  const refresh = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n    if (sdk.currentUser && channelRef.current) {\n      updateRefreshing(true);\n      yield init(Number.MAX_SAFE_INTEGER, sbuConstants.collection.message.defaultLimit);\n      updateRefreshing(false);\n    }\n  }));\n  const loadPrevious = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n    var _d;\n    const collection = collectionRef.current.instance;\n    if ((collection === null || collection === void 0 ? void 0 : collection.hasPrevious) && !isFetching.current.prev) {\n      try {\n        isFetching.current.prev = true;\n        const list = yield collection.loadPrevious();\n        updateMessages(list, false, (_d = sdk.currentUser) === null || _d === void 0 ? void 0 : _d.userId);\n      } catch (_e) {\n        // noop\n      } finally {\n        isFetching.current.prev = false;\n      }\n    }\n  }));\n  const hasPrevious = usePreservedCallback(() => {\n    const {\n      initialized,\n      instance\n    } = collectionRef.current;\n    if (initialized && instance) {\n      return instance.hasPrevious;\n    } else {\n      return false;\n    }\n  });\n  const loadNext = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n    var _f;\n    const collection = collectionRef.current.instance;\n    if ((collection === null || collection === void 0 ? void 0 : collection.hasNext) && !isFetching.current.next) {\n      try {\n        isFetching.current.next = true;\n        const list = yield collection.loadNext();\n        updateMessages(list, false, (_f = sdk.currentUser) === null || _f === void 0 ? void 0 : _f.userId);\n      } catch (_g) {\n        // noop\n      } finally {\n        isFetching.current.next = false;\n      }\n    }\n  }));\n  const hasNext = usePreservedCallback(() => {\n    // When the API is not initialized, the default value of collection.hasNext is true.\n    // Due to this, there is an issue with UI elements such as the scroll to bottom button appearing and disappearing.\n    // To address this, we additionally check the API initialized state.\n    const {\n      initialized,\n      apiInitialized,\n      instance\n    } = collectionRef.current;\n    if (apiInitialized && initialized && instance) {\n      return instance.hasNext;\n    } else {\n      return false;\n    }\n  });\n  const sendUserMessage = usePreservedCallback((params, onPending) => {\n    var _a;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise((resolve, reject) => {\n      channelRef.current.sendUserMessage(params).onPending(pendingMessage => {\n        var _a;\n        if (pendingMessage.channelUrl === channelRef.current.url) {\n          updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n      }).onSucceeded(sentMessage => {\n        var _a;\n        if (sentMessage.channelUrl === channelRef.current.url) {\n          updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        resolve(sentMessage);\n      }).onFailed((err, failedMessage) => {\n        var _a;\n        if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n          updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        reject(err);\n      });\n    });\n  });\n  const sendFileMessage = usePreservedCallback((params, onPending) => {\n    var _a;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise((resolve, reject) => {\n      channelRef.current.sendFileMessage(params).onPending(pendingMessage => {\n        var _a;\n        if (pendingMessage.channelUrl === channelRef.current.url) {\n          updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n      }).onSucceeded(sentMessage => {\n        var _a;\n        if (sentMessage.channelUrl === channelRef.current.url) {\n          updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        resolve(sentMessage);\n      }).onFailed((err, failedMessage) => {\n        var _a;\n        if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n          updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        reject(err);\n      });\n    });\n  });\n  const sendFileMessages = usePreservedCallback((paramsList, onPending) => __awaiter(void 0, void 0, void 0, function* () {\n    var _h;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_h = logger === null || logger === void 0 ? void 0 : logger.error) === null || _h === void 0 ? void 0 : _h.call(logger, '[useGroupChannelMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise(resolve => {\n      const messages = [];\n      channelRef.current.sendFileMessages(paramsList).onPending(pendingMessage => {\n        var _a;\n        if (pendingMessage.channelUrl === channelRef.current.url) {\n          updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n      }).onSucceeded(sentMessage => {\n        var _a;\n        if (sentMessage.isFileMessage() && sentMessage.channelUrl === channelRef.current.url) {\n          updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n          messages.push(sentMessage);\n        }\n        if (messages.length === paramsList.length) resolve(messages);\n      }).onFailed((_, failedMessage) => {\n        var _a;\n        if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n          updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n          messages.push(failedMessage);\n        } else {\n          // NOTE: Since failedMessage is nullable by type, to resolve the promise, handle pushing null even when there is no failedMessage.\n          messages.push(null);\n        }\n        if (messages.length === paramsList.length) resolve(messages);\n      });\n    });\n  }));\n  const sendMultipleFilesMessage = usePreservedCallback((params, onPending) => {\n    var _a;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise((resolve, reject) => {\n      channelRef.current.sendMultipleFilesMessage(params).onPending(pendingMessage => {\n        var _a;\n        if (pendingMessage.channelUrl === channelRef.current.url) {\n          updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n      }).onFileUploaded(() => {\n        // Just re-render to use updated message.messageParams\n        forceUpdate();\n      }).onSucceeded(sentMessage => {\n        var _a;\n        if (sentMessage.channelUrl === channelRef.current.url) {\n          updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        resolve(sentMessage);\n      }).onFailed((err, failedMessage) => {\n        var _a;\n        if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n          updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        reject(err);\n      });\n    });\n  });\n  const updateUserMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {\n    var _j, _k;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_j = logger === null || logger === void 0 ? void 0 : logger.error) === null || _j === void 0 ? void 0 : _j.call(logger, '[useGroupChannelMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    const updatedMessage = yield channelRef.current.updateUserMessage(messageId, params);\n    if (updatedMessage.channelUrl === channelRef.current.url) {\n      updateMessages([updatedMessage], false, (_k = sdk.currentUser) === null || _k === void 0 ? void 0 : _k.userId);\n    }\n    return updatedMessage;\n  }));\n  const updateFileMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {\n    var _l, _m;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_l = logger === null || logger === void 0 ? void 0 : logger.error) === null || _l === void 0 ? void 0 : _l.call(logger, '[useGroupChannelMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    const updatedMessage = yield channelRef.current.updateFileMessage(messageId, params);\n    if (updatedMessage.channelUrl === channelRef.current.url) {\n      updateMessages([updatedMessage], false, (_m = sdk.currentUser) === null || _m === void 0 ? void 0 : _m.userId);\n    }\n    return updatedMessage;\n  }));\n  const resendMessage = usePreservedCallback(failedMessage => __awaiter(void 0, void 0, void 0, function* () {\n    var _o;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_o = logger === null || logger === void 0 ? void 0 : logger.error) === null || _o === void 0 ? void 0 : _o.call(logger, '[useGroupChannelMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise((resolve, reject) => {\n      let handler = undefined;\n      if (failedMessage.isUserMessage()) handler = channelRef.current.resendMessage(failedMessage);\n      if (failedMessage.isFileMessage()) handler = channelRef.current.resendMessage(failedMessage);\n      if (failedMessage.isMultipleFilesMessage()) handler = channelRef.current.resendMessage(failedMessage);\n      if (handler) {\n        if ('onPending' in handler) {\n          handler.onPending(message => {\n            var _a;\n            if (message.channelUrl === channelRef.current.url) {\n              updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n            }\n          });\n        }\n        if ('onFileUploaded' in handler) {\n          handler.onFileUploaded(() => {\n            // Just re-render to use updated message.messageParams\n            forceUpdate();\n          });\n        }\n        if ('onSucceeded' in handler) {\n          handler.onSucceeded(message => {\n            var _a;\n            if (message.channelUrl === channelRef.current.url) {\n              updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n            }\n            resolve(message);\n          });\n        }\n        if ('onFailed' in handler) {\n          handler.onFailed((err, message) => {\n            var _a;\n            if (message && message.channelUrl === channelRef.current.url) {\n              updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n            }\n            reject(err);\n          });\n        }\n      }\n    });\n  }));\n  const deleteMessage = usePreservedCallback(message => __awaiter(void 0, void 0, void 0, function* () {\n    var _p, _q;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_p = logger === null || logger === void 0 ? void 0 : logger.error) === null || _p === void 0 ? void 0 : _p.call(logger, '[useGroupChannelMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    if (message.sendingStatus === 'succeeded') {\n      if (message.isUserMessage()) yield channelRef.current.deleteMessage(message);\n      if (message.isFileMessage()) yield channelRef.current.deleteMessage(message);\n      if (message.isMultipleFilesMessage()) yield channelRef.current.deleteMessage(message);\n    } else {\n      try {\n        yield (_q = collectionRef.current.instance) === null || _q === void 0 ? void 0 : _q.removeFailedMessage(message.reqId);\n      } finally {\n        deleteMessages([message.messageId], [message.reqId]);\n      }\n    }\n  }));\n  const resetNewMessages = usePreservedCallback(() => {\n    var _a;\n    updateNewMessages([], true, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n  });\n  const resetWithStartingPoint = usePreservedCallback(startingPoint => __awaiter(void 0, void 0, void 0, function* () {\n    var _r;\n    if (sdk.currentUser && channelRef.current) {\n      const limit = getCollectionLimitBy(startingPoint);\n      updateLoading(true);\n      updateMessages([], true, (_r = sdk.currentUser) === null || _r === void 0 ? void 0 : _r.userId);\n      yield init(startingPoint, limit);\n      updateLoading(false);\n    }\n  }));\n  return {\n    /**\n     * Initialized state, only available on first render\n     * */\n    initialized,\n    /**\n     * Loading state, status is changes on first mount or when the resetWithStartingPoint is called.\n     * */\n    loading,\n    /**\n     * Refreshing state, status is changes when the refresh is called.\n     * */\n    refreshing,\n    /**\n     * Get messages, this state is for render\n     * For example, if a user receives a new messages while searching for an old message\n     * for this case, new messages will be included here.\n     * */\n    messages,\n    /**\n     * If the `shouldCountNewMessages()` is true, only then push in the newMessages state.\n     * (Return false for the `shouldCountNewMessages()` if the message scroll is the most recent; otherwise, return true.)\n     *\n     * A new message means a message that meets the below conditions\n     * - Not admin message\n     * - Not updated message\n     * - Not current user's message\n     * */\n    newMessages,\n    /**\n     * Reset new message list\n     * @return {void}\n     * */\n    resetNewMessages,\n    /**\n     * Reset message list and create a new collection for latest messages\n     * @return {Promise<void>}\n     * */\n    refresh,\n    /**\n     * Load previous messages to state\n     * @return {Promise<void>}\n     * */\n    loadPrevious,\n    /**\n     * Check if there are more previous messages to fetch\n     * @return {boolean}\n     * */\n    hasPrevious,\n    /**\n     * Load next messages to state\n     * @return {Promise<void>}\n     * */\n    loadNext,\n    /**\n     * Check if there are more next messages to fetch\n     * @return {boolean}\n     * */\n    hasNext,\n    /**\n     * Send user message\n     * @param {UserMessageCreateParams} params user message create params\n     * @param {function} [onPending] pending message callback\n     * @return {Promise<UserMessage>} succeeded message\n     * */\n    sendUserMessage,\n    /**\n     * Send file message\n     * @param {FileMessageCreateParams} params file message create params\n     * @param {function} [onPending] pending message callback\n     * @return {Promise<FileMessage>} succeeded message\n     * */\n    sendFileMessage,\n    /**\n     * Send file messages\n     * @param {FileMessageCreateParams[]} paramList file message create params\n     * @param {function} [onPending] pending message callback for each message request\n     * @return {Promise<FileMessage[]>} succeeded or failed message\n     * */\n    sendFileMessages,\n    /**\n     * Send multiple files message\n     * @param {MultipleFilesMessageCreateParams} params multiple files message create params\n     * @param {function} [onPending] pending message callback\n     * @return {Promise<MultipleFilesMessage>} succeeded message\n     * */\n    sendMultipleFilesMessage,\n    /**\n     * Update user message\n     * @param {number} messageId\n     * @param {UserMessageUpdateParams} params user message update params\n     * @return {Promise<UserMessage>}\n     * */\n    updateUserMessage,\n    /**\n     * Update file message\n     * @param {number} messageId\n     * @param {FileMessageUpdateParams} params file message update params\n     * @return {Promise<FileMessage>}\n     * */\n    updateFileMessage,\n    /**\n     * Resend failed message\n     * @template {UserMessage | FileMessage | MultipleFilesMessage} T\n     * @param {T} failedMessage message to resend\n     * @return {Promise<T>}\n     * */\n    resendMessage,\n    /**\n     * Delete a message\n     * @template {UserMessage | FileMessage | MultipleFilesMessage} T\n     * @param {T} message succeeded or failed message\n     * @return {Promise<void>}\n     * */\n    deleteMessage,\n    /**\n     * Reset message list and create a new collection with starting point\n     * @param {number} startingPoint\n     * @param {function} callback\n     * @return {void}\n     * */\n    resetWithStartingPoint,\n    /**\n     * Do not use this api\n     * */\n    _dangerous_reducer_updateMessages: updateMessages,\n    /**\n     * Do not use this api\n     * */\n    _dangerous_reducer_deleteMessages: deleteMessages\n  };\n};","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","useEffect","useLayoutEffect","useRef","CollectionEventSource","MessageCollectionInitPolicy","MessageFilter","sbuConstants","isDifferentChannel","isMyMessage","isSendableMessage","isNotEmptyArray","useForceUpdate","useGroupChannelHandler","usePreservedCallback","useChannelMessagesReducer","createMessageCollection","channel","limit","options","_a","basicParams","prevResultLimit","prev","nextResultLimit","startingPoint","replyType","passedCollection","collectionCreator","call","Object","assign","filter","getCollectionLimitBy","Date","now","collection","message","searchLimit","defaultLimit","useGroupChannelMessages","sdk","arguments","length","undefined","_b","_c","internalOptions","current","channelRef","logger","initialStartingPoint","Number","MAX_SAFE_INTEGER","initialLimit","isFetching","forceUpdate","collectionRef","initialized","apiInitialized","instance","loading","refreshing","messages","newMessages","updateMessages","updateNewMessages","deleteNewMessages","deleteMessages","updateInitialized","updateLoading","updateRefreshing","sortComparator","markAsReadBySource","source","_d","url","error","EVENT_MESSAGE_RECEIVED","EVENT_MESSAGE_SENT_SUCCESS","SYNC_MESSAGE_FILL","markAsRead","warn","updateNewMessagesReceived","_e","incomingMessages","it","currentUser","userId","shouldCountNewMessages","onMessagesReceived","init","dispose","updateUnsentMessages","pendingMessages","failedMessages","collectionInstance","setMessageCollectionHandler","onMessagesAdded","ctx","__","onMessagesUpdated","EVENT_MESSAGE_UPDATED","onMessagesDeleted","_","___","msgIds","map","messageId","reqIds","reqId","onChannelDeleted","channelUrl","onChannelUpdated","onHugeGapDetected","initialize","CACHE_AND_REPLACE_BY_API","onCacheResult","err","isCacheEnabled","debug","onApiResult","onUserBanned","eventChannel","bannedUser","isGroupChannel","onCurrentUserBanned","timeout","setTimeout","clearTimeout","refresh","loadPrevious","hasPrevious","list","loadNext","_f","hasNext","_g","sendUserMessage","params","onPending","Error","pendingMessage","onSucceeded","sentMessage","onFailed","failedMessage","sendFileMessage","sendFileMessages","paramsList","_h","isFileMessage","push","sendMultipleFilesMessage","onFileUploaded","updateUserMessage","_j","_k","updatedMessage","updateFileMessage","_l","_m","resendMessage","_o","handler","isUserMessage","isMultipleFilesMessage","deleteMessage","_p","_q","sendingStatus","removeFailedMessage","resetNewMessages","resetWithStartingPoint","_r","_dangerous_reducer_updateMessages","_dangerous_reducer_deleteMessages"],"sources":["D:/ebgbot/node_modules/@sendbird/uikit-react/node_modules/@sendbird/uikit-tools/dist/esm/hooks/useGroupChannelMessages/index.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { useEffect, useLayoutEffect, useRef } from 'react';\nimport { CollectionEventSource } from '@sendbird/chat';\nimport { MessageCollectionInitPolicy, MessageFilter } from '@sendbird/chat/groupChannel';\nimport { sbuConstants } from '../../constants/sbuConstants.js';\nimport { isDifferentChannel } from '../../utils/channel.js';\nimport { isMyMessage, isSendableMessage } from '../../utils/message.js';\nimport { isNotEmptyArray } from '../../utils/validators.js';\nimport { useForceUpdate } from '../useForceUpdate.js';\nimport { useGroupChannelHandler } from '../useGroupChannelHandler.js';\nimport { usePreservedCallback } from '../usePreservedCallback.js';\nimport { useChannelMessagesReducer } from './reducer.js';\nconst createMessageCollection = (channel, limit, options) => {\n    var _a;\n    const basicParams = {\n        prevResultLimit: limit.prev,\n        nextResultLimit: limit.next,\n        startingPoint: options === null || options === void 0 ? void 0 : options.startingPoint,\n        replyType: options === null || options === void 0 ? void 0 : options.replyType,\n    };\n    const passedCollection = (_a = options === null || options === void 0 ? void 0 : options.collectionCreator) === null || _a === void 0 ? void 0 : _a.call(options, basicParams);\n    if (passedCollection)\n        return passedCollection;\n    return channel.createMessageCollection(Object.assign(Object.assign({}, basicParams), { filter: new MessageFilter(basicParams) }));\n};\n// NOTE: In React-Native's FlatList, the bidirectional message loading doesn't work reliably, causing a bug\n//  where scrolling jumps to a random position when loading a large number of messages at once.\n//  Therefore, in the message search that explores past messages, a small number of messages is loaded to address this issue.\nfunction getCollectionLimitBy(startingPoint) {\n    return startingPoint < Date.now()\n        ? sbuConstants.collection.message.searchLimit\n        : sbuConstants.collection.message.defaultLimit;\n}\n/**\n * group channel messages hook\n * - Receive new messages from other users & should count new messages -> append to state(newMessages)\n * - onTopReached -> prev() -> fetch prev messages and append to state(messages)\n * - onBottomReached -> next() -> fetch next messages and append to state(messages)\n * */\nexport const useGroupChannelMessages = (sdk, channel, options = {}) => {\n    var _a, _b, _c;\n    const internalOptions = useRef(options); // to keep reference of options in event handler\n    internalOptions.current = options;\n    const channelRef = useRef(channel); // to keep reference of channel in event handler\n    channelRef.current = channel;\n    const logger = internalOptions.current.logger;\n    const initialStartingPoint = (_a = internalOptions.current.startingPoint) !== null && _a !== void 0 ? _a : Number.MAX_SAFE_INTEGER;\n    const initialLimit = getCollectionLimitBy(initialStartingPoint);\n    const isFetching = useRef({ prev: false, next: false });\n    const forceUpdate = useForceUpdate();\n    const collectionRef = useRef({\n        initialized: false,\n        apiInitialized: false,\n        instance: null,\n    });\n    const { initialized, loading, refreshing, messages, newMessages, updateMessages, updateNewMessages, deleteNewMessages, deleteMessages, updateInitialized, updateLoading, updateRefreshing, } = useChannelMessagesReducer(options === null || options === void 0 ? void 0 : options.sortComparator);\n    const markAsReadBySource = usePreservedCallback((source) => {\n        var _a, _b, _c, _d;\n        if (!channelRef.current || !channelRef.current.url)\n            return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n        try {\n            switch (source) {\n                case CollectionEventSource.EVENT_MESSAGE_RECEIVED:\n                case CollectionEventSource.EVENT_MESSAGE_SENT_SUCCESS:\n                case CollectionEventSource.SYNC_MESSAGE_FILL:\n                case undefined:\n                    (_c = (_b = internalOptions.current).markAsRead) === null || _c === void 0 ? void 0 : _c.call(_b, [channelRef.current]);\n                    break;\n            }\n        }\n        catch (e) {\n            (_d = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _d === void 0 ? void 0 : _d.call(logger, '[useGroupChannelMessages/markAsReadBySource]', e);\n        }\n    });\n    const updateNewMessagesReceived = usePreservedCallback((source, messages) => {\n        var _a, _b, _c, _d, _e;\n        const incomingMessages = messages.filter((it) => { var _a; return !isMyMessage(it, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId); });\n        if (incomingMessages.length > 0) {\n            switch (source) {\n                case CollectionEventSource.EVENT_MESSAGE_RECEIVED:\n                case CollectionEventSource.SYNC_MESSAGE_FILL: {\n                    if ((_b = (_a = internalOptions.current).shouldCountNewMessages) === null || _b === void 0 ? void 0 : _b.call(_a)) {\n                        updateNewMessages(incomingMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n                    }\n                    (_e = (_d = internalOptions.current).onMessagesReceived) === null || _e === void 0 ? void 0 : _e.call(_d, incomingMessages);\n                    break;\n                }\n            }\n        }\n    });\n    const init = usePreservedCallback((startingPoint, limit) => __awaiter(void 0, void 0, void 0, function* () {\n        return new Promise((resolve) => {\n            var _a, _b;\n            if (!channelRef.current || !channelRef.current.url)\n                return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n            if (collectionRef.current.instance)\n                collectionRef.current.instance.dispose();\n            markAsReadBySource();\n            updateNewMessages([], true, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId);\n            const updateUnsentMessages = () => {\n                var _a, _b, _c;\n                const { pendingMessages, failedMessages } = (_a = collectionRef.current.instance) !== null && _a !== void 0 ? _a : {};\n                if (isNotEmptyArray(pendingMessages))\n                    updateMessages(pendingMessages, false, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId);\n                if (isNotEmptyArray(failedMessages))\n                    updateMessages(failedMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n            };\n            const collectionInstance = createMessageCollection(channelRef.current, limit, Object.assign(Object.assign({}, internalOptions.current), { startingPoint }));\n            collectionRef.current = { apiInitialized: false, initialized: false, instance: collectionInstance };\n            collectionInstance.setMessageCollectionHandler({\n                onMessagesAdded: (ctx, __, messages) => {\n                    var _a;\n                    markAsReadBySource(ctx.source);\n                    updateNewMessagesReceived(ctx.source, messages);\n                    updateMessages(messages, false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                },\n                onMessagesUpdated: (ctx, __, messages) => {\n                    var _a, _b, _c;\n                    markAsReadBySource(ctx.source);\n                    updateNewMessagesReceived(ctx.source, messages); // NOTE: admin message is not added via onMessagesAdded handler, not checked yet is this a bug.\n                    updateMessages(messages, false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                    if (ctx.source === CollectionEventSource.EVENT_MESSAGE_UPDATED) {\n                        (_c = (_b = internalOptions.current).onMessagesUpdated) === null || _c === void 0 ? void 0 : _c.call(_b, messages);\n                    }\n                },\n                onMessagesDeleted: (_, __, ___, messages) => {\n                    const msgIds = messages.map((it) => it.messageId);\n                    const reqIds = messages.filter(isSendableMessage).map((it) => it.reqId);\n                    deleteMessages(msgIds, reqIds);\n                    deleteNewMessages(msgIds, reqIds);\n                },\n                onChannelDeleted: (_, channelUrl) => {\n                    var _a, _b;\n                    (_b = (_a = internalOptions.current).onChannelDeleted) === null || _b === void 0 ? void 0 : _b.call(_a, channelUrl);\n                },\n                onChannelUpdated: (_, channel) => {\n                    var _a, _b;\n                    forceUpdate();\n                    (_b = (_a = internalOptions.current).onChannelUpdated) === null || _b === void 0 ? void 0 : _b.call(_a, channel);\n                },\n                onHugeGapDetected: () => {\n                    init(Number.MAX_SAFE_INTEGER, sbuConstants.collection.message.defaultLimit);\n                },\n            });\n            collectionInstance\n                .initialize(MessageCollectionInitPolicy.CACHE_AND_REPLACE_BY_API)\n                .onCacheResult((err, messages) => {\n                var _a, _b, _c;\n                if (err)\n                    sdk.isCacheEnabled && ((_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages/onCacheResult]', err));\n                else if (messages) {\n                    (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelMessages/onCacheResult]', 'message length:', messages.length);\n                    updateMessages(messages, true, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n                    updateUnsentMessages();\n                    // Note: If there are messages exchanged in the channel but no cached messages have been saved yet,\n                    //  to prevent the API-retrieved messages from appearing immediately after the 'no messages' UI is displayed,\n                    //  resolve only when there are messages present in the cache\n                    if (messages.length > 0) {\n                        collectionRef.current.initialized = true;\n                        resolve();\n                    }\n                }\n            })\n                .onApiResult((err, messages) => {\n                var _a, _b, _c, _d, _e;\n                if (err)\n                    (_a = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages/onApiResult]', err);\n                else if (messages) {\n                    (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelMessages/onApiResult]', 'message length:', messages.length);\n                    updateMessages(messages, true, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n                    if (!internalOptions.current.startingPoint)\n                        (_e = (_d = internalOptions.current).onMessagesReceived) === null || _e === void 0 ? void 0 : _e.call(_d, messages);\n                    if (sdk.isCacheEnabled)\n                        updateUnsentMessages();\n                }\n                collectionRef.current.initialized = true;\n                collectionRef.current.apiInitialized = true;\n                resolve();\n            });\n        });\n    }));\n    useGroupChannelHandler(sdk, {\n        onUserBanned(eventChannel, bannedUser) {\n            var _a, _b, _c;\n            if (eventChannel.isGroupChannel() && !isDifferentChannel(eventChannel, channelRef.current)) {\n                if (bannedUser.userId === ((_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId)) {\n                    (_c = (_b = internalOptions.current).onCurrentUserBanned) === null || _c === void 0 ? void 0 : _c.call(_b);\n                }\n                else {\n                    forceUpdate();\n                }\n            }\n        },\n    });\n    useLayoutEffect(() => {\n        const timeout = setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {\n            if (sdk.currentUser && channelRef.current) {\n                updateInitialized(false);\n                updateLoading(true);\n                yield init(initialStartingPoint, initialLimit);\n                updateLoading(false);\n                updateInitialized(true);\n            }\n        }));\n        return () => clearTimeout(timeout);\n    }, [sdk, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId, (_c = channelRef.current) === null || _c === void 0 ? void 0 : _c.url, internalOptions.current.replyType]);\n    useEffect(() => {\n        return () => {\n            if (collectionRef.current.instance)\n                collectionRef.current.instance.dispose();\n        };\n    }, []);\n    const refresh = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        if (sdk.currentUser && channelRef.current) {\n            updateRefreshing(true);\n            yield init(Number.MAX_SAFE_INTEGER, sbuConstants.collection.message.defaultLimit);\n            updateRefreshing(false);\n        }\n    }));\n    const loadPrevious = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        var _d;\n        const collection = collectionRef.current.instance;\n        if ((collection === null || collection === void 0 ? void 0 : collection.hasPrevious) && !isFetching.current.prev) {\n            try {\n                isFetching.current.prev = true;\n                const list = yield collection.loadPrevious();\n                updateMessages(list, false, (_d = sdk.currentUser) === null || _d === void 0 ? void 0 : _d.userId);\n            }\n            catch (_e) {\n                // noop\n            }\n            finally {\n                isFetching.current.prev = false;\n            }\n        }\n    }));\n    const hasPrevious = usePreservedCallback(() => {\n        const { initialized, instance } = collectionRef.current;\n        if (initialized && instance) {\n            return instance.hasPrevious;\n        }\n        else {\n            return false;\n        }\n    });\n    const loadNext = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        var _f;\n        const collection = collectionRef.current.instance;\n        if ((collection === null || collection === void 0 ? void 0 : collection.hasNext) && !isFetching.current.next) {\n            try {\n                isFetching.current.next = true;\n                const list = yield collection.loadNext();\n                updateMessages(list, false, (_f = sdk.currentUser) === null || _f === void 0 ? void 0 : _f.userId);\n            }\n            catch (_g) {\n                // noop\n            }\n            finally {\n                isFetching.current.next = false;\n            }\n        }\n    }));\n    const hasNext = usePreservedCallback(() => {\n        // When the API is not initialized, the default value of collection.hasNext is true.\n        // Due to this, there is an issue with UI elements such as the scroll to bottom button appearing and disappearing.\n        // To address this, we additionally check the API initialized state.\n        const { initialized, apiInitialized, instance } = collectionRef.current;\n        if (apiInitialized && initialized && instance) {\n            return instance.hasNext;\n        }\n        else {\n            return false;\n        }\n    });\n    const sendUserMessage = usePreservedCallback((params, onPending) => {\n        var _a;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve, reject) => {\n            channelRef.current\n                .sendUserMessage(params)\n                .onPending((pendingMessage) => {\n                var _a;\n                if (pendingMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n            })\n                .onSucceeded((sentMessage) => {\n                var _a;\n                if (sentMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                resolve(sentMessage);\n            })\n                .onFailed((err, failedMessage) => {\n                var _a;\n                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                reject(err);\n            });\n        });\n    });\n    const sendFileMessage = usePreservedCallback((params, onPending) => {\n        var _a;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve, reject) => {\n            channelRef.current\n                .sendFileMessage(params)\n                .onPending((pendingMessage) => {\n                var _a;\n                if (pendingMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n            })\n                .onSucceeded((sentMessage) => {\n                var _a;\n                if (sentMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                resolve(sentMessage);\n            })\n                .onFailed((err, failedMessage) => {\n                var _a;\n                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                reject(err);\n            });\n        });\n    });\n    const sendFileMessages = usePreservedCallback((paramsList, onPending) => __awaiter(void 0, void 0, void 0, function* () {\n        var _h;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_h = logger === null || logger === void 0 ? void 0 : logger.error) === null || _h === void 0 ? void 0 : _h.call(logger, '[useGroupChannelMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve) => {\n            const messages = [];\n            channelRef.current\n                .sendFileMessages(paramsList)\n                .onPending((pendingMessage) => {\n                var _a;\n                if (pendingMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n            })\n                .onSucceeded((sentMessage) => {\n                var _a;\n                if (sentMessage.isFileMessage() && sentMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                    messages.push(sentMessage);\n                }\n                if (messages.length === paramsList.length)\n                    resolve(messages);\n            })\n                .onFailed((_, failedMessage) => {\n                var _a;\n                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                    messages.push(failedMessage);\n                }\n                else {\n                    // NOTE: Since failedMessage is nullable by type, to resolve the promise, handle pushing null even when there is no failedMessage.\n                    messages.push(null);\n                }\n                if (messages.length === paramsList.length)\n                    resolve(messages);\n            });\n        });\n    }));\n    const sendMultipleFilesMessage = usePreservedCallback((params, onPending) => {\n        var _a;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve, reject) => {\n            channelRef.current\n                .sendMultipleFilesMessage(params)\n                .onPending((pendingMessage) => {\n                var _a;\n                if (pendingMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n            })\n                .onFileUploaded(() => {\n                // Just re-render to use updated message.messageParams\n                forceUpdate();\n            })\n                .onSucceeded((sentMessage) => {\n                var _a;\n                if (sentMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                resolve(sentMessage);\n            })\n                .onFailed((err, failedMessage) => {\n                var _a;\n                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                reject(err);\n            });\n        });\n    });\n    const updateUserMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {\n        var _j, _k;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_j = logger === null || logger === void 0 ? void 0 : logger.error) === null || _j === void 0 ? void 0 : _j.call(logger, '[useGroupChannelMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        const updatedMessage = yield channelRef.current.updateUserMessage(messageId, params);\n        if (updatedMessage.channelUrl === channelRef.current.url) {\n            updateMessages([updatedMessage], false, (_k = sdk.currentUser) === null || _k === void 0 ? void 0 : _k.userId);\n        }\n        return updatedMessage;\n    }));\n    const updateFileMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {\n        var _l, _m;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_l = logger === null || logger === void 0 ? void 0 : logger.error) === null || _l === void 0 ? void 0 : _l.call(logger, '[useGroupChannelMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        const updatedMessage = yield channelRef.current.updateFileMessage(messageId, params);\n        if (updatedMessage.channelUrl === channelRef.current.url) {\n            updateMessages([updatedMessage], false, (_m = sdk.currentUser) === null || _m === void 0 ? void 0 : _m.userId);\n        }\n        return updatedMessage;\n    }));\n    const resendMessage = usePreservedCallback((failedMessage) => __awaiter(void 0, void 0, void 0, function* () {\n        var _o;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_o = logger === null || logger === void 0 ? void 0 : logger.error) === null || _o === void 0 ? void 0 : _o.call(logger, '[useGroupChannelMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve, reject) => {\n            let handler = undefined;\n            if (failedMessage.isUserMessage())\n                handler = channelRef.current.resendMessage(failedMessage);\n            if (failedMessage.isFileMessage())\n                handler = channelRef.current.resendMessage(failedMessage);\n            if (failedMessage.isMultipleFilesMessage())\n                handler = channelRef.current.resendMessage(failedMessage);\n            if (handler) {\n                if ('onPending' in handler) {\n                    handler.onPending((message) => {\n                        var _a;\n                        if (message.channelUrl === channelRef.current.url) {\n                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                        }\n                    });\n                }\n                if ('onFileUploaded' in handler) {\n                    handler.onFileUploaded(() => {\n                        // Just re-render to use updated message.messageParams\n                        forceUpdate();\n                    });\n                }\n                if ('onSucceeded' in handler) {\n                    handler.onSucceeded((message) => {\n                        var _a;\n                        if (message.channelUrl === channelRef.current.url) {\n                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                        }\n                        resolve(message);\n                    });\n                }\n                if ('onFailed' in handler) {\n                    handler.onFailed((err, message) => {\n                        var _a;\n                        if (message && message.channelUrl === channelRef.current.url) {\n                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                        }\n                        reject(err);\n                    });\n                }\n            }\n        });\n    }));\n    const deleteMessage = usePreservedCallback((message) => __awaiter(void 0, void 0, void 0, function* () {\n        var _p, _q;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_p = logger === null || logger === void 0 ? void 0 : logger.error) === null || _p === void 0 ? void 0 : _p.call(logger, '[useGroupChannelMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        if (message.sendingStatus === 'succeeded') {\n            if (message.isUserMessage())\n                yield channelRef.current.deleteMessage(message);\n            if (message.isFileMessage())\n                yield channelRef.current.deleteMessage(message);\n            if (message.isMultipleFilesMessage())\n                yield channelRef.current.deleteMessage(message);\n        }\n        else {\n            try {\n                yield ((_q = collectionRef.current.instance) === null || _q === void 0 ? void 0 : _q.removeFailedMessage(message.reqId));\n            }\n            finally {\n                deleteMessages([message.messageId], [message.reqId]);\n            }\n        }\n    }));\n    const resetNewMessages = usePreservedCallback(() => {\n        var _a;\n        updateNewMessages([], true, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n    });\n    const resetWithStartingPoint = usePreservedCallback((startingPoint) => __awaiter(void 0, void 0, void 0, function* () {\n        var _r;\n        if (sdk.currentUser && channelRef.current) {\n            const limit = getCollectionLimitBy(startingPoint);\n            updateLoading(true);\n            updateMessages([], true, (_r = sdk.currentUser) === null || _r === void 0 ? void 0 : _r.userId);\n            yield init(startingPoint, limit);\n            updateLoading(false);\n        }\n    }));\n    return {\n        /**\n         * Initialized state, only available on first render\n         * */\n        initialized,\n        /**\n         * Loading state, status is changes on first mount or when the resetWithStartingPoint is called.\n         * */\n        loading,\n        /**\n         * Refreshing state, status is changes when the refresh is called.\n         * */\n        refreshing,\n        /**\n         * Get messages, this state is for render\n         * For example, if a user receives a new messages while searching for an old message\n         * for this case, new messages will be included here.\n         * */\n        messages,\n        /**\n         * If the `shouldCountNewMessages()` is true, only then push in the newMessages state.\n         * (Return false for the `shouldCountNewMessages()` if the message scroll is the most recent; otherwise, return true.)\n         *\n         * A new message means a message that meets the below conditions\n         * - Not admin message\n         * - Not updated message\n         * - Not current user's message\n         * */\n        newMessages,\n        /**\n         * Reset new message list\n         * @return {void}\n         * */\n        resetNewMessages,\n        /**\n         * Reset message list and create a new collection for latest messages\n         * @return {Promise<void>}\n         * */\n        refresh,\n        /**\n         * Load previous messages to state\n         * @return {Promise<void>}\n         * */\n        loadPrevious,\n        /**\n         * Check if there are more previous messages to fetch\n         * @return {boolean}\n         * */\n        hasPrevious,\n        /**\n         * Load next messages to state\n         * @return {Promise<void>}\n         * */\n        loadNext,\n        /**\n         * Check if there are more next messages to fetch\n         * @return {boolean}\n         * */\n        hasNext,\n        /**\n         * Send user message\n         * @param {UserMessageCreateParams} params user message create params\n         * @param {function} [onPending] pending message callback\n         * @return {Promise<UserMessage>} succeeded message\n         * */\n        sendUserMessage,\n        /**\n         * Send file message\n         * @param {FileMessageCreateParams} params file message create params\n         * @param {function} [onPending] pending message callback\n         * @return {Promise<FileMessage>} succeeded message\n         * */\n        sendFileMessage,\n        /**\n         * Send file messages\n         * @param {FileMessageCreateParams[]} paramList file message create params\n         * @param {function} [onPending] pending message callback for each message request\n         * @return {Promise<FileMessage[]>} succeeded or failed message\n         * */\n        sendFileMessages,\n        /**\n         * Send multiple files message\n         * @param {MultipleFilesMessageCreateParams} params multiple files message create params\n         * @param {function} [onPending] pending message callback\n         * @return {Promise<MultipleFilesMessage>} succeeded message\n         * */\n        sendMultipleFilesMessage,\n        /**\n         * Update user message\n         * @param {number} messageId\n         * @param {UserMessageUpdateParams} params user message update params\n         * @return {Promise<UserMessage>}\n         * */\n        updateUserMessage,\n        /**\n         * Update file message\n         * @param {number} messageId\n         * @param {FileMessageUpdateParams} params file message update params\n         * @return {Promise<FileMessage>}\n         * */\n        updateFileMessage,\n        /**\n         * Resend failed message\n         * @template {UserMessage | FileMessage | MultipleFilesMessage} T\n         * @param {T} failedMessage message to resend\n         * @return {Promise<T>}\n         * */\n        resendMessage,\n        /**\n         * Delete a message\n         * @template {UserMessage | FileMessage | MultipleFilesMessage} T\n         * @param {T} message succeeded or failed message\n         * @return {Promise<void>}\n         * */\n        deleteMessage,\n        /**\n         * Reset message list and create a new collection with starting point\n         * @param {number} startingPoint\n         * @param {function} callback\n         * @return {void}\n         * */\n        resetWithStartingPoint,\n        /**\n         * Do not use this api\n         * */\n        _dangerous_reducer_updateMessages: updateMessages,\n        /**\n         * Do not use this api\n         * */\n        _dangerous_reducer_deleteMessages: deleteMessages,\n    };\n};\n"],"mappings":"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6C,aAAa,CAAC,IAAI,CAAC;MACnBL,cAAc,CAAC,EAAE,EAAE,IAAI,EAAE,CAAC6G,EAAE,GAAGrI,GAAG,CAAC8C,WAAW,MAAM,IAAI,IAAIuF,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACtF,MAAM,CAAC;MAC/F,MAAMG,IAAI,CAAClE,aAAa,EAAEP,KAAK,CAAC;MAChCoD,aAAa,CAAC,KAAK,CAAC;IACxB;EACJ,CAAC,CAAC,CAAC;EACH,OAAO;IACH;AACR;AACA;IACQZ,WAAW;IACX;AACR;AACA;IACQG,OAAO;IACP;AACR;AACA;IACQC,UAAU;IACV;AACR;AACA;AACA;AACA;IACQC,QAAQ;IACR;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQC,WAAW;IACX;AACR;AACA;AACA;IACQ4G,gBAAgB;IAChB;AACR;AACA;AACA;IACQ1C,OAAO;IACP;AACR;AACA;AACA;IACQC,YAAY;IACZ;AACR;AACA;AACA;IACQC,WAAW;IACX;AACR;AACA;AACA;IACQE,QAAQ;IACR;AACR;AACA;AACA;IACQE,OAAO;IACP;AACR;AACA;AACA;AACA;AACA;IACQE,eAAe;IACf;AACR;AACA;AACA;AACA;AACA;IACQS,eAAe;IACf;AACR;AACA;AACA;AACA;AACA;IACQC,gBAAgB;IAChB;AACR;AACA;AACA;AACA;AACA;IACQK,wBAAwB;IACxB;AACR;AACA;AACA;AACA;AACA;IACQE,iBAAiB;IACjB;AACR;AACA;AACA;AACA;AACA;IACQI,iBAAiB;IACjB;AACR;AACA;AACA;AACA;AACA;IACQG,aAAa;IACb;AACR;AACA;AACA;AACA;AACA;IACQK,aAAa;IACb;AACR;AACA;AACA;AACA;AACA;IACQM,sBAAsB;IACtB;AACR;AACA;IACQE,iCAAiC,EAAE9G,cAAc;IACjD;AACR;AACA;IACQ+G,iCAAiC,EAAE5G;EACvC,CAAC;AACL,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module"}