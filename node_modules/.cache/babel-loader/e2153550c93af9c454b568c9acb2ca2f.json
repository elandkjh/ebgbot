{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { useEffect, useLayoutEffect, useRef } from 'react';\nimport { CollectionEventSource } from '@sendbird/chat';\nimport { MessageCollectionInitPolicy, MessageFilter } from '@sendbird/chat/groupChannel';\nimport { sbuConstants } from '../../constants/sbuConstants.js';\nimport { isDifferentChannel } from '../../utils/channel.js';\nimport { isMyMessage, isSendableMessage } from '../../utils/message.js';\nimport { isNotEmptyArray } from '../../utils/validators.js';\nimport { useForceUpdate } from '../useForceUpdate.js';\nimport { useGroupChannelHandler } from '../useGroupChannelHandler.js';\nimport { usePreservedCallback } from '../usePreservedCallback.js';\nimport { useChannelMessagesReducer } from './reducer.js';\nconst createMessageCollection = (channel, limit, options) => {\n  var _a;\n  const basicParams = {\n    prevResultLimit: limit.prev,\n    nextResultLimit: limit.next,\n    startingPoint: options === null || options === void 0 ? void 0 : options.startingPoint,\n    replyType: options === null || options === void 0 ? void 0 : options.replyType\n  };\n  const passedCollection = (_a = options === null || options === void 0 ? void 0 : options.collectionCreator) === null || _a === void 0 ? void 0 : _a.call(options, basicParams);\n  if (passedCollection) return passedCollection;\n  return channel.createMessageCollection(Object.assign(Object.assign({}, basicParams), {\n    filter: new MessageFilter(basicParams)\n  }));\n};\n// NOTE: In React-Native's FlatList, the bidirectional message loading doesn't work reliably, causing a bug\n//  where scrolling jumps to a random position when loading a large number of messages at once.\n//  Therefore, in the message search that explores past messages, a small number of messages is loaded to address this issue.\nfunction getCollectionLimitBy(startingPoint) {\n  return startingPoint < Date.now() ? sbuConstants.collection.message.searchLimit : sbuConstants.collection.message.defaultLimit;\n}\n/**\n * group channel messages hook\n * - Receive new messages from other users & should count new messages -> append to state(newMessages)\n * - onTopReached -> prev() -> fetch prev messages and append to state(messages)\n * - onBottomReached -> next() -> fetch next messages and append to state(messages)\n * */\nexport const useGroupChannelMessages = (sdk, channel, options = {}) => {\n  var _a, _b, _c;\n  const internalOptions = useRef(options); // to keep reference of options in event handler\n  internalOptions.current = options;\n  const channelRef = useRef(channel); // to keep reference of channel in event handler\n  channelRef.current = channel;\n  const logger = internalOptions.current.logger;\n  const initialStartingPoint = (_a = internalOptions.current.startingPoint) !== null && _a !== void 0 ? _a : Number.MAX_SAFE_INTEGER;\n  const initialLimit = getCollectionLimitBy(initialStartingPoint);\n  const isFetching = useRef({\n    prev: false,\n    next: false\n  });\n  const forceUpdate = useForceUpdate();\n  const collectionRef = useRef({\n    initialized: false,\n    apiInitialized: false,\n    instance: null\n  });\n  const {\n    initialized,\n    loading,\n    refreshing,\n    messages,\n    newMessages,\n    updateMessages,\n    updateNewMessages,\n    deleteNewMessages,\n    deleteMessages,\n    updateInitialized,\n    updateLoading,\n    updateRefreshing\n  } = useChannelMessagesReducer(options === null || options === void 0 ? void 0 : options.sortComparator);\n  const markAsReadBySource = usePreservedCallback(source => {\n    var _a, _b, _c, _d;\n    if (!channelRef.current || !channelRef.current.url) return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n    try {\n      switch (source) {\n        case CollectionEventSource.EVENT_MESSAGE_RECEIVED:\n        case CollectionEventSource.EVENT_MESSAGE_SENT_SUCCESS:\n        case CollectionEventSource.SYNC_MESSAGE_FILL:\n        case undefined:\n          (_c = (_b = internalOptions.current).markAsRead) === null || _c === void 0 ? void 0 : _c.call(_b, [channelRef.current]);\n          break;\n      }\n    } catch (e) {\n      (_d = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _d === void 0 ? void 0 : _d.call(logger, '[useGroupChannelMessages/markAsReadBySource]', e);\n    }\n  });\n  const updateNewMessagesReceived = usePreservedCallback((source, messages) => {\n    var _a, _b, _c, _d, _e;\n    const incomingMessages = messages.filter(it => {\n      var _a;\n      return !isMyMessage(it, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n    });\n    if (incomingMessages.length > 0) {\n      switch (source) {\n        case CollectionEventSource.EVENT_MESSAGE_RECEIVED:\n        case CollectionEventSource.SYNC_MESSAGE_FILL:\n          {\n            if ((_b = (_a = internalOptions.current).shouldCountNewMessages) === null || _b === void 0 ? void 0 : _b.call(_a)) {\n              updateNewMessages(incomingMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n            }\n            (_e = (_d = internalOptions.current).onMessagesReceived) === null || _e === void 0 ? void 0 : _e.call(_d, incomingMessages);\n            break;\n          }\n      }\n    }\n  });\n  const init = usePreservedCallback((startingPoint, limit) => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise(resolve => {\n      var _a, _b;\n      if (!channelRef.current || !channelRef.current.url) return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n      if (collectionRef.current.instance) collectionRef.current.instance.dispose();\n      markAsReadBySource();\n      updateNewMessages([], true, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId);\n      const updateUnsentMessages = () => {\n        var _a, _b, _c;\n        const {\n          pendingMessages,\n          failedMessages\n        } = (_a = collectionRef.current.instance) !== null && _a !== void 0 ? _a : {};\n        if (isNotEmptyArray(pendingMessages)) updateMessages(pendingMessages, false, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId);\n        if (isNotEmptyArray(failedMessages)) updateMessages(failedMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n      };\n      const collectionInstance = createMessageCollection(channelRef.current, limit, Object.assign(Object.assign({}, internalOptions.current), {\n        startingPoint\n      }));\n      collectionRef.current = {\n        apiInitialized: false,\n        initialized: false,\n        instance: collectionInstance\n      };\n      collectionInstance.setMessageCollectionHandler({\n        onMessagesAdded: (ctx, __, messages) => {\n          var _a;\n          markAsReadBySource(ctx.source);\n          updateNewMessagesReceived(ctx.source, messages);\n          updateMessages(messages, false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        },\n        onMessagesUpdated: (ctx, __, messages) => {\n          var _a, _b, _c;\n          markAsReadBySource(ctx.source);\n          updateNewMessagesReceived(ctx.source, messages); // NOTE: admin message is not added via onMessagesAdded handler, not checked yet is this a bug.\n          updateMessages(messages, false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n          if (ctx.source === CollectionEventSource.EVENT_MESSAGE_UPDATED) {\n            (_c = (_b = internalOptions.current).onMessagesUpdated) === null || _c === void 0 ? void 0 : _c.call(_b, messages);\n          }\n        },\n        onMessagesDeleted: (_, __, ___, messages) => {\n          const msgIds = messages.map(it => it.messageId);\n          const reqIds = messages.filter(isSendableMessage).map(it => it.reqId);\n          deleteMessages(msgIds, reqIds);\n          deleteNewMessages(msgIds, reqIds);\n        },\n        onChannelDeleted: (_, channelUrl) => {\n          var _a, _b;\n          (_b = (_a = internalOptions.current).onChannelDeleted) === null || _b === void 0 ? void 0 : _b.call(_a, channelUrl);\n        },\n        onChannelUpdated: (_, channel) => {\n          var _a, _b;\n          forceUpdate();\n          (_b = (_a = internalOptions.current).onChannelUpdated) === null || _b === void 0 ? void 0 : _b.call(_a, channel);\n        },\n        onHugeGapDetected: () => {\n          init(Number.MAX_SAFE_INTEGER, sbuConstants.collection.message.defaultLimit);\n        }\n      });\n      collectionInstance.initialize(MessageCollectionInitPolicy.CACHE_AND_REPLACE_BY_API).onCacheResult((err, messages) => {\n        var _a, _b, _c;\n        if (err) sdk.isCacheEnabled && ((_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages/onCacheResult]', err));else if (messages) {\n          (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelMessages/onCacheResult]', 'message length:', messages.length);\n          updateMessages(messages, true, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n          updateUnsentMessages();\n          // Note: If there are messages exchanged in the channel but no cached messages have been saved yet,\n          //  to prevent the API-retrieved messages from appearing immediately after the 'no messages' UI is displayed,\n          //  resolve only when there are messages present in the cache\n          if (messages.length > 0) {\n            collectionRef.current.initialized = true;\n            resolve();\n          }\n        }\n      }).onApiResult((err, messages) => {\n        var _a, _b, _c, _d, _e;\n        if (err) (_a = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages/onApiResult]', err);else if (messages) {\n          (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelMessages/onApiResult]', 'message length:', messages.length);\n          updateMessages(messages, true, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n          if (!internalOptions.current.startingPoint) (_e = (_d = internalOptions.current).onMessagesReceived) === null || _e === void 0 ? void 0 : _e.call(_d, messages);\n          if (sdk.isCacheEnabled) updateUnsentMessages();\n        }\n        collectionRef.current.initialized = true;\n        collectionRef.current.apiInitialized = true;\n        resolve();\n      });\n    });\n  }));\n  useGroupChannelHandler(sdk, {\n    onUserBanned(eventChannel, bannedUser) {\n      var _a, _b, _c;\n      if (eventChannel.isGroupChannel() && !isDifferentChannel(eventChannel, channelRef.current)) {\n        if (bannedUser.userId === ((_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId)) {\n          (_c = (_b = internalOptions.current).onCurrentUserBanned) === null || _c === void 0 ? void 0 : _c.call(_b);\n        } else {\n          forceUpdate();\n        }\n      }\n    }\n  });\n  useLayoutEffect(() => {\n    const timeout = setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {\n      if (sdk.currentUser && channelRef.current) {\n        updateInitialized(false);\n        updateLoading(true);\n        yield init(initialStartingPoint, initialLimit);\n        updateLoading(false);\n        updateInitialized(true);\n      }\n    }));\n    return () => clearTimeout(timeout);\n  }, [sdk, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId, (_c = channelRef.current) === null || _c === void 0 ? void 0 : _c.url, internalOptions.current.replyType]);\n  useEffect(() => {\n    return () => {\n      if (collectionRef.current.instance) collectionRef.current.instance.dispose();\n    };\n  }, []);\n  const refresh = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n    if (sdk.currentUser && channelRef.current) {\n      updateRefreshing(true);\n      yield init(Number.MAX_SAFE_INTEGER, sbuConstants.collection.message.defaultLimit);\n      updateRefreshing(false);\n    }\n  }));\n  const loadPrevious = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n    var _d;\n    const collection = collectionRef.current.instance;\n    if ((collection === null || collection === void 0 ? void 0 : collection.hasPrevious) && !isFetching.current.prev) {\n      try {\n        isFetching.current.prev = true;\n        const list = yield collection.loadPrevious();\n        updateMessages(list, false, (_d = sdk.currentUser) === null || _d === void 0 ? void 0 : _d.userId);\n      } catch (_e) {\n        // noop\n      } finally {\n        isFetching.current.prev = false;\n      }\n    }\n  }));\n  const hasPrevious = usePreservedCallback(() => {\n    const {\n      initialized,\n      instance\n    } = collectionRef.current;\n    if (initialized && instance) {\n      return instance.hasPrevious;\n    } else {\n      return false;\n    }\n  });\n  const loadNext = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n    var _f;\n    const collection = collectionRef.current.instance;\n    if ((collection === null || collection === void 0 ? void 0 : collection.hasNext) && !isFetching.current.next) {\n      try {\n        isFetching.current.next = true;\n        const list = yield collection.loadNext();\n        updateMessages(list, false, (_f = sdk.currentUser) === null || _f === void 0 ? void 0 : _f.userId);\n      } catch (_g) {\n        // noop\n      } finally {\n        isFetching.current.next = false;\n      }\n    }\n  }));\n  const hasNext = usePreservedCallback(() => {\n    // When the API is not initialized, the default value of collection.hasNext is true.\n    // Due to this, there is an issue with UI elements such as the scroll to bottom button appearing and disappearing.\n    // To address this, we additionally check the API initialized state.\n    const {\n      initialized,\n      apiInitialized,\n      instance\n    } = collectionRef.current;\n    if (apiInitialized && initialized && instance) {\n      return instance.hasNext;\n    } else {\n      return false;\n    }\n  });\n  const sendUserMessage = usePreservedCallback((params, onPending) => {\n    var _a;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise((resolve, reject) => {\n      channelRef.current.sendUserMessage(params).onPending(pendingMessage => {\n        var _a;\n        if (pendingMessage.channelUrl === channelRef.current.url) {\n          updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n      }).onSucceeded(sentMessage => {\n        var _a;\n        if (sentMessage.channelUrl === channelRef.current.url) {\n          updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        resolve(sentMessage);\n      }).onFailed((err, failedMessage) => {\n        var _a;\n        if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n          updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        reject(err);\n      });\n    });\n  });\n  const sendFileMessage = usePreservedCallback((params, onPending) => {\n    var _a;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise((resolve, reject) => {\n      channelRef.current.sendFileMessage(params).onPending(pendingMessage => {\n        var _a;\n        if (pendingMessage.channelUrl === channelRef.current.url) {\n          updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n      }).onSucceeded(sentMessage => {\n        var _a;\n        if (sentMessage.channelUrl === channelRef.current.url) {\n          updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        resolve(sentMessage);\n      }).onFailed((err, failedMessage) => {\n        var _a;\n        if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n          updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        reject(err);\n      });\n    });\n  });\n  const sendFileMessages = usePreservedCallback((paramsList, onPending) => __awaiter(void 0, void 0, void 0, function* () {\n    var _h;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_h = logger === null || logger === void 0 ? void 0 : logger.error) === null || _h === void 0 ? void 0 : _h.call(logger, '[useGroupChannelMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise(resolve => {\n      const messages = [];\n      channelRef.current.sendFileMessages(paramsList).onPending(pendingMessage => {\n        var _a;\n        if (pendingMessage.channelUrl === channelRef.current.url) {\n          updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n      }).onSucceeded(sentMessage => {\n        var _a;\n        if (sentMessage.isFileMessage() && sentMessage.channelUrl === channelRef.current.url) {\n          updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n          messages.push(sentMessage);\n        }\n        if (messages.length === paramsList.length) resolve(messages);\n      }).onFailed((_, failedMessage) => {\n        var _a;\n        if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n          updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n          messages.push(failedMessage);\n        } else {\n          // NOTE: Since failedMessage is nullable by type, to resolve the promise, handle pushing null even when there is no failedMessage.\n          messages.push(null);\n        }\n        if (messages.length === paramsList.length) resolve(messages);\n      });\n    });\n  }));\n  const sendMultipleFilesMessage = usePreservedCallback((params, onPending) => {\n    var _a;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise((resolve, reject) => {\n      channelRef.current.sendMultipleFilesMessage(params).onPending(pendingMessage => {\n        var _a;\n        if (pendingMessage.channelUrl === channelRef.current.url) {\n          updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n      }).onFileUploaded(() => {\n        // Just re-render to use updated message.messageParams\n        forceUpdate();\n      }).onSucceeded(sentMessage => {\n        var _a;\n        if (sentMessage.channelUrl === channelRef.current.url) {\n          updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        resolve(sentMessage);\n      }).onFailed((err, failedMessage) => {\n        var _a;\n        if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n          updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        reject(err);\n      });\n    });\n  });\n  const updateUserMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {\n    var _j, _k;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_j = logger === null || logger === void 0 ? void 0 : logger.error) === null || _j === void 0 ? void 0 : _j.call(logger, '[useGroupChannelMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    const updatedMessage = yield channelRef.current.updateUserMessage(messageId, params);\n    if (updatedMessage.channelUrl === channelRef.current.url) {\n      updateMessages([updatedMessage], false, (_k = sdk.currentUser) === null || _k === void 0 ? void 0 : _k.userId);\n    }\n    return updatedMessage;\n  }));\n  const updateFileMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {\n    var _l, _m;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_l = logger === null || logger === void 0 ? void 0 : logger.error) === null || _l === void 0 ? void 0 : _l.call(logger, '[useGroupChannelMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    const updatedMessage = yield channelRef.current.updateFileMessage(messageId, params);\n    if (updatedMessage.channelUrl === channelRef.current.url) {\n      updateMessages([updatedMessage], false, (_m = sdk.currentUser) === null || _m === void 0 ? void 0 : _m.userId);\n    }\n    return updatedMessage;\n  }));\n  const resendMessage = usePreservedCallback(failedMessage => __awaiter(void 0, void 0, void 0, function* () {\n    var _o;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_o = logger === null || logger === void 0 ? void 0 : logger.error) === null || _o === void 0 ? void 0 : _o.call(logger, '[useGroupChannelMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise((resolve, reject) => {\n      let handler = undefined;\n      if (failedMessage.isUserMessage()) handler = channelRef.current.resendMessage(failedMessage);\n      if (failedMessage.isFileMessage()) handler = channelRef.current.resendMessage(failedMessage);\n      if (failedMessage.isMultipleFilesMessage()) handler = channelRef.current.resendMessage(failedMessage);\n      if (handler) {\n        if ('onPending' in handler) {\n          handler.onPending(message => {\n            var _a;\n            if (message.channelUrl === channelRef.current.url) {\n              updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n            }\n          });\n        }\n        if ('onFileUploaded' in handler) {\n          handler.onFileUploaded(() => {\n            // Just re-render to use updated message.messageParams\n            forceUpdate();\n          });\n        }\n        if ('onSucceeded' in handler) {\n          handler.onSucceeded(message => {\n            var _a;\n            if (message.channelUrl === channelRef.current.url) {\n              updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n            }\n            resolve(message);\n          });\n        }\n        if ('onFailed' in handler) {\n          handler.onFailed((err, message) => {\n            var _a;\n            if (message && message.channelUrl === channelRef.current.url) {\n              updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n            }\n            reject(err);\n          });\n        }\n      }\n    });\n  }));\n  const deleteMessage = usePreservedCallback(message => __awaiter(void 0, void 0, void 0, function* () {\n    var _p, _q;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_p = logger === null || logger === void 0 ? void 0 : logger.error) === null || _p === void 0 ? void 0 : _p.call(logger, '[useGroupChannelMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    if (message.sendingStatus === 'succeeded') {\n      if (message.isUserMessage()) yield channelRef.current.deleteMessage(message);\n      if (message.isFileMessage()) yield channelRef.current.deleteMessage(message);\n      if (message.isMultipleFilesMessage()) yield channelRef.current.deleteMessage(message);\n    } else {\n      try {\n        yield (_q = collectionRef.current.instance) === null || _q === void 0 ? void 0 : _q.removeFailedMessage(message.reqId);\n      } finally {\n        deleteMessages([message.messageId], [message.reqId]);\n      }\n    }\n  }));\n  const resetNewMessages = usePreservedCallback(() => {\n    var _a;\n    updateNewMessages([], true, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n  });\n  const resetWithStartingPoint = usePreservedCallback(startingPoint => __awaiter(void 0, void 0, void 0, function* () {\n    var _r;\n    if (sdk.currentUser && channelRef.current) {\n      const limit = getCollectionLimitBy(startingPoint);\n      updateLoading(true);\n      updateMessages([], true, (_r = sdk.currentUser) === null || _r === void 0 ? void 0 : _r.userId);\n      yield init(startingPoint, limit);\n      updateLoading(false);\n    }\n  }));\n  return {\n    /**\n     * Initialized state, only available on first render\n     * */\n    initialized,\n    /**\n     * Loading state, status is changes on first mount or when the resetWithStartingPoint is called.\n     * */\n    loading,\n    /**\n     * Refreshing state, status is changes when the refresh is called.\n     * */\n    refreshing,\n    /**\n     * Get messages, this state is for render\n     * For example, if a user receives a new messages while searching for an old message\n     * for this case, new messages will be included here.\n     * */\n    messages,\n    /**\n     * If the `shouldCountNewMessages()` is true, only then push in the newMessages state.\n     * (Return false for the `shouldCountNewMessages()` if the message scroll is the most recent; otherwise, return true.)\n     *\n     * A new message means a message that meets the below conditions\n     * - Not admin message\n     * - Not updated message\n     * - Not current user's message\n     * */\n    newMessages,\n    /**\n     * Reset new message list\n     * @return {void}\n     * */\n    resetNewMessages,\n    /**\n     * Reset message list and create a new collection for latest messages\n     * @return {Promise<void>}\n     * */\n    refresh,\n    /**\n     * Load previous messages to state\n     * @return {Promise<void>}\n     * */\n    loadPrevious,\n    /**\n     * Check if there are more previous messages to fetch\n     * @return {boolean}\n     * */\n    hasPrevious,\n    /**\n     * Load next messages to state\n     * @return {Promise<void>}\n     * */\n    loadNext,\n    /**\n     * Check if there are more next messages to fetch\n     * @return {boolean}\n     * */\n    hasNext,\n    /**\n     * Send user message\n     * @param {UserMessageCreateParams} params user message create params\n     * @param {function} [onPending] pending message callback\n     * @return {Promise<UserMessage>} succeeded message\n     * */\n    sendUserMessage,\n    /**\n     * Send file message\n     * @param {FileMessageCreateParams} params file message create params\n     * @param {function} [onPending] pending message callback\n     * @return {Promise<FileMessage>} succeeded message\n     * */\n    sendFileMessage,\n    /**\n     * Send file messages\n     * @param {FileMessageCreateParams[]} paramList file message create params\n     * @param {function} [onPending] pending message callback for each message request\n     * @return {Promise<FileMessage[]>} succeeded or failed message\n     * */\n    sendFileMessages,\n    /**\n     * Send multiple files message\n     * @param {MultipleFilesMessageCreateParams} params multiple files message create params\n     * @param {function} [onPending] pending message callback\n     * @return {Promise<MultipleFilesMessage>} succeeded message\n     * */\n    sendMultipleFilesMessage,\n    /**\n     * Update user message\n     * @param {number} messageId\n     * @param {UserMessageUpdateParams} params user message update params\n     * @return {Promise<UserMessage>}\n     * */\n    updateUserMessage,\n    /**\n     * Update file message\n     * @param {number} messageId\n     * @param {FileMessageUpdateParams} params file message update params\n     * @return {Promise<FileMessage>}\n     * */\n    updateFileMessage,\n    /**\n     * Resend failed message\n     * @template {UserMessage | FileMessage | MultipleFilesMessage} T\n     * @param {T} failedMessage message to resend\n     * @return {Promise<T>}\n     * */\n    resendMessage,\n    /**\n     * Delete a message\n     * @template {UserMessage | FileMessage | MultipleFilesMessage} T\n     * @param {T} message succeeded or failed message\n     * @return {Promise<void>}\n     * */\n    deleteMessage,\n    /**\n     * Reset message list and create a new collection with starting point\n     * @param {number} startingPoint\n     * @param {function} callback\n     * @return {void}\n     * */\n    resetWithStartingPoint,\n    /**\n     * Do not use this api\n     * */\n    _dangerous_reducer_updateMessages: updateMessages,\n    /**\n     * Do not use this api\n     * */\n    _dangerous_reducer_deleteMessages: deleteMessages\n  };\n};","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","useEffect","useLayoutEffect","useRef","CollectionEventSource","MessageCollectionInitPolicy","MessageFilter","sbuConstants","isDifferentChannel","isMyMessage","isSendableMessage","isNotEmptyArray","useForceUpdate","useGroupChannelHandler","usePreservedCallback","useChannelMessagesReducer","createMessageCollection","channel","limit","options","_a","basicParams","prevResultLimit","prev","nextResultLimit","startingPoint","replyType","passedCollection","collectionCreator","call","Object","assign","filter","getCollectionLimitBy","Date","now","collection","message","searchLimit","defaultLimit","useGroupChannelMessages","sdk","_b","_c","internalOptions","current","channelRef","logger","initialStartingPoint","Number","MAX_SAFE_INTEGER","initialLimit","isFetching","forceUpdate","collectionRef","initialized","apiInitialized","instance","loading","refreshing","messages","newMessages","updateMessages","updateNewMessages","deleteNewMessages","deleteMessages","updateInitialized","updateLoading","updateRefreshing","sortComparator","markAsReadBySource","source","_d","url","error","EVENT_MESSAGE_RECEIVED","EVENT_MESSAGE_SENT_SUCCESS","SYNC_MESSAGE_FILL","undefined","markAsRead","warn","updateNewMessagesReceived","_e","incomingMessages","it","currentUser","userId","length","shouldCountNewMessages","onMessagesReceived","init","dispose","updateUnsentMessages","pendingMessages","failedMessages","collectionInstance","setMessageCollectionHandler","onMessagesAdded","ctx","__","onMessagesUpdated","EVENT_MESSAGE_UPDATED","onMessagesDeleted","_","___","msgIds","map","messageId","reqIds","reqId","onChannelDeleted","channelUrl","onChannelUpdated","onHugeGapDetected","initialize","CACHE_AND_REPLACE_BY_API","onCacheResult","err","isCacheEnabled","debug","onApiResult","onUserBanned","eventChannel","bannedUser","isGroupChannel","onCurrentUserBanned","timeout","setTimeout","clearTimeout","refresh","loadPrevious","hasPrevious","list","loadNext","_f","hasNext","_g","sendUserMessage","params","onPending","Error","pendingMessage","onSucceeded","sentMessage","onFailed","failedMessage","sendFileMessage","sendFileMessages","paramsList","_h","isFileMessage","push","sendMultipleFilesMessage","onFileUploaded","updateUserMessage","_j","_k","updatedMessage","updateFileMessage","_l","_m","resendMessage","_o","handler","isUserMessage","isMultipleFilesMessage","deleteMessage","_p","_q","sendingStatus","removeFailedMessage","resetNewMessages","resetWithStartingPoint","_r","_dangerous_reducer_updateMessages","_dangerous_reducer_deleteMessages"],"sources":["D:/ebgbot/node_modules/@sendbird/uikit-react/node_modules/@sendbird/uikit-tools/dist/esm/hooks/useGroupChannelMessages/index.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { useEffect, useLayoutEffect, useRef } from 'react';\nimport { CollectionEventSource } from '@sendbird/chat';\nimport { MessageCollectionInitPolicy, MessageFilter } from '@sendbird/chat/groupChannel';\nimport { sbuConstants } from '../../constants/sbuConstants.js';\nimport { isDifferentChannel } from '../../utils/channel.js';\nimport { isMyMessage, isSendableMessage } from '../../utils/message.js';\nimport { isNotEmptyArray } from '../../utils/validators.js';\nimport { useForceUpdate } from '../useForceUpdate.js';\nimport { useGroupChannelHandler } from '../useGroupChannelHandler.js';\nimport { usePreservedCallback } from '../usePreservedCallback.js';\nimport { useChannelMessagesReducer } from './reducer.js';\nconst createMessageCollection = (channel, limit, options) => {\n    var _a;\n    const basicParams = {\n        prevResultLimit: limit.prev,\n        nextResultLimit: limit.next,\n        startingPoint: options === null || options === void 0 ? void 0 : options.startingPoint,\n        replyType: options === null || options === void 0 ? void 0 : options.replyType,\n    };\n    const passedCollection = (_a = options === null || options === void 0 ? void 0 : options.collectionCreator) === null || _a === void 0 ? void 0 : _a.call(options, basicParams);\n    if (passedCollection)\n        return passedCollection;\n    return channel.createMessageCollection(Object.assign(Object.assign({}, basicParams), { filter: new MessageFilter(basicParams) }));\n};\n// NOTE: In React-Native's FlatList, the bidirectional message loading doesn't work reliably, causing a bug\n//  where scrolling jumps to a random position when loading a large number of messages at once.\n//  Therefore, in the message search that explores past messages, a small number of messages is loaded to address this issue.\nfunction getCollectionLimitBy(startingPoint) {\n    return startingPoint < Date.now()\n        ? sbuConstants.collection.message.searchLimit\n        : sbuConstants.collection.message.defaultLimit;\n}\n/**\n * group channel messages hook\n * - Receive new messages from other users & should count new messages -> append to state(newMessages)\n * - onTopReached -> prev() -> fetch prev messages and append to state(messages)\n * - onBottomReached -> next() -> fetch next messages and append to state(messages)\n * */\nexport const useGroupChannelMessages = (sdk, channel, options = {}) => {\n    var _a, _b, _c;\n    const internalOptions = useRef(options); // to keep reference of options in event handler\n    internalOptions.current = options;\n    const channelRef = useRef(channel); // to keep reference of channel in event handler\n    channelRef.current = channel;\n    const logger = internalOptions.current.logger;\n    const initialStartingPoint = (_a = internalOptions.current.startingPoint) !== null && _a !== void 0 ? _a : Number.MAX_SAFE_INTEGER;\n    const initialLimit = getCollectionLimitBy(initialStartingPoint);\n    const isFetching = useRef({ prev: false, next: false });\n    const forceUpdate = useForceUpdate();\n    const collectionRef = useRef({\n        initialized: false,\n        apiInitialized: false,\n        instance: null,\n    });\n    const { initialized, loading, refreshing, messages, newMessages, updateMessages, updateNewMessages, deleteNewMessages, deleteMessages, updateInitialized, updateLoading, updateRefreshing, } = useChannelMessagesReducer(options === null || options === void 0 ? void 0 : options.sortComparator);\n    const markAsReadBySource = usePreservedCallback((source) => {\n        var _a, _b, _c, _d;\n        if (!channelRef.current || !channelRef.current.url)\n            return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n        try {\n            switch (source) {\n                case CollectionEventSource.EVENT_MESSAGE_RECEIVED:\n                case CollectionEventSource.EVENT_MESSAGE_SENT_SUCCESS:\n                case CollectionEventSource.SYNC_MESSAGE_FILL:\n                case undefined:\n                    (_c = (_b = internalOptions.current).markAsRead) === null || _c === void 0 ? void 0 : _c.call(_b, [channelRef.current]);\n                    break;\n            }\n        }\n        catch (e) {\n            (_d = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _d === void 0 ? void 0 : _d.call(logger, '[useGroupChannelMessages/markAsReadBySource]', e);\n        }\n    });\n    const updateNewMessagesReceived = usePreservedCallback((source, messages) => {\n        var _a, _b, _c, _d, _e;\n        const incomingMessages = messages.filter((it) => { var _a; return !isMyMessage(it, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId); });\n        if (incomingMessages.length > 0) {\n            switch (source) {\n                case CollectionEventSource.EVENT_MESSAGE_RECEIVED:\n                case CollectionEventSource.SYNC_MESSAGE_FILL: {\n                    if ((_b = (_a = internalOptions.current).shouldCountNewMessages) === null || _b === void 0 ? void 0 : _b.call(_a)) {\n                        updateNewMessages(incomingMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n                    }\n                    (_e = (_d = internalOptions.current).onMessagesReceived) === null || _e === void 0 ? void 0 : _e.call(_d, incomingMessages);\n                    break;\n                }\n            }\n        }\n    });\n    const init = usePreservedCallback((startingPoint, limit) => __awaiter(void 0, void 0, void 0, function* () {\n        return new Promise((resolve) => {\n            var _a, _b;\n            if (!channelRef.current || !channelRef.current.url)\n                return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n            if (collectionRef.current.instance)\n                collectionRef.current.instance.dispose();\n            markAsReadBySource();\n            updateNewMessages([], true, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId);\n            const updateUnsentMessages = () => {\n                var _a, _b, _c;\n                const { pendingMessages, failedMessages } = (_a = collectionRef.current.instance) !== null && _a !== void 0 ? _a : {};\n                if (isNotEmptyArray(pendingMessages))\n                    updateMessages(pendingMessages, false, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId);\n                if (isNotEmptyArray(failedMessages))\n                    updateMessages(failedMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n            };\n            const collectionInstance = createMessageCollection(channelRef.current, limit, Object.assign(Object.assign({}, internalOptions.current), { startingPoint }));\n            collectionRef.current = { apiInitialized: false, initialized: false, instance: collectionInstance };\n            collectionInstance.setMessageCollectionHandler({\n                onMessagesAdded: (ctx, __, messages) => {\n                    var _a;\n                    markAsReadBySource(ctx.source);\n                    updateNewMessagesReceived(ctx.source, messages);\n                    updateMessages(messages, false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                },\n                onMessagesUpdated: (ctx, __, messages) => {\n                    var _a, _b, _c;\n                    markAsReadBySource(ctx.source);\n                    updateNewMessagesReceived(ctx.source, messages); // NOTE: admin message is not added via onMessagesAdded handler, not checked yet is this a bug.\n                    updateMessages(messages, false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                    if (ctx.source === CollectionEventSource.EVENT_MESSAGE_UPDATED) {\n                        (_c = (_b = internalOptions.current).onMessagesUpdated) === null || _c === void 0 ? void 0 : _c.call(_b, messages);\n                    }\n                },\n                onMessagesDeleted: (_, __, ___, messages) => {\n                    const msgIds = messages.map((it) => it.messageId);\n                    const reqIds = messages.filter(isSendableMessage).map((it) => it.reqId);\n                    deleteMessages(msgIds, reqIds);\n                    deleteNewMessages(msgIds, reqIds);\n                },\n                onChannelDeleted: (_, channelUrl) => {\n                    var _a, _b;\n                    (_b = (_a = internalOptions.current).onChannelDeleted) === null || _b === void 0 ? void 0 : _b.call(_a, channelUrl);\n                },\n                onChannelUpdated: (_, channel) => {\n                    var _a, _b;\n                    forceUpdate();\n                    (_b = (_a = internalOptions.current).onChannelUpdated) === null || _b === void 0 ? void 0 : _b.call(_a, channel);\n                },\n                onHugeGapDetected: () => {\n                    init(Number.MAX_SAFE_INTEGER, sbuConstants.collection.message.defaultLimit);\n                },\n            });\n            collectionInstance\n                .initialize(MessageCollectionInitPolicy.CACHE_AND_REPLACE_BY_API)\n                .onCacheResult((err, messages) => {\n                var _a, _b, _c;\n                if (err)\n                    sdk.isCacheEnabled && ((_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages/onCacheResult]', err));\n                else if (messages) {\n                    (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelMessages/onCacheResult]', 'message length:', messages.length);\n                    updateMessages(messages, true, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n                    updateUnsentMessages();\n                    // Note: If there are messages exchanged in the channel but no cached messages have been saved yet,\n                    //  to prevent the API-retrieved messages from appearing immediately after the 'no messages' UI is displayed,\n                    //  resolve only when there are messages present in the cache\n                    if (messages.length > 0) {\n                        collectionRef.current.initialized = true;\n                        resolve();\n                    }\n                }\n            })\n                .onApiResult((err, messages) => {\n                var _a, _b, _c, _d, _e;\n                if (err)\n                    (_a = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages/onApiResult]', err);\n                else if (messages) {\n                    (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelMessages/onApiResult]', 'message length:', messages.length);\n                    updateMessages(messages, true, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n                    if (!internalOptions.current.startingPoint)\n                        (_e = (_d = internalOptions.current).onMessagesReceived) === null || _e === void 0 ? void 0 : _e.call(_d, messages);\n                    if (sdk.isCacheEnabled)\n                        updateUnsentMessages();\n                }\n                collectionRef.current.initialized = true;\n                collectionRef.current.apiInitialized = true;\n                resolve();\n            });\n        });\n    }));\n    useGroupChannelHandler(sdk, {\n        onUserBanned(eventChannel, bannedUser) {\n            var _a, _b, _c;\n            if (eventChannel.isGroupChannel() && !isDifferentChannel(eventChannel, channelRef.current)) {\n                if (bannedUser.userId === ((_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId)) {\n                    (_c = (_b = internalOptions.current).onCurrentUserBanned) === null || _c === void 0 ? void 0 : _c.call(_b);\n                }\n                else {\n                    forceUpdate();\n                }\n            }\n        },\n    });\n    useLayoutEffect(() => {\n        const timeout = setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {\n            if (sdk.currentUser && channelRef.current) {\n                updateInitialized(false);\n                updateLoading(true);\n                yield init(initialStartingPoint, initialLimit);\n                updateLoading(false);\n                updateInitialized(true);\n            }\n        }));\n        return () => clearTimeout(timeout);\n    }, [sdk, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId, (_c = channelRef.current) === null || _c === void 0 ? void 0 : _c.url, internalOptions.current.replyType]);\n    useEffect(() => {\n        return () => {\n            if (collectionRef.current.instance)\n                collectionRef.current.instance.dispose();\n        };\n    }, []);\n    const refresh = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        if (sdk.currentUser && channelRef.current) {\n            updateRefreshing(true);\n            yield init(Number.MAX_SAFE_INTEGER, sbuConstants.collection.message.defaultLimit);\n            updateRefreshing(false);\n        }\n    }));\n    const loadPrevious = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        var _d;\n        const collection = collectionRef.current.instance;\n        if ((collection === null || collection === void 0 ? void 0 : collection.hasPrevious) && !isFetching.current.prev) {\n            try {\n                isFetching.current.prev = true;\n                const list = yield collection.loadPrevious();\n                updateMessages(list, false, (_d = sdk.currentUser) === null || _d === void 0 ? void 0 : _d.userId);\n            }\n            catch (_e) {\n                // noop\n            }\n            finally {\n                isFetching.current.prev = false;\n            }\n        }\n    }));\n    const hasPrevious = usePreservedCallback(() => {\n        const { initialized, instance } = collectionRef.current;\n        if (initialized && instance) {\n            return instance.hasPrevious;\n        }\n        else {\n            return false;\n        }\n    });\n    const loadNext = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        var _f;\n        const collection = collectionRef.current.instance;\n        if ((collection === null || collection === void 0 ? void 0 : collection.hasNext) && !isFetching.current.next) {\n            try {\n                isFetching.current.next = true;\n                const list = yield collection.loadNext();\n                updateMessages(list, false, (_f = sdk.currentUser) === null || _f === void 0 ? void 0 : _f.userId);\n            }\n            catch (_g) {\n                // noop\n            }\n            finally {\n                isFetching.current.next = false;\n            }\n        }\n    }));\n    const hasNext = usePreservedCallback(() => {\n        // When the API is not initialized, the default value of collection.hasNext is true.\n        // Due to this, there is an issue with UI elements such as the scroll to bottom button appearing and disappearing.\n        // To address this, we additionally check the API initialized state.\n        const { initialized, apiInitialized, instance } = collectionRef.current;\n        if (apiInitialized && initialized && instance) {\n            return instance.hasNext;\n        }\n        else {\n            return false;\n        }\n    });\n    const sendUserMessage = usePreservedCallback((params, onPending) => {\n        var _a;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve, reject) => {\n            channelRef.current\n                .sendUserMessage(params)\n                .onPending((pendingMessage) => {\n                var _a;\n                if (pendingMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n            })\n                .onSucceeded((sentMessage) => {\n                var _a;\n                if (sentMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                resolve(sentMessage);\n            })\n                .onFailed((err, failedMessage) => {\n                var _a;\n                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                reject(err);\n            });\n        });\n    });\n    const sendFileMessage = usePreservedCallback((params, onPending) => {\n        var _a;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve, reject) => {\n            channelRef.current\n                .sendFileMessage(params)\n                .onPending((pendingMessage) => {\n                var _a;\n                if (pendingMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n            })\n                .onSucceeded((sentMessage) => {\n                var _a;\n                if (sentMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                resolve(sentMessage);\n            })\n                .onFailed((err, failedMessage) => {\n                var _a;\n                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                reject(err);\n            });\n        });\n    });\n    const sendFileMessages = usePreservedCallback((paramsList, onPending) => __awaiter(void 0, void 0, void 0, function* () {\n        var _h;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_h = logger === null || logger === void 0 ? void 0 : logger.error) === null || _h === void 0 ? void 0 : _h.call(logger, '[useGroupChannelMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve) => {\n            const messages = [];\n            channelRef.current\n                .sendFileMessages(paramsList)\n                .onPending((pendingMessage) => {\n                var _a;\n                if (pendingMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n            })\n                .onSucceeded((sentMessage) => {\n                var _a;\n                if (sentMessage.isFileMessage() && sentMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                    messages.push(sentMessage);\n                }\n                if (messages.length === paramsList.length)\n                    resolve(messages);\n            })\n                .onFailed((_, failedMessage) => {\n                var _a;\n                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                    messages.push(failedMessage);\n                }\n                else {\n                    // NOTE: Since failedMessage is nullable by type, to resolve the promise, handle pushing null even when there is no failedMessage.\n                    messages.push(null);\n                }\n                if (messages.length === paramsList.length)\n                    resolve(messages);\n            });\n        });\n    }));\n    const sendMultipleFilesMessage = usePreservedCallback((params, onPending) => {\n        var _a;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve, reject) => {\n            channelRef.current\n                .sendMultipleFilesMessage(params)\n                .onPending((pendingMessage) => {\n                var _a;\n                if (pendingMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n            })\n                .onFileUploaded(() => {\n                // Just re-render to use updated message.messageParams\n                forceUpdate();\n            })\n                .onSucceeded((sentMessage) => {\n                var _a;\n                if (sentMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                resolve(sentMessage);\n            })\n                .onFailed((err, failedMessage) => {\n                var _a;\n                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                reject(err);\n            });\n        });\n    });\n    const updateUserMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {\n        var _j, _k;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_j = logger === null || logger === void 0 ? void 0 : logger.error) === null || _j === void 0 ? void 0 : _j.call(logger, '[useGroupChannelMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        const updatedMessage = yield channelRef.current.updateUserMessage(messageId, params);\n        if (updatedMessage.channelUrl === channelRef.current.url) {\n            updateMessages([updatedMessage], false, (_k = sdk.currentUser) === null || _k === void 0 ? void 0 : _k.userId);\n        }\n        return updatedMessage;\n    }));\n    const updateFileMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {\n        var _l, _m;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_l = logger === null || logger === void 0 ? void 0 : logger.error) === null || _l === void 0 ? void 0 : _l.call(logger, '[useGroupChannelMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        const updatedMessage = yield channelRef.current.updateFileMessage(messageId, params);\n        if (updatedMessage.channelUrl === channelRef.current.url) {\n            updateMessages([updatedMessage], false, (_m = sdk.currentUser) === null || _m === void 0 ? void 0 : _m.userId);\n        }\n        return updatedMessage;\n    }));\n    const resendMessage = usePreservedCallback((failedMessage) => __awaiter(void 0, void 0, void 0, function* () {\n        var _o;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_o = logger === null || logger === void 0 ? void 0 : logger.error) === null || _o === void 0 ? void 0 : _o.call(logger, '[useGroupChannelMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve, reject) => {\n            let handler = undefined;\n            if (failedMessage.isUserMessage())\n                handler = channelRef.current.resendMessage(failedMessage);\n            if (failedMessage.isFileMessage())\n                handler = channelRef.current.resendMessage(failedMessage);\n            if (failedMessage.isMultipleFilesMessage())\n                handler = channelRef.current.resendMessage(failedMessage);\n            if (handler) {\n                if ('onPending' in handler) {\n                    handler.onPending((message) => {\n                        var _a;\n                        if (message.channelUrl === channelRef.current.url) {\n                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                        }\n                    });\n                }\n                if ('onFileUploaded' in handler) {\n                    handler.onFileUploaded(() => {\n                        // Just re-render to use updated message.messageParams\n                        forceUpdate();\n                    });\n                }\n                if ('onSucceeded' in handler) {\n                    handler.onSucceeded((message) => {\n                        var _a;\n                        if (message.channelUrl === channelRef.current.url) {\n                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                        }\n                        resolve(message);\n                    });\n                }\n                if ('onFailed' in handler) {\n                    handler.onFailed((err, message) => {\n                        var _a;\n                        if (message && message.channelUrl === channelRef.current.url) {\n                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                        }\n                        reject(err);\n                    });\n                }\n            }\n        });\n    }));\n    const deleteMessage = usePreservedCallback((message) => __awaiter(void 0, void 0, void 0, function* () {\n        var _p, _q;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_p = logger === null || logger === void 0 ? void 0 : logger.error) === null || _p === void 0 ? void 0 : _p.call(logger, '[useGroupChannelMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        if (message.sendingStatus === 'succeeded') {\n            if (message.isUserMessage())\n                yield channelRef.current.deleteMessage(message);\n            if (message.isFileMessage())\n                yield channelRef.current.deleteMessage(message);\n            if (message.isMultipleFilesMessage())\n                yield channelRef.current.deleteMessage(message);\n        }\n        else {\n            try {\n                yield ((_q = collectionRef.current.instance) === null || _q === void 0 ? void 0 : _q.removeFailedMessage(message.reqId));\n            }\n            finally {\n                deleteMessages([message.messageId], [message.reqId]);\n            }\n        }\n    }));\n    const resetNewMessages = usePreservedCallback(() => {\n        var _a;\n        updateNewMessages([], true, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n    });\n    const resetWithStartingPoint = usePreservedCallback((startingPoint) => __awaiter(void 0, void 0, void 0, function* () {\n        var _r;\n        if (sdk.currentUser && channelRef.current) {\n            const limit = getCollectionLimitBy(startingPoint);\n            updateLoading(true);\n            updateMessages([], true, (_r = sdk.currentUser) === null || _r === void 0 ? void 0 : _r.userId);\n            yield init(startingPoint, limit);\n            updateLoading(false);\n        }\n    }));\n    return {\n        /**\n         * Initialized state, only available on first render\n         * */\n        initialized,\n        /**\n         * Loading state, status is changes on first mount or when the resetWithStartingPoint is called.\n         * */\n        loading,\n        /**\n         * Refreshing state, status is changes when the refresh is called.\n         * */\n        refreshing,\n        /**\n         * Get messages, this state is for render\n         * For example, if a user receives a new messages while searching for an old message\n         * for this case, new messages will be included here.\n         * */\n        messages,\n        /**\n         * If the `shouldCountNewMessages()` is true, only then push in the newMessages state.\n         * (Return false for the `shouldCountNewMessages()` if the message scroll is the most recent; otherwise, return true.)\n         *\n         * A new message means a message that meets the below conditions\n         * - Not admin message\n         * - Not updated message\n         * - Not current user's message\n         * */\n        newMessages,\n        /**\n         * Reset new message list\n         * @return {void}\n         * */\n        resetNewMessages,\n        /**\n         * Reset message list and create a new collection for latest messages\n         * @return {Promise<void>}\n         * */\n        refresh,\n        /**\n         * Load previous messages to state\n         * @return {Promise<void>}\n         * */\n        loadPrevious,\n        /**\n         * Check if there are more previous messages to fetch\n         * @return {boolean}\n         * */\n        hasPrevious,\n        /**\n         * Load next messages to state\n         * @return {Promise<void>}\n         * */\n        loadNext,\n        /**\n         * Check if there are more next messages to fetch\n         * @return {boolean}\n         * */\n        hasNext,\n        /**\n         * Send user message\n         * @param {UserMessageCreateParams} params user message create params\n         * @param {function} [onPending] pending message callback\n         * @return {Promise<UserMessage>} succeeded message\n         * */\n        sendUserMessage,\n        /**\n         * Send file message\n         * @param {FileMessageCreateParams} params file message create params\n         * @param {function} [onPending] pending message callback\n         * @return {Promise<FileMessage>} succeeded message\n         * */\n        sendFileMessage,\n        /**\n         * Send file messages\n         * @param {FileMessageCreateParams[]} paramList file message create params\n         * @param {function} [onPending] pending message callback for each message request\n         * @return {Promise<FileMessage[]>} succeeded or failed message\n         * */\n        sendFileMessages,\n        /**\n         * Send multiple files message\n         * @param {MultipleFilesMessageCreateParams} params multiple files message create params\n         * @param {function} [onPending] pending message callback\n         * @return {Promise<MultipleFilesMessage>} succeeded message\n         * */\n        sendMultipleFilesMessage,\n        /**\n         * Update user message\n         * @param {number} messageId\n         * @param {UserMessageUpdateParams} params user message update params\n         * @return {Promise<UserMessage>}\n         * */\n        updateUserMessage,\n        /**\n         * Update file message\n         * @param {number} messageId\n         * @param {FileMessageUpdateParams} params file message update params\n         * @return {Promise<FileMessage>}\n         * */\n        updateFileMessage,\n        /**\n         * Resend failed message\n         * @template {UserMessage | FileMessage | MultipleFilesMessage} T\n         * @param {T} failedMessage message to resend\n         * @return {Promise<T>}\n         * */\n        resendMessage,\n        /**\n         * Delete a message\n         * @template {UserMessage | FileMessage | MultipleFilesMessage} T\n         * @param {T} message succeeded or failed message\n         * @return {Promise<void>}\n         * */\n        deleteMessage,\n        /**\n         * Reset message list and create a new collection with starting point\n         * @param {number} startingPoint\n         * @param {function} callback\n         * @return {void}\n         * */\n        resetWithStartingPoint,\n        /**\n         * Do not use this api\n         * */\n        _dangerous_reducer_updateMessages: updateMessages,\n        /**\n         * Do not use this api\n         * */\n        _dangerous_reducer_deleteMessages: deleteMessages,\n    };\n};\n"],"mappings":"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G,CAAC4C,WAAW,MAAM,IAAI,IAAIwF,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACvF,MAAM,CAAC;MAC/F,MAAMI,IAAI,CAACjE,aAAa,EAAEP,KAAK,CAAC;MAChCiD,aAAa,CAAC,KAAK,CAAC;IACxB;EACJ,CAAC,CAAC,CAAC;EACH,OAAO;IACH;AACR;AACA;IACQZ,WAAW;IACX;AACR;AACA;IACQG,OAAO;IACP;AACR;AACA;IACQC,UAAU;IACV;AACR;AACA;AACA;AACA;IACQC,QAAQ;IACR;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQC,WAAW;IACX;AACR;AACA;AACA;IACQ8G,gBAAgB;IAChB;AACR;AACA;AACA;IACQ1C,OAAO;IACP;AACR;AACA;AACA;IACQC,YAAY;IACZ;AACR;AACA;AACA;IACQC,WAAW;IACX;AACR;AACA;AACA;IACQE,QAAQ;IACR;AACR;AACA;AACA;IACQE,OAAO;IACP;AACR;AACA;AACA;AACA;AACA;IACQE,eAAe;IACf;AACR;AACA;AACA;AACA;AACA;IACQS,eAAe;IACf;AACR;AACA;AACA;AACA;AACA;IACQC,gBAAgB;IAChB;AACR;AACA;AACA;AACA;AACA;IACQK,wBAAwB;IACxB;AACR;AACA;AACA;AACA;AACA;IACQE,iBAAiB;IACjB;AACR;AACA;AACA;AACA;AACA;IACQI,iBAAiB;IACjB;AACR;AACA;AACA;AACA;AACA;IACQG,aAAa;IACb;AACR;AACA;AACA;AACA;AACA;IACQK,aAAa;IACb;AACR;AACA;AACA;AACA;AACA;IACQM,sBAAsB;IACtB;AACR;AACA;IACQE,iCAAiC,EAAEhH,cAAc;IACjD;AACR;AACA;IACQiH,iCAAiC,EAAE9G;EACvC,CAAC;AACL,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module"}