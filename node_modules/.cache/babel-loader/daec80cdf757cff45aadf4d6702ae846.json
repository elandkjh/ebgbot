{"ast":null,"code":"import React__default, { useEffect, useCallback, useState, useReducer, useRef, useMemo } from 'react';\nimport { U as UserProfileProvider } from './bundle-BrTJ5Zbd.js';\nimport { _ as __assign, c as __spreadArray, a as __awaiter, b as __generator } from './bundle-BQi9-O76.js';\nimport { c as compareIds } from './bundle-CZUYMubi.js';\nimport { p as pubSubTopics } from './bundle-b6TpX_JP.js';\nimport { ChannelType } from '@sendbird/chat';\nimport { OpenChannelHandler } from '@sendbird/chat/openChannel';\nimport { u as uuidv4 } from './bundle-etuaqevl.js';\nimport { c as compressImages } from './bundle-DAz5E5O_.js';\nimport { useSendbirdStateContext } from '../useSendbirdStateContext.js';\nimport { b as useGlobalModalContext, c as ModalFooter } from './bundle-CXdo2kR_.js';\nimport { u as useLocalization } from './bundle-cQZ3UZoG.js';\nimport { O as ONE_MiB } from './bundle-DCMGp6rH.js';\nimport './bundle-DhKQeIfP.js';\nimport { ButtonTypes } from '../ui/Button.js';\nvar shouldFetchMore = function (messageLength, maxMessages) {\n  if (typeof maxMessages !== 'number') {\n    return true;\n  }\n  return maxMessages > messageLength;\n};\n/* eslint-disable default-param-last */\nvar scrollIntoLast = function (initialTry, scrollRef) {\n  if (initialTry === void 0) {\n    initialTry = 0;\n  }\n  var MAX_TRIES = 10;\n  var currentTry = initialTry;\n  if (currentTry > MAX_TRIES) {\n    return;\n  }\n  try {\n    var scrollDOM = (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current) || document.querySelector('.sendbird-openchannel-conversation-scroll__container__item-container');\n    // eslint-disable-next-line no-multi-assign\n    if (scrollDOM) {\n      scrollDOM.scrollTop = scrollDOM.scrollHeight;\n    }\n  } catch (error) {\n    setTimeout(function () {\n      scrollIntoLast(currentTry + 1, scrollRef);\n    }, 500 * currentTry);\n  }\n};\nvar kFormatter = function (num) {\n  if (Math.abs(num) > 999999) {\n    return \"\".concat((Math.abs(num) / 1000000).toFixed(1), \"M\");\n  }\n  if (Math.abs(num) > 999) {\n    return \"\".concat((Math.abs(num) / 1000).toFixed(1), \"K\");\n  }\n  return \"\".concat(num);\n};\nvar isOperator = function (openChannel, userId) {\n  var operators = openChannel === null || openChannel === void 0 ? void 0 : openChannel.operators;\n  if (operators.map(function (operator) {\n    return operator.userId;\n  }).indexOf(userId) < 0) {\n    return false;\n  }\n  return true;\n};\nvar isDisabledBecauseFrozen = function (openChannel, userId) {\n  if (!openChannel) return false;\n  var isFrozen = openChannel.isFrozen;\n  return isFrozen && !isOperator(openChannel, userId);\n};\nvar isDisabledBecauseMuted = function (mutedParticipantIds, userId) {\n  return mutedParticipantIds.indexOf(userId) > -1;\n};\nvar fetchWithListQuery = function (listQuery, logger, eachQueryNextCallback) {\n  var fetchList = function (query) {\n    var hasNext = query.hasNext;\n    if (hasNext) {\n      query.next().then(function (users) {\n        eachQueryNextCallback(users);\n        fetchList(query);\n      }).catch(function (error) {\n        logger.warning('OpenChannel | FetchUserList failed', error);\n      });\n    } else {\n      logger.info('OpenChannel | FetchUserList finished');\n    }\n  };\n  logger.info('OpenChannel | FetchUserList start', listQuery);\n  fetchList(listQuery);\n};\nvar SET_CURRENT_CHANNEL = 'SET_CURRENT_CHANNEL';\nvar SET_CHANNEL_INVALID = 'SET_CHANNEL_INVALID';\nvar RESET_MESSAGES = 'RESET_MESSAGES';\nvar EXIT_CURRENT_CHANNEL = 'EXIT_CURRENT_CHANNEL';\nvar GET_PREV_MESSAGES_START = 'GET_PREV_MESSAGES_START';\nvar GET_PREV_MESSAGES_SUCESS = 'GET_PREV_MESSAGES_SUCESS';\nvar GET_PREV_MESSAGES_FAIL = 'GET_PREV_MESSAGES_FAIL';\nvar SENDING_MESSAGE_FAILED = 'SENDING_MESSAGE_FAILED';\nvar SENDING_MESSAGE_SUCCEEDED = 'SENDING_MESSAGE_SUCCEEDED';\nvar SENDING_MESSAGE_START = 'SENDING_MESSAGE_START';\nvar RESENDING_MESSAGE_START = 'RESENDING_MESSAGE_START';\nvar FETCH_PARTICIPANT_LIST = 'FETCH_PARTICIPANT_LIST';\nvar FETCH_BANNED_USER_LIST = 'FETCH_BANNED_USER_LIST';\nvar FETCH_MUTED_USER_LIST = 'FETCH_MUTED_USER_LIST';\nvar TRIM_MESSAGE_LIST = 'TRIM_MESSAGE_LIST';\n// event handlers\nvar ON_MESSAGE_RECEIVED = 'ON_MESSAGE_RECEIVED';\nvar ON_MESSAGE_UPDATED = 'ON_MESSAGE_UPDATED';\nvar ON_MESSAGE_DELETED = 'ON_MESSAGE_DELETED';\nvar ON_MESSAGE_DELETED_BY_REQ_ID = 'ON_MESSAGE_DELETED_BY_REQ_ID';\nvar ON_OPERATOR_UPDATED = 'ON_OPERATOR_UPDATED';\nvar ON_USER_ENTERED = 'ON_USER_ENTERED';\nvar ON_USER_EXITED = 'ON_USER_EXITED';\nvar ON_USER_MUTED = 'ON_USER_MUTED';\nvar ON_USER_UNMUTED = 'ON_USER_UNMUTED';\nvar ON_USER_BANNED = 'ON_USER_BANNED';\nvar ON_USER_UNBANNED = 'ON_USER_UNBANNED';\nvar ON_CHANNEL_FROZEN = 'ON_CHANNEL_FROZEN';\nvar ON_CHANNEL_UNFROZEN = 'ON_CHANNEL_UNFROZEN';\nvar ON_CHANNEL_CHANGED = 'ON_CHANNEL_CHANGED';\nvar ON_CHANNEL_DELETED = 'ON_CHANNEL_DELETED';\nvar ON_META_DATA_CREATED = 'ON_META_DATA_CREATED';\nvar ON_META_DATA_UPDATED = 'ON_META_DATA_UPDATED';\nvar ON_META_DATA_DELETED = 'ON_META_DATA_DELETED';\nvar ON_META_COUNTERS_CREATED = 'ON_META_COUNTERS_CREATED';\nvar ON_META_COUNTERS_UPDATED = 'ON_META_COUNTERS_UPDATED';\nvar ON_META_COUNTERS_DELETED = 'ON_META_COUNTERS_DELETED';\nvar ON_MENTION_RECEIVED = 'ON_MENTION_RECEIVED';\nfunction reducer(state, action) {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n  switch (action.type) {\n    case RESET_MESSAGES:\n      {\n        return __assign(__assign({}, state), {\n          allMessages: []\n        });\n      }\n    case EXIT_CURRENT_CHANNEL:\n      {\n        if (((_a = action.payload) === null || _a === void 0 ? void 0 : _a.url) === ((_b = state.currentOpenChannel) === null || _b === void 0 ? void 0 : _b.url)) {\n          return __assign(__assign({}, state), {\n            currentOpenChannel: null\n          });\n        }\n        return state;\n      }\n    case SET_CURRENT_CHANNEL:\n      {\n        var gottenChannel = action.payload;\n        var operators = gottenChannel.operators;\n        if (!state.isInvalid && state.currentOpenChannel && state.currentOpenChannel.url && state.currentOpenChannel.url === gottenChannel.url) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          currentOpenChannel: gottenChannel,\n          isInvalid: false,\n          operators: operators,\n          participants: operators,\n          bannedParticipantIds: [],\n          mutedParticipantIds: []\n        });\n      }\n    case SET_CHANNEL_INVALID:\n      {\n        return __assign(__assign({}, state), {\n          isInvalid: true\n        });\n      }\n    case GET_PREV_MESSAGES_START:\n      {\n        return __assign(__assign({}, state), {\n          loading: true\n        });\n      }\n    case GET_PREV_MESSAGES_SUCESS:\n    case GET_PREV_MESSAGES_FAIL:\n      {\n        var isFailed = action.type === GET_PREV_MESSAGES_FAIL;\n        var _j = action.payload,\n          _k = _j.currentOpenChannel,\n          currentOpenChannel = _k === void 0 ? {} : _k,\n          _l = _j.messages,\n          messages = _l === void 0 ? [] : _l,\n          hasMore = _j.hasMore,\n          lastMessageTimestamp = _j.lastMessageTimestamp;\n        var actionChannelUrl = currentOpenChannel.url;\n        var receivedMessages_1 = isFailed ? [] : messages;\n        var _hasMore = isFailed ? false : hasMore;\n        var _lastMessageTimestamp = isFailed ? 0 : lastMessageTimestamp;\n        var stateChannel = state.currentOpenChannel;\n        var stateChannelUrl = stateChannel === null || stateChannel === void 0 ? void 0 : stateChannel.url;\n        if (actionChannelUrl !== stateChannelUrl) {\n          return state;\n        }\n        var filteredAllMessages = state.allMessages.filter(function (message) {\n          return !receivedMessages_1.find(function (_a) {\n            var messageId = _a.messageId;\n            return compareIds(messageId, message.messageId);\n          });\n        });\n        return __assign(__assign({}, state), {\n          loading: false,\n          initialized: true,\n          hasMore: _hasMore,\n          lastMessageTimestamp: _lastMessageTimestamp,\n          allMessages: __spreadArray(__spreadArray([], receivedMessages_1, true), filteredAllMessages, true)\n        });\n      }\n    case SENDING_MESSAGE_START:\n      {\n        var _m = action.payload,\n          message_1 = _m.message,\n          channel = _m.channel;\n        if ((channel === null || channel === void 0 ? void 0 : channel.url) !== ((_c = state.currentOpenChannel) === null || _c === void 0 ? void 0 : _c.url) || state.allMessages.some(function (m) {\n          return m.reqId === message_1.reqId;\n        })\n        // Handing failed first than sending start issue\n        ) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          allMessages: __spreadArray(__spreadArray([], state.allMessages, true), [message_1], false)\n        });\n      }\n    case SENDING_MESSAGE_SUCCEEDED:\n      {\n        var sentMessage_1 = action.payload;\n        var newMessages = state.allMessages.map(function (m) {\n          return compareIds(m.reqId, sentMessage_1.reqId) ? sentMessage_1 : m;\n        });\n        return __assign(__assign({}, state), {\n          allMessages: newMessages\n        });\n      }\n    case SENDING_MESSAGE_FAILED:\n      {\n        var sentMessage_2 = action.payload;\n        sentMessage_2.sendingStatus = 'failed';\n        if (!state.allMessages.some(function (m) {\n          return (m === null || m === void 0 ? void 0 : m.reqId) === (sentMessage_2 === null || sentMessage_2 === void 0 ? void 0 : sentMessage_2.reqId);\n        })) {\n          // Handling failed first than sending start issue\n          return __assign(__assign({}, state), {\n            allMessages: __spreadArray(__spreadArray([], state.allMessages.filter(function (m) {\n              return !compareIds(m.reqId, sentMessage_2);\n            }), true), [sentMessage_2], false)\n          });\n        } else {\n          return __assign(__assign({}, state), {\n            allMessages: state.allMessages.map(function (m) {\n              return compareIds(m.reqId, sentMessage_2.reqId) ? sentMessage_2 : m;\n            })\n          });\n        }\n      }\n    case TRIM_MESSAGE_LIST:\n      {\n        var allMessages = state.allMessages;\n        var messageLimit = (_d = action.payload) === null || _d === void 0 ? void 0 : _d.messageLimit;\n        if (messageLimit && messageLimit > 0 && (allMessages === null || allMessages === void 0 ? void 0 : allMessages.length) > messageLimit) {\n          var sliceAt = allMessages.length - messageLimit;\n          return __assign(__assign({}, state), {\n            allMessages: allMessages.slice(sliceAt)\n          });\n        }\n        return state;\n      }\n    case RESENDING_MESSAGE_START:\n      {\n        var eventedChannel = action.payload.channel;\n        var resentMessage_1 = action.payload.message;\n        if (eventedChannel.url !== ((_e = state.currentOpenChannel) === null || _e === void 0 ? void 0 : _e.url)) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          allMessages: state.allMessages.map(function (m) {\n            return compareIds(m.reqId, resentMessage_1.reqId) ? resentMessage_1 : m;\n          })\n        });\n      }\n    case FETCH_PARTICIPANT_LIST:\n      {\n        var eventedChannel = action.payload.channel;\n        var fetchedParticipantList = action.payload.users;\n        if (eventedChannel.url !== ((_f = state.currentOpenChannel) === null || _f === void 0 ? void 0 : _f.url)) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          participants: __spreadArray(__spreadArray([], state.participants, true), fetchedParticipantList, true)\n        });\n      }\n    case FETCH_BANNED_USER_LIST:\n      {\n        var eventedChannel = action.payload.channel;\n        var fetchedBannedUserList = action.payload.users;\n        if (eventedChannel.url !== ((_g = state.currentOpenChannel) === null || _g === void 0 ? void 0 : _g.url) || !fetchedBannedUserList.every(function (user) {\n          return typeof user.userId === 'string';\n        })) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          bannedParticipantIds: __spreadArray(__spreadArray([], state.bannedParticipantIds, true), fetchedBannedUserList.map(function (user) {\n            return user.userId;\n          }), true)\n        });\n      }\n    case FETCH_MUTED_USER_LIST:\n      {\n        var eventedChannel = action.payload.channel;\n        var fetchedMutedUserList = action.payload.users;\n        if (eventedChannel.url !== ((_h = state.currentOpenChannel) === null || _h === void 0 ? void 0 : _h.url) || !fetchedMutedUserList.every(function (user) {\n          return typeof user.userId === 'string';\n        })) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          mutedParticipantIds: __spreadArray(__spreadArray([], state.mutedParticipantIds, true), fetchedMutedUserList.map(function (user) {\n            return user.userId;\n          }), true)\n        });\n      }\n    // events\n    case ON_MESSAGE_RECEIVED:\n      {\n        var eventedChannel = action.payload.channel;\n        var receivedMessage = action.payload.message;\n        var currentOpenChannel = state.currentOpenChannel;\n        if (!compareIds(eventedChannel.url, currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.url) || !(state.allMessages.map(function (message) {\n          return message.messageId;\n        }).indexOf(receivedMessage.messageId) < 0)) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          allMessages: __spreadArray(__spreadArray([], state.allMessages, true), [receivedMessage], false)\n        });\n      }\n    case ON_MESSAGE_UPDATED:\n      {\n        var eventedChannel = action.payload.channel;\n        var updatedMessage_1 = action.payload.message;\n        var currentChannel = state.currentOpenChannel;\n        if (!currentChannel || currentChannel.url && currentChannel.url !== eventedChannel.url) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          allMessages: state.allMessages.map(function (message) {\n            return message.isIdentical(updatedMessage_1) ? updatedMessage_1 : message;\n          })\n        });\n      }\n    case ON_MESSAGE_DELETED:\n      {\n        var eventedChannel = action.payload.channel;\n        var deletedMessageId_1 = action.payload.messageId;\n        var currentChannel = state.currentOpenChannel;\n        if (!currentChannel || currentChannel.url && currentChannel.url !== eventedChannel.url) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          allMessages: state.allMessages.filter(function (message) {\n            return !compareIds(message.messageId, deletedMessageId_1);\n          })\n        });\n      }\n    case ON_MESSAGE_DELETED_BY_REQ_ID:\n      {\n        return __assign(__assign({}, state), {\n          allMessages: state.allMessages.filter(function (m) {\n            return !compareIds(m.reqId, action.payload);\n          })\n        });\n      }\n    case ON_OPERATOR_UPDATED:\n      {\n        var eventedChannel = action.payload.channel;\n        var updatedOperators = action.payload.operators;\n        var currentChannel = state.currentOpenChannel;\n        if (!currentChannel || currentChannel.url && currentChannel.url !== eventedChannel.url) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          currentOpenChannel: eventedChannel,\n          operators: updatedOperators\n        });\n      }\n    case ON_USER_ENTERED:\n      {\n        var eventedChannel = action.payload.channel;\n        var enteredUser = action.payload.user;\n        var currentChannel = state.currentOpenChannel;\n        if (!currentChannel || currentChannel.url && currentChannel.url !== eventedChannel.url) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          participants: __spreadArray(__spreadArray([], state.participants, true), [enteredUser], false)\n        });\n      }\n    case ON_USER_EXITED:\n      {\n        var eventedChannel = action.payload.channel;\n        var exitedUser_1 = action.payload.user;\n        var currentChannel = state.currentOpenChannel;\n        if (!currentChannel || currentChannel.url && currentChannel.url !== eventedChannel.url) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          participants: state.participants.filter(function (participant) {\n            return !compareIds(participant.userId, exitedUser_1.userId);\n          })\n        });\n      }\n    case ON_USER_MUTED:\n      {\n        var eventedChannel = action.payload.channel;\n        var mutedUser = action.payload.user;\n        var currentChannel = state.currentOpenChannel;\n        if (!currentChannel || currentChannel.url && currentChannel.url !== eventedChannel.url || state.mutedParticipantIds.indexOf(mutedUser.userId) >= 0) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          mutedParticipantIds: __spreadArray(__spreadArray([], state.mutedParticipantIds, true), [mutedUser.userId], false)\n        });\n      }\n    case ON_USER_UNMUTED:\n      {\n        var eventedChannel = action.payload.channel;\n        var unmutedUser_1 = action.payload.user;\n        var currentChannel = state.currentOpenChannel;\n        if (!currentChannel || currentChannel.url && currentChannel.url !== eventedChannel.url || state.mutedParticipantIds.indexOf(unmutedUser_1.userId) < 0) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          mutedParticipantIds: state.mutedParticipantIds.filter(function (userId) {\n            return userId !== unmutedUser_1.userId;\n          })\n        });\n      }\n    case ON_USER_BANNED:\n      {\n        var eventedChannel = action.payload.channel;\n        var bannedUser = action.payload.user;\n        var currentUser = action.payload.currentUser;\n        var currentChannel = state.currentOpenChannel;\n        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (eventedChannel === null || eventedChannel === void 0 ? void 0 : eventedChannel.url) && (bannedUser === null || bannedUser === void 0 ? void 0 : bannedUser.userId) === (currentUser === null || currentUser === void 0 ? void 0 : currentUser.userId)) {\n          return __assign(__assign({}, state), {\n            currentOpenChannel: null\n          });\n        } else if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (eventedChannel === null || eventedChannel === void 0 ? void 0 : eventedChannel.url)) {\n          return __assign(__assign({}, state), {\n            bannedParticipantIds: __spreadArray(__spreadArray([], state.bannedParticipantIds, true), [bannedUser.userId], false)\n          });\n        }\n        return state;\n      }\n    case ON_USER_UNBANNED:\n      {\n        var eventedChannel = action.payload.channel;\n        var unbannedUser_1 = action.payload.user;\n        var currentChannel = state.currentOpenChannel;\n        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (eventedChannel === null || eventedChannel === void 0 ? void 0 : eventedChannel.url)) {\n          return __assign(__assign({}, state), {\n            bannedParticipantIds: state.bannedParticipantIds.filter(function (userId) {\n              return userId !== unbannedUser_1.userId;\n            })\n          });\n        }\n        return state;\n      }\n    case ON_CHANNEL_FROZEN:\n      {\n        var frozenChannel = action.payload;\n        var currentChannel = state.currentOpenChannel;\n        if (!currentChannel || currentChannel.url && currentChannel.url !== frozenChannel.url) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          frozen: true\n        });\n      }\n    case ON_CHANNEL_UNFROZEN:\n      {\n        var unfrozenChannel = action.payload;\n        var currentChannel = state.currentOpenChannel;\n        if (!currentChannel || currentChannel.url && currentChannel.url !== unfrozenChannel.url) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          frozen: false\n        });\n      }\n    case ON_CHANNEL_CHANGED:\n      {\n        var changedChannel = action.payload;\n        var currentChannel = state.currentOpenChannel;\n        if (!currentChannel || currentChannel.url && currentChannel.url !== changedChannel.url) {\n          return state;\n        }\n        return __assign(__assign({}, state), {\n          currentOpenChannel: changedChannel\n        });\n      }\n    case ON_CHANNEL_DELETED:\n      {\n        var deletedChannelUrl = action.payload;\n        var currentChannel = state === null || state === void 0 ? void 0 : state.currentOpenChannel;\n        if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === deletedChannelUrl) {\n          return __assign(__assign({}, state), {\n            currentOpenChannel: null\n          });\n        }\n        return state;\n      }\n    case ON_META_DATA_CREATED:\n      {\n        // const eventedChannel = action.payload.channel;\n        // const createdMetaData = action.payload.metaData;\n        // return {\n        //   ...state\n        // };\n        return state;\n      }\n    case ON_META_DATA_UPDATED:\n      {\n        // const eventedChannel = action.payload.channel;\n        // const updatedMetaData = action.payload.metaData;\n        // return {\n        //   ...state\n        // };\n        return state;\n      }\n    case ON_META_DATA_DELETED:\n      {\n        // const eventedChannel = action.payload.channel;\n        // const deletedMetaDataKeys = action.payload.metaDataKeys;\n        // return {\n        //   ...state\n        // };\n        return state;\n      }\n    case ON_META_COUNTERS_CREATED:\n      {\n        // const eventedChannel = action.payload.channel;\n        // const createdMetaCounter = action.payload.metaCounter;\n        // return {\n        //   ...state\n        // };\n        return state;\n      }\n    case ON_META_COUNTERS_UPDATED:\n      {\n        // const eventedChannel = action.payload.channel;\n        // const updatedMetaCounter = action.payload.metaCounter;\n        // return {\n        //   ...state\n        // };\n        return state;\n      }\n    case ON_META_COUNTERS_DELETED:\n      {\n        // const eventedChannel = action.payload.channel;\n        // const deletedMetaCounterKeys = action.payload.metaCounterKeys;\n        // return {\n        //   ...state\n        // };\n        return state;\n      }\n    case ON_MENTION_RECEIVED:\n      {\n        // const eventedChannel = action.payload.channel;\n        // const mentionedMessage = action.payload.message;\n        // return {\n        //   ...state\n        // };\n        return state;\n      }\n    default:\n      return state;\n  }\n}\nvar initialState = {\n  allMessages: [],\n  loading: false,\n  initialized: false,\n  currentOpenChannel: null,\n  isInvalid: false,\n  hasMore: false,\n  lastMessageTimestamp: 0,\n  frozen: false,\n  operators: [],\n  participants: [],\n  bannedParticipantIds: [],\n  mutedParticipantIds: []\n};\nfunction useSetChannel(_a, _b) {\n  var channelUrl = _a.channelUrl,\n    sdkInit = _a.sdkInit,\n    fetchingParticipants = _a.fetchingParticipants,\n    userId = _a.userId,\n    currentOpenChannel = _a.currentOpenChannel;\n  var sdk = _b.sdk,\n    logger = _b.logger,\n    messagesDispatcher = _b.messagesDispatcher;\n  useEffect(function () {\n    var _a;\n    if (channelUrl && sdkInit && (sdk === null || sdk === void 0 ? void 0 : sdk.openChannel)) {\n      if (currentOpenChannel && (currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.exit)) {\n        (_a = currentOpenChannel.exit) === null || _a === void 0 ? void 0 : _a.call(currentOpenChannel).then(function () {\n          logger.info('OpenChannel | useSetChannel: Exit from the previous open channel', currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.url);\n          messagesDispatcher({\n            type: EXIT_CURRENT_CHANNEL,\n            payload: currentOpenChannel\n          });\n        });\n      }\n      logger.info('OpenChannel | useSetChannel: Fetching channel', channelUrl);\n      sdk.openChannel.getChannel(channelUrl).then(function (openChannel) {\n        logger.info('OpenChannel | useSetChannel: Succeeded to fetch channel', openChannel);\n        messagesDispatcher({\n          type: SET_CURRENT_CHANNEL,\n          payload: openChannel\n        });\n        openChannel.enter().then(function () {\n          if (openChannel.isOperator(userId)) {\n            // only operator has a permission to fetch these list\n            var bannedParticipantListQuery = openChannel.createBannedUserListQuery();\n            var mutedParticipantListQuery = openChannel.createMutedUserListQuery();\n            fetchWithListQuery(bannedParticipantListQuery, logger, function (users) {\n              messagesDispatcher({\n                type: FETCH_BANNED_USER_LIST,\n                payload: {\n                  channel: openChannel,\n                  users: users\n                }\n              });\n            });\n            fetchWithListQuery(mutedParticipantListQuery, logger, function (users) {\n              messagesDispatcher({\n                type: FETCH_MUTED_USER_LIST,\n                payload: {\n                  channel: openChannel,\n                  users: users\n                }\n              });\n            });\n          } else {\n            openChannel.getMyMutedInfo().then(function (mutedInfo) {\n              if (mutedInfo === null || mutedInfo === void 0 ? void 0 : mutedInfo.isMuted) {\n                messagesDispatcher({\n                  type: FETCH_MUTED_USER_LIST,\n                  payload: {\n                    channel: openChannel,\n                    users: [sdk === null || sdk === void 0 ? void 0 : sdk.currentUser]\n                  }\n                });\n              }\n            });\n          }\n          if (fetchingParticipants) {\n            // fetch participants list\n            var participantListQuery = openChannel.createParticipantListQuery({\n              limit: openChannel.participantCount\n            });\n            fetchWithListQuery(participantListQuery, logger, function (users) {\n              messagesDispatcher({\n                type: FETCH_PARTICIPANT_LIST,\n                payload: {\n                  channel: openChannel,\n                  users: users\n                }\n              });\n            });\n          }\n        }).catch(function (error) {\n          logger.warning('OpenChannel | useSetChannel: Failed to enter channel', {\n            channelUrl: channelUrl,\n            error: error\n          });\n          messagesDispatcher({\n            type: SET_CHANNEL_INVALID,\n            payload: null\n          });\n        });\n      }).catch(function (error) {\n        logger.warning('OpenChannel | useSetChannel: Failed to fetch channel', {\n          channelUrl: channelUrl,\n          error: error\n        });\n        messagesDispatcher({\n          type: SET_CHANNEL_INVALID,\n          payload: null\n        });\n      });\n    }\n  }, [channelUrl, sdkInit, fetchingParticipants]);\n}\nfunction useHandleChannelEvents(_a, _b) {\n  var currentOpenChannel = _a.currentOpenChannel,\n    checkScrollBottom = _a.checkScrollBottom;\n  var sdk = _b.sdk,\n    logger = _b.logger,\n    messagesDispatcher = _b.messagesDispatcher,\n    scrollRef = _b.scrollRef;\n  useEffect(function () {\n    var _a, _b;\n    var messageReceiverId = uuidv4();\n    if (currentOpenChannel && currentOpenChannel.url && ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.openChannel) === null || _a === void 0 ? void 0 : _a.addOpenChannelHandler)) {\n      logger.info('OpenChannel | useHandleChannelEvents: Setup evnet handler', messageReceiverId);\n      var channelHandlerParams = {\n        onMessageReceived: function (channel, message) {\n          var scrollToEnd = checkScrollBottom();\n          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n          logger.info('OpenChannel | useHandleChannelEvents: onMessageReceived', {\n            channelUrl: channelUrl,\n            message: message\n          });\n          messagesDispatcher({\n            type: ON_MESSAGE_RECEIVED,\n            payload: {\n              channel: channel,\n              message: message\n            }\n          });\n          if (scrollToEnd) {\n            try {\n              setTimeout(function () {\n                scrollIntoLast(0, scrollRef);\n              });\n            } catch (error) {\n              logger.warning('OpenChannel | onMessageReceived | scroll to end failed');\n            }\n          }\n        },\n        onMessageUpdated: function (channel, message) {\n          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n          logger.info('OpenChannel | useHandleChannelEvents: onMessageUpdated', {\n            channelUrl: channelUrl,\n            message: message\n          });\n          messagesDispatcher({\n            type: ON_MESSAGE_UPDATED,\n            payload: {\n              channel: channel,\n              message: message\n            }\n          });\n        },\n        onMessageDeleted: function (channel, messageId) {\n          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n          logger.info('OpenChannel | useHandleChannelEvents: onMessageDeleted', {\n            channelUrl: channelUrl,\n            messageId: messageId\n          });\n          messagesDispatcher({\n            type: ON_MESSAGE_DELETED,\n            payload: {\n              channel: channel,\n              messageId: messageId\n            }\n          });\n        },\n        onOperatorUpdated: function (channel, operators) {\n          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n          logger.info('OpenChannel | useHandleChannelEvents: onOperatorUpdated', {\n            channelUrl: channelUrl,\n            operators: operators\n          });\n          messagesDispatcher({\n            type: ON_OPERATOR_UPDATED,\n            payload: {\n              channel: channel,\n              operators: operators\n            }\n          });\n        },\n        onUserEntered: function (channel, user) {\n          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n          logger.info('OpenChannel | useHandleChannelEvents: onUserEntered', {\n            channelUrl: channelUrl,\n            user: user\n          });\n          messagesDispatcher({\n            type: ON_USER_ENTERED,\n            payload: {\n              channel: channel,\n              user: user\n            }\n          });\n        },\n        onUserExited: function (channel, user) {\n          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n          logger.info('OpenChannel | useHandleChannelEvents: onUserExited', {\n            channelUrl: channelUrl,\n            user: user\n          });\n          messagesDispatcher({\n            type: ON_USER_EXITED,\n            payload: {\n              channel: channel,\n              user: user\n            }\n          });\n        },\n        onUserMuted: function (channel, user) {\n          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n          logger.info('OpenChannel | useHandleChannelEvents: onUserMuted', {\n            channelUrl: channelUrl,\n            user: user\n          });\n          messagesDispatcher({\n            type: ON_USER_MUTED,\n            payload: {\n              channel: channel,\n              user: user\n            }\n          });\n        },\n        onUserUnmuted: function (channel, user) {\n          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n          logger.info('OpenChannel | useHandleChannelEvents: onUserUnmuted', {\n            channelUrl: channelUrl,\n            user: user\n          });\n          messagesDispatcher({\n            type: ON_USER_UNMUTED,\n            payload: {\n              channel: channel,\n              user: user\n            }\n          });\n        },\n        onUserBanned: function (channel, user) {\n          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n          logger.info('OpenChannel | useHandleChannelEvents: onUserBanned', {\n            channelUrl: channelUrl,\n            user: user\n          });\n          messagesDispatcher({\n            type: ON_USER_BANNED,\n            payload: {\n              channel: channel,\n              user: user,\n              currentUser: sdk === null || sdk === void 0 ? void 0 : sdk.currentUser\n            }\n          });\n        },\n        onUserUnbanned: function (channel, user) {\n          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n          logger.info('OpenChannel | useHandleChannelEvents: onUserUnbanned', {\n            channelUrl: channelUrl,\n            user: user\n          });\n          messagesDispatcher({\n            type: ON_USER_UNBANNED,\n            payload: {\n              channel: channel,\n              user: user\n            }\n          });\n        },\n        onChannelFrozen: function (channel) {\n          logger.info('OpenChannel | useHandleChannelEvents: onChannelFrozen', channel);\n          messagesDispatcher({\n            type: ON_CHANNEL_FROZEN,\n            payload: channel\n          });\n        },\n        onChannelUnfrozen: function (channel) {\n          logger.info('OpenChannel | useHandleChannelEvents: onChannelUnfrozen', channel);\n          messagesDispatcher({\n            type: ON_CHANNEL_UNFROZEN,\n            payload: channel\n          });\n        },\n        onChannelChanged: function (channel) {\n          logger.info('OpenChannel | useHandleChannelEvents: onChannelChanged', channel);\n          messagesDispatcher({\n            type: ON_CHANNEL_CHANGED,\n            payload: channel\n          });\n        },\n        onMetaDataCreated: function (channel, metaData) {\n          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n          logger.info('OpenChannel | useHandleChannelEvents: onMetaDataCreated', {\n            channelUrl: channelUrl,\n            metaData: metaData\n          });\n          messagesDispatcher({\n            type: ON_META_DATA_CREATED,\n            payload: {\n              channel: channel,\n              metaData: metaData\n            }\n          });\n        },\n        onMetaDataUpdated: function (channel, metaData) {\n          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n          logger.info('OpenChannel | useHandleChannelEvents: onMetaDataUpdated', {\n            channelUrl: channelUrl,\n            metaData: metaData\n          });\n          messagesDispatcher({\n            type: ON_META_DATA_UPDATED,\n            payload: {\n              channel: channel,\n              metaData: metaData\n            }\n          });\n        },\n        onMetaDataDeleted: function (channel, metaDataKeys) {\n          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n          logger.info('OpenChannel | useHandleChannelEvents: onMetaDataDeleted', {\n            channelUrl: channelUrl,\n            metaDataKeys: metaDataKeys\n          });\n          messagesDispatcher({\n            type: ON_META_DATA_DELETED,\n            payload: {\n              channel: channel,\n              metaDataKeys: metaDataKeys\n            }\n          });\n        },\n        onMetaCounterCreated: function (channel, metaCounter) {\n          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n          logger.info('OpenChannel | useHandleChannelEvents: onMetaCountersCreated', {\n            channelUrl: channelUrl,\n            metaCounter: metaCounter\n          });\n          messagesDispatcher({\n            type: ON_META_COUNTERS_CREATED,\n            payload: {\n              channel: channel,\n              metaCounter: metaCounter\n            }\n          });\n        },\n        onMetaCounterUpdated: function (channel, metaCounter) {\n          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n          logger.info('OpenChannel | useHandleChannelEvents: onMetaCountersUpdated', {\n            channelUrl: channelUrl,\n            metaCounter: metaCounter\n          });\n          messagesDispatcher({\n            type: ON_META_COUNTERS_UPDATED,\n            payload: {\n              channel: channel,\n              metaCounter: metaCounter\n            }\n          });\n        },\n        onMetaCounterDeleted: function (channel, metaCounterKeys) {\n          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n          logger.info('OpenChannel | useHandleChannelEvents: onMetaCountersDeleted', {\n            channelUrl: channelUrl,\n            metaCounterKeys: metaCounterKeys\n          });\n          messagesDispatcher({\n            type: ON_META_COUNTERS_DELETED,\n            payload: {\n              channel: channel,\n              metaCounterKeys: metaCounterKeys\n            }\n          });\n        },\n        onMentionReceived: function (channel, message) {\n          var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n          logger.info('OpenChannel | useHandleChannelEvents: onMentionReceived', {\n            channelUrl: channelUrl,\n            message: message\n          });\n          messagesDispatcher({\n            type: ON_MENTION_RECEIVED,\n            payload: {\n              channel: channel,\n              message: message\n            }\n          });\n        },\n        onChannelDeleted: function (channelUrl, channelType) {\n          if (channelType === ChannelType.OPEN && (currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.url) === channelUrl) {\n            messagesDispatcher({\n              type: ON_CHANNEL_DELETED,\n              payload: channelUrl\n            });\n          }\n        }\n      };\n      var ChannelHandler = new OpenChannelHandler(channelHandlerParams);\n      (_b = sdk === null || sdk === void 0 ? void 0 : sdk.openChannel) === null || _b === void 0 ? void 0 : _b.addOpenChannelHandler(messageReceiverId, ChannelHandler);\n    }\n    return function () {\n      var _a;\n      if ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.openChannel) === null || _a === void 0 ? void 0 : _a.removeOpenChannelHandler) {\n        logger.info('OpenChannel | useHandleChannelEvents: Removing message receiver handler', messageReceiverId);\n        sdk.openChannel.removeOpenChannelHandler(messageReceiverId);\n      }\n    };\n  }, [currentOpenChannel]);\n}\nfunction useInitialMessagesFetch(_a, _b) {\n  var currentOpenChannel = _a.currentOpenChannel,\n    userFilledMessageListParams = _a.userFilledMessageListParams;\n  var logger = _b.logger,\n    messagesDispatcher = _b.messagesDispatcher,\n    scrollRef = _b.scrollRef;\n  useEffect(function () {\n    logger.info('OpenChannel | useInitialMessagesFetch: Setup started', currentOpenChannel);\n    messagesDispatcher({\n      type: RESET_MESSAGES,\n      payload: null\n    });\n    if (currentOpenChannel && currentOpenChannel.getMessagesByTimestamp) {\n      var messageListParams_1 = {\n        nextResultSize: 0,\n        prevResultSize: 30,\n        isInclusive: true,\n        includeReactions: false\n      };\n      if (userFilledMessageListParams) {\n        Object.keys(userFilledMessageListParams).forEach(function (key) {\n          // @ts-ignore\n          messageListParams_1[key] = userFilledMessageListParams[key];\n        });\n        logger.info('OpenChannel | useInitialMessagesFetch: Used customizedMessageListParams');\n      }\n      logger.info('OpenChannel | useInitialMessagesFetch: Fetching messages', {\n        currentOpenChannel: currentOpenChannel,\n        messageListParams: messageListParams_1\n      });\n      messagesDispatcher({\n        type: GET_PREV_MESSAGES_START,\n        payload: null\n      });\n      currentOpenChannel.getMessagesByTimestamp(new Date().getTime(), messageListParams_1).then(function (messages) {\n        logger.info('OpenChannel | useInitialMessagesFetch: Fetching messages succeeded', messages);\n        var hasMore = messages && messages.length > 0;\n        var lastMessageTimestamp = hasMore ? messages[0].createdAt : null;\n        messagesDispatcher({\n          type: GET_PREV_MESSAGES_SUCESS,\n          payload: {\n            currentOpenChannel: currentOpenChannel,\n            messages: messages,\n            hasMore: hasMore,\n            lastMessageTimestamp: lastMessageTimestamp\n          }\n        });\n        setTimeout(function () {\n          scrollIntoLast(0, scrollRef);\n        });\n      }).catch(function (error) {\n        logger.error('OpenChannel | useInitialMessagesFetch: Fetching messages failed', error);\n        messagesDispatcher({\n          type: GET_PREV_MESSAGES_FAIL,\n          payload: {\n            currentOpenChannel: currentOpenChannel,\n            messages: [],\n            hasMore: false,\n            lastMessageTimestamp: 0\n          }\n        });\n      });\n    }\n  }, [currentOpenChannel, userFilledMessageListParams]);\n}\nfunction useScrollCallback(_a, _b) {\n  var currentOpenChannel = _a.currentOpenChannel,\n    lastMessageTimestamp = _a.lastMessageTimestamp,\n    fetchMore = _a.fetchMore;\n  var sdk = _b.sdk,\n    logger = _b.logger,\n    messagesDispatcher = _b.messagesDispatcher,\n    hasMore = _b.hasMore,\n    userFilledMessageListParams = _b.userFilledMessageListParams;\n  return useCallback(function (callback) {\n    if (fetchMore && hasMore) {\n      logger.info('OpenChannel | useScrollCallback: start');\n      var messageListParams_1 = {\n        prevResultSize: 30,\n        includeReactions: false,\n        nextResultSize: 0\n      };\n      if (userFilledMessageListParams) {\n        Object.keys(userFilledMessageListParams).forEach(function (key) {\n          // @ts-ignore\n          messageListParams_1[key] = userFilledMessageListParams[key];\n        });\n        logger.info('OpenChannel | useScrollCallback: Used userFilledMessageListParams', userFilledMessageListParams);\n      }\n      logger.info('OpenChannel | useScrollCallback: Fetching messages', {\n        currentOpenChannel: currentOpenChannel,\n        messageListParams: messageListParams_1\n      });\n      currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.getMessagesByTimestamp(lastMessageTimestamp || new Date().getTime(), messageListParams_1).then(function (messages) {\n        logger.info('OpenChannel | useScrollCallback: Fetching messages succeeded', messages);\n        var hasMore = messages && messages.length > 0;\n        var lastMessageTimestamp = hasMore ? messages[0].createdAt : null;\n        messagesDispatcher({\n          type: GET_PREV_MESSAGES_SUCESS,\n          payload: {\n            currentOpenChannel: currentOpenChannel,\n            messages: messages,\n            hasMore: hasMore,\n            lastMessageTimestamp: lastMessageTimestamp\n          }\n        });\n        setTimeout(function () {\n          callback();\n        });\n      }).catch(function (error) {\n        logger.error('OpenChannel | useScrollCallback: Fetching messages failed', error);\n        messagesDispatcher({\n          type: GET_PREV_MESSAGES_FAIL,\n          payload: {\n            currentOpenChannel: currentOpenChannel,\n            messages: [],\n            hasMore: false,\n            lastMessageTimestamp: 0\n          }\n        });\n      });\n    }\n  }, [currentOpenChannel, lastMessageTimestamp, fetchMore, sdk]);\n}\nfunction useCheckScrollBottom(_a, _b) {\n  var conversationScrollRef = _a.conversationScrollRef;\n  var logger = _b.logger;\n  return useCallback(function () {\n    var isBottom = true;\n    if (conversationScrollRef && (conversationScrollRef === null || conversationScrollRef === void 0 ? void 0 : conversationScrollRef.current)) {\n      try {\n        var conversationScroll = conversationScrollRef.current;\n        isBottom = conversationScroll.scrollHeight <= conversationScroll.scrollTop + conversationScroll.clientHeight;\n      } catch (error) {\n        logger.error('OpenChannel | useCheckScrollBottom', error);\n      }\n    }\n    return isBottom;\n  }, [conversationScrollRef]);\n}\nfunction useSendMessageCallback(_a, _b) {\n  var currentOpenChannel = _a.currentOpenChannel,\n    onBeforeSendUserMessage = _a.onBeforeSendUserMessage,\n    messageInputRef = _a.messageInputRef;\n  var sdk = _b.sdk,\n    logger = _b.logger,\n    messagesDispatcher = _b.messagesDispatcher,\n    scrollRef = _b.scrollRef;\n  return useCallback(function () {\n    var _a;\n    if (sdk) {\n      var text = (_a = messageInputRef.current) === null || _a === void 0 ? void 0 : _a.innerText;\n      var createParamsDefault = function (txt) {\n        var message = txt;\n        var params = {\n          message: message\n        };\n        return params;\n      };\n      var createCustomParams = onBeforeSendUserMessage && typeof onBeforeSendUserMessage === 'function';\n      if (createCustomParams) {\n        logger.info('OpenChannel | useSendMessageCallback: Creating params using onBeforeSendUserMessage', onBeforeSendUserMessage);\n      }\n      var params = onBeforeSendUserMessage ? onBeforeSendUserMessage(text !== null && text !== void 0 ? text : '') : createParamsDefault(text !== null && text !== void 0 ? text : '');\n      logger.info('OpenChannel | useSendMessageCallback: Sending message has started', params);\n      var pendingMsg_1;\n      currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.sendUserMessage(params).onPending(function (pendingMessage) {\n        messagesDispatcher({\n          type: SENDING_MESSAGE_START,\n          payload: {\n            message: pendingMessage,\n            channel: currentOpenChannel\n          }\n        });\n        pendingMsg_1 = pendingMessage;\n        setTimeout(function () {\n          return scrollIntoLast(0, scrollRef);\n        });\n      }).onSucceeded(function (message) {\n        logger.info('OpenChannel | useSendMessageCallback: Sending message succeeded', message);\n        messagesDispatcher({\n          type: SENDING_MESSAGE_SUCCEEDED,\n          payload: message\n        });\n      }).onFailed(function (error) {\n        logger.warning('OpenChannel | useSendMessageCallback: Sending message failed', error);\n        messagesDispatcher({\n          type: SENDING_MESSAGE_FAILED,\n          payload: pendingMsg_1\n        });\n        // https://sendbird.com/docs/chat/v3/javascript/guides/error-codes#2-server-error-codes\n        // TODO: Do we need to handle the error cases?\n        // @ts-ignore\n        if ((error === null || error === void 0 ? void 0 : error.code) === 900041) {\n          messagesDispatcher({\n            type: ON_USER_MUTED,\n            payload: {\n              channel: currentOpenChannel,\n              user: sdk.currentUser\n            }\n          });\n        }\n      });\n    }\n  }, [currentOpenChannel, onBeforeSendUserMessage, messageInputRef]);\n}\nfunction useFileUploadCallback(_a, _b) {\n  var _this = this;\n  var currentOpenChannel = _a.currentOpenChannel,\n    _c = _a.imageCompression,\n    imageCompression = _c === void 0 ? {} : _c,\n    onBeforeSendFileMessage = _a.onBeforeSendFileMessage;\n  var sdk = _b.sdk,\n    logger = _b.logger,\n    messagesDispatcher = _b.messagesDispatcher,\n    scrollRef = _b.scrollRef;\n  var stringSet = useLocalization().stringSet;\n  var openModal = useGlobalModalContext().openModal;\n  var config = useSendbirdStateContext().config;\n  var uikitUploadSizeLimit = config.uikitUploadSizeLimit;\n  return useCallback(function (files) {\n    return __awaiter(_this, void 0, void 0, function () {\n      var file_1, createCustomParams, createParamsDefault, compressedFiles, compressedFile, params;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!sdk) return [3 /*break*/, 2];\n            file_1 = Array.isArray(files) ? files[0] : files;\n            createCustomParams = onBeforeSendFileMessage && typeof onBeforeSendFileMessage === 'function';\n            createParamsDefault = function (file) {\n              var params = {};\n              params.file = file;\n              return params;\n            };\n            /**\n             * Validate file sizes\n             * The default value of uikitUploadSizeLimit is 25MiB\n             */\n            if (file_1.size > uikitUploadSizeLimit) {\n              logger.info(\"OpenChannel | useFileUploadCallback: Cannot upload file size exceeding \".concat(uikitUploadSizeLimit));\n              openModal({\n                modalProps: {\n                  titleText: stringSet.FILE_UPLOAD_NOTIFICATION__SIZE_LIMIT.replace('%d', \"\".concat(Math.floor(uikitUploadSizeLimit / ONE_MiB))),\n                  hideFooter: true\n                },\n                childElement: function (_a) {\n                  var closeModal = _a.closeModal;\n                  return React__default.createElement(ModalFooter, {\n                    type: ButtonTypes.PRIMARY,\n                    submitText: stringSet.BUTTON__OK,\n                    hideCancelButton: true,\n                    onCancel: closeModal,\n                    onSubmit: closeModal\n                  });\n                }\n              });\n              return [2 /*return*/];\n            }\n            return [4 /*yield*/, compressImages({\n              files: [file_1],\n              imageCompression: imageCompression,\n              logger: logger\n            })];\n          case 1:\n            compressedFiles = _a.sent().compressedFiles;\n            compressedFile = compressedFiles[0];\n            // Send FileMessage\n            if (createCustomParams) {\n              logger.info('OpenChannel | useFileUploadCallback: Creating params using onBeforeSendFileMessage', onBeforeSendFileMessage);\n            }\n            params = onBeforeSendFileMessage ? onBeforeSendFileMessage(compressedFile) : createParamsDefault(compressedFile);\n            logger.info('OpenChannel | useFileUploadCallback: Uploading file message start', params);\n            currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.sendFileMessage(params).onPending(function (pendingMessage) {\n              messagesDispatcher({\n                type: SENDING_MESSAGE_START,\n                payload: {\n                  // TODO: remove data pollution\n                  message: __assign(__assign({}, pendingMessage), {\n                    url: URL.createObjectURL(file_1),\n                    // pending thumbnail message seems to be failed\n                    requestState: 'pending',\n                    isUserMessage: pendingMessage.isUserMessage,\n                    isFileMessage: pendingMessage.isFileMessage,\n                    isAdminMessage: pendingMessage.isAdminMessage,\n                    isMultipleFilesMessage: pendingMessage.isMultipleFilesMessage\n                  }),\n                  channel: currentOpenChannel\n                }\n              });\n              setTimeout(function () {\n                return scrollIntoLast(0, scrollRef);\n              });\n            }).onSucceeded(function (message) {\n              logger.info('OpenChannel | useFileUploadCallback: Sending message succeeded', message);\n              messagesDispatcher({\n                type: SENDING_MESSAGE_SUCCEEDED,\n                payload: message\n              });\n            }).onFailed(function (error, message) {\n              logger.error('OpenChannel | useFileUploadCallback: Sending file message failed', {\n                message: message,\n                error: error\n              });\n              // @ts-ignore\n              message.localUrl = URL.createObjectURL(file_1);\n              // @ts-ignore\n              message.file = file_1;\n              messagesDispatcher({\n                type: SENDING_MESSAGE_FAILED,\n                payload: message\n              });\n            });\n            _a.label = 2;\n          case 2:\n            return [2 /*return*/];\n        }\n      });\n    });\n  }, [currentOpenChannel, onBeforeSendFileMessage, imageCompression]);\n}\nfunction useUpdateMessageCallback(_a, _b) {\n  var currentOpenChannel = _a.currentOpenChannel,\n    onBeforeSendUserMessage = _a.onBeforeSendUserMessage;\n  var logger = _b.logger,\n    messagesDispatcher = _b.messagesDispatcher;\n  return useCallback(function (messageId, text, callback) {\n    var createParamsDefault = function (txt) {\n      return {\n        message: txt\n      };\n    };\n    if (onBeforeSendUserMessage && typeof onBeforeSendUserMessage === 'function') {\n      logger.info('OpenChannel | useUpdateMessageCallback: Creating params using onBeforeUpdateUserMessage');\n    }\n    var params = onBeforeSendUserMessage ? onBeforeSendUserMessage(text) : createParamsDefault(text);\n    currentOpenChannel.updateUserMessage(messageId, params).then(function (message) {\n      if (callback) {\n        callback();\n      }\n      logger.info('OpenChannel | useUpdateMessageCallback: Updating message succeeded', {\n        message: message,\n        params: params\n      });\n      messagesDispatcher({\n        type: ON_MESSAGE_UPDATED,\n        payload: {\n          channel: currentOpenChannel,\n          message: message\n        }\n      });\n    });\n  }, [currentOpenChannel, onBeforeSendUserMessage]);\n}\nfunction useDeleteMessageCallback(_a, _b) {\n  var currentOpenChannel = _a.currentOpenChannel;\n  var logger = _b.logger,\n    messagesDispatcher = _b.messagesDispatcher;\n  return useCallback(function (message, callback) {\n    logger.info('OpenChannel | useDeleteMessageCallback: Deleting message', message);\n    var sendingStatus = message.sendingStatus;\n    logger.info('OpenChannel | useDeleteMessageCallback: Deleting message requestState', sendingStatus);\n    if (sendingStatus === 'failed' || sendingStatus === 'pending') {\n      logger.info('OpenChannel | useDeleteMessageCallback: Deleted message from local', message);\n      messagesDispatcher({\n        type: ON_MESSAGE_DELETED_BY_REQ_ID,\n        payload: message.reqId\n      });\n      if (callback) {\n        callback();\n      }\n    } else {\n      if (!(message.messageType === 'file' || message.messageType === 'user')) {\n        return;\n      }\n      var messageToDelete = message;\n      currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.deleteMessage(messageToDelete).then(function () {\n        logger.info('OpenChannel | useDeleteMessageCallback: Deleting message on server', sendingStatus);\n        if (callback) {\n          callback();\n        }\n        logger.info('OpenChannel | useDeleteMessageCallback: Deleting message succeeded', message);\n        messagesDispatcher({\n          type: ON_MESSAGE_DELETED,\n          payload: {\n            channel: currentOpenChannel,\n            messageId: message.messageId\n          }\n        });\n      }).catch(function (error) {\n        logger.warning('OpenChannel | useDeleteMessageCallback: Deleting message failed', error);\n      });\n    }\n  }, [currentOpenChannel]);\n}\nfunction useResendMessageCallback(_a, _b) {\n  var currentOpenChannel = _a.currentOpenChannel;\n  var logger = _b.logger,\n    messagesDispatcher = _b.messagesDispatcher;\n  return useCallback(function (failedMessage) {\n    logger.info('OpenChannel | useResendMessageCallback: Resending message has started', failedMessage);\n    if (typeof (failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.isResendable) === 'boolean' && failedMessage.isResendable) {\n      // userMessage\n      if (failedMessage.isUserMessage()) {\n        currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.resendMessage(failedMessage).onPending(function (message) {\n          messagesDispatcher({\n            type: RESENDING_MESSAGE_START,\n            payload: {\n              channel: currentOpenChannel,\n              message: message\n            }\n          });\n        }).onSucceeded(function (message) {\n          logger.info('OpenChannel | useResendMessageCallback: Reseding message succeeded', message);\n          messagesDispatcher({\n            type: SENDING_MESSAGE_SUCCEEDED,\n            payload: message\n          });\n        }).onFailed(function (error, message) {\n          logger.warning('OpenChannel | useResendMessageCallback: Resending message failed', error);\n          messagesDispatcher({\n            type: SENDING_MESSAGE_FAILED,\n            payload: message\n          });\n        });\n      }\n      // fileMessage\n      if (failedMessage.isFileMessage()) {\n        currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.resendMessage(failedMessage).onPending(function (message) {\n          messagesDispatcher({\n            type: RESENDING_MESSAGE_START,\n            payload: {\n              channel: currentOpenChannel,\n              message: message\n            }\n          });\n        }).onSucceeded(function (message) {\n          logger.info('OpenChannel | useResendMessageCallback: Resending file message succeeded', message);\n          messagesDispatcher({\n            type: SENDING_MESSAGE_SUCCEEDED,\n            payload: message\n          });\n        }).onFailed(function (error, message) {\n          logger.warning('OpenChannel | useResendMessageCallback: Resending file message failed', error);\n          messagesDispatcher({\n            type: SENDING_MESSAGE_FAILED,\n            payload: message\n          });\n        });\n      }\n    } else {\n      // to alert user on console\n      // eslint-disable-next-line no-console\n      console.error('OpenChannel | useResendMessageCallback: Message is not resendable');\n      logger.warning('OpenChannel | useResendMessageCallback: Message is not resendable', failedMessage);\n    }\n  }, [currentOpenChannel]);\n}\nvar THROTTLE_TIMER = 5000;\n// to trim message list so that we wont keep thousands of messages in memory\n// We are throttling here; not debouncing\n// it will be called once very 5 sec if messagesLength, messageLimit changes\n// we check if messagesLength > messageLimit before dispatching action\nfunction useTrimMessageList(_a, _b) {\n  var messagesLength = _a.messagesLength,\n    messageLimit = _a.messageLimit;\n  var messagesDispatcher = _b.messagesDispatcher,\n    logger = _b.logger;\n  var _c = useState(false),\n    inProgress = _c[0],\n    setInProgress = _c[1];\n  useEffect(function () {\n    if (inProgress) {\n      return;\n    }\n    if (typeof messagesLength === 'number' && typeof messageLimit === 'number' && messagesLength > messageLimit) {\n      logger.info('Trimming MessageList');\n      messagesDispatcher({\n        type: TRIM_MESSAGE_LIST,\n        payload: {\n          messageLimit: messageLimit\n        }\n      });\n    }\n    setInProgress(true);\n    setTimeout(function () {\n      setInProgress(false);\n    }, THROTTLE_TIMER);\n  }, [messagesLength, messageLimit]);\n}\nvar OpenChannelContext = React__default.createContext(null);\nvar OpenChannelProvider = function (props) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  var channelUrl = props.channelUrl,\n    children = props.children,\n    _h = props.isMessageGroupingEnabled,\n    isMessageGroupingEnabled = _h === void 0 ? true : _h,\n    queries = props.queries,\n    onBeforeSendUserMessage = props.onBeforeSendUserMessage,\n    messageLimit = props.messageLimit,\n    onBeforeSendFileMessage = props.onBeforeSendFileMessage,\n    onChatHeaderActionClick = props.onChatHeaderActionClick,\n    onBackClick = props.onBackClick,\n    disableUserProfile = props.disableUserProfile,\n    renderUserProfile = props.renderUserProfile;\n  // We didn't decide to support fetching participant list\n  var fetchingParticipants = false;\n  var globalStore = useSendbirdStateContext();\n  var sdk = (_b = (_a = globalStore === null || globalStore === void 0 ? void 0 : globalStore.stores) === null || _a === void 0 ? void 0 : _a.sdkStore) === null || _b === void 0 ? void 0 : _b.sdk;\n  var sdkInit = (_d = (_c = globalStore === null || globalStore === void 0 ? void 0 : globalStore.stores) === null || _c === void 0 ? void 0 : _c.sdkStore) === null || _d === void 0 ? void 0 : _d.initialized;\n  var user = (_f = (_e = globalStore === null || globalStore === void 0 ? void 0 : globalStore.stores) === null || _e === void 0 ? void 0 : _e.userStore) === null || _f === void 0 ? void 0 : _f.user;\n  var config = globalStore === null || globalStore === void 0 ? void 0 : globalStore.config;\n  var userId = config.userId,\n    isOnline = config.isOnline,\n    logger = config.logger,\n    pubSub = config.pubSub,\n    imageCompression = config.imageCompression;\n  // hook variables\n  var _j = useReducer(reducer, initialState),\n    messagesStore = _j[0],\n    messagesDispatcher = _j[1];\n  var allMessages = messagesStore.allMessages,\n    loading = messagesStore.loading,\n    initialized = messagesStore.initialized,\n    currentOpenChannel = messagesStore.currentOpenChannel,\n    isInvalid = messagesStore.isInvalid,\n    hasMore = messagesStore.hasMore,\n    lastMessageTimestamp = messagesStore.lastMessageTimestamp,\n    operators = messagesStore.operators,\n    bannedParticipantIds = messagesStore.bannedParticipantIds,\n    mutedParticipantIds = messagesStore.mutedParticipantIds;\n  // ref\n  var messageInputRef = useRef(null); // useSendMessageCallback\n  var conversationScrollRef = useRef(null); // useScrollAfterSendMessageCallback\n  // const\n  var userFilledMessageListParams = queries === null || queries === void 0 ? void 0 : queries.messageListParams;\n  var disabled = !initialized || !isOnline || isDisabledBecauseFrozen(currentOpenChannel, userId) || isDisabledBecauseMuted(mutedParticipantIds, userId);\n  // useMemo\n  var amIBanned = useMemo(function () {\n    return bannedParticipantIds.indexOf(user.userId) >= 0;\n  }, [channelUrl, bannedParticipantIds, user]);\n  var amIMuted = useMemo(function () {\n    return mutedParticipantIds.indexOf(user.userId) >= 0;\n  }, [channelUrl, mutedParticipantIds, user]);\n  var amIOperator = useMemo(function () {\n    return operators.map(function (operator) {\n      return operator.userId;\n    }).indexOf(user.userId) >= 0;\n  }, [channelUrl, operators, user]);\n  // use hooks\n  useSetChannel({\n    channelUrl: channelUrl,\n    sdkInit: sdkInit,\n    fetchingParticipants: fetchingParticipants,\n    userId: userId,\n    currentOpenChannel: currentOpenChannel\n  }, {\n    sdk: sdk,\n    logger: logger,\n    messagesDispatcher: messagesDispatcher\n  });\n  var checkScrollBottom = useCheckScrollBottom({\n    conversationScrollRef: conversationScrollRef\n  }, {\n    logger: logger\n  });\n  useHandleChannelEvents({\n    currentOpenChannel: currentOpenChannel,\n    checkScrollBottom: checkScrollBottom\n  }, {\n    sdk: sdk,\n    logger: logger,\n    messagesDispatcher: messagesDispatcher,\n    scrollRef: conversationScrollRef\n  });\n  useInitialMessagesFetch({\n    currentOpenChannel: currentOpenChannel,\n    userFilledMessageListParams: userFilledMessageListParams\n  }, {\n    logger: logger,\n    messagesDispatcher: messagesDispatcher,\n    scrollRef: conversationScrollRef\n  });\n  var fetchMore = shouldFetchMore(allMessages === null || allMessages === void 0 ? void 0 : allMessages.length, messageLimit);\n  // do not fetch more for streaming\n  var onScroll = useScrollCallback({\n    currentOpenChannel: currentOpenChannel,\n    lastMessageTimestamp: lastMessageTimestamp,\n    fetchMore: fetchMore\n  }, {\n    sdk: sdk,\n    logger: logger,\n    messagesDispatcher: messagesDispatcher,\n    hasMore: hasMore,\n    userFilledMessageListParams: userFilledMessageListParams\n  });\n  var handleSendMessage = useSendMessageCallback({\n    currentOpenChannel: currentOpenChannel,\n    onBeforeSendUserMessage: onBeforeSendUserMessage,\n    checkScrollBottom: checkScrollBottom,\n    messageInputRef: messageInputRef\n  }, {\n    sdk: sdk,\n    logger: logger,\n    messagesDispatcher: messagesDispatcher,\n    scrollRef: conversationScrollRef\n  });\n  var handleFileUpload = useFileUploadCallback({\n    currentOpenChannel: currentOpenChannel,\n    onBeforeSendFileMessage: onBeforeSendFileMessage,\n    checkScrollBottom: checkScrollBottom,\n    imageCompression: imageCompression\n  }, {\n    sdk: sdk,\n    logger: logger,\n    messagesDispatcher: messagesDispatcher,\n    scrollRef: conversationScrollRef\n  });\n  var updateMessage = useUpdateMessageCallback({\n    currentOpenChannel: currentOpenChannel,\n    onBeforeSendUserMessage: onBeforeSendUserMessage\n  }, {\n    logger: logger,\n    messagesDispatcher: messagesDispatcher\n  });\n  var deleteMessage = useDeleteMessageCallback({\n    currentOpenChannel: currentOpenChannel\n  }, {\n    logger: logger,\n    messagesDispatcher: messagesDispatcher\n  });\n  var resendMessage = useResendMessageCallback({\n    currentOpenChannel: currentOpenChannel\n  }, {\n    logger: logger,\n    messagesDispatcher: messagesDispatcher\n  });\n  useTrimMessageList({\n    messagesLength: allMessages === null || allMessages === void 0 ? void 0 : allMessages.length,\n    messageLimit: messageLimit\n  }, {\n    messagesDispatcher: messagesDispatcher,\n    logger: logger\n  });\n  // handle API calls from withSendbird\n  useEffect(function () {\n    var subscriber = new Map();\n    if (!pubSub || !pubSub.subscribe) {\n      return;\n    }\n    subscriber.set(pubSubTopics.SEND_USER_MESSAGE, pubSub.subscribe(pubSubTopics.SEND_USER_MESSAGE, function (msg) {\n      var channel = msg.channel,\n        message = msg.message;\n      scrollIntoLast(0, conversationScrollRef);\n      if (channel && channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n        messagesDispatcher({\n          type: SENDING_MESSAGE_SUCCEEDED,\n          payload: message\n        });\n      }\n    }));\n    subscriber.set(pubSubTopics.SEND_MESSAGE_START, pubSub.subscribe(pubSubTopics.SEND_MESSAGE_START, function (msg) {\n      var channel = msg.channel,\n        message = msg.message;\n      if (channel && channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n        messagesDispatcher({\n          type: SENDING_MESSAGE_START,\n          payload: {\n            message: message,\n            channel: channel\n          }\n        });\n      }\n    }));\n    subscriber.set(pubSubTopics.SEND_FILE_MESSAGE, pubSub.subscribe(pubSubTopics.SEND_FILE_MESSAGE, function (msg) {\n      var channel = msg.channel,\n        message = msg.message;\n      scrollIntoLast(0, conversationScrollRef);\n      if (channel && channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n        messagesDispatcher({\n          type: SENDING_MESSAGE_SUCCEEDED,\n          payload: {\n            message: message,\n            channel: channel\n          }\n        });\n      }\n    }));\n    subscriber.set(pubSubTopics.UPDATE_USER_MESSAGE, pubSub.subscribe(pubSubTopics.UPDATE_USER_MESSAGE, function (msg) {\n      var channel = msg.channel,\n        message = msg.message,\n        fromSelector = msg.fromSelector;\n      if (fromSelector && channel && channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n        messagesDispatcher({\n          type: ON_MESSAGE_UPDATED,\n          payload: {\n            channel: channel,\n            message: message\n          }\n        });\n      }\n    }));\n    subscriber.set(pubSubTopics.DELETE_MESSAGE, pubSub.subscribe(pubSubTopics.DELETE_MESSAGE, function (msg) {\n      var channel = msg.channel,\n        messageId = msg.messageId;\n      if (channel && channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n        messagesDispatcher({\n          type: ON_MESSAGE_DELETED,\n          payload: messageId\n        });\n      }\n    }));\n    return function () {\n      if (subscriber) {\n        subscriber.forEach(function (s) {\n          try {\n            s.remove();\n          } catch (_a) {\n            //\n          }\n        });\n      }\n    };\n  }, [channelUrl, sdkInit]);\n  return React__default.createElement(OpenChannelContext.Provider, {\n    value: {\n      // props\n      channelUrl: channelUrl,\n      children: children,\n      isMessageGroupingEnabled: isMessageGroupingEnabled,\n      queries: queries,\n      onBeforeSendUserMessage: onBeforeSendUserMessage,\n      messageLimit: messageLimit,\n      onBeforeSendFileMessage: onBeforeSendFileMessage,\n      onChatHeaderActionClick: onChatHeaderActionClick,\n      onBackClick: onBackClick,\n      // store\n      allMessages: allMessages,\n      loading: loading,\n      initialized: initialized,\n      currentOpenChannel: currentOpenChannel,\n      isInvalid: isInvalid,\n      hasMore: hasMore,\n      lastMessageTimestamp: lastMessageTimestamp,\n      operators: operators,\n      bannedParticipantIds: bannedParticipantIds,\n      mutedParticipantIds: mutedParticipantIds,\n      // derived/utils\n      messageInputRef: messageInputRef,\n      conversationScrollRef: conversationScrollRef,\n      disabled: disabled,\n      amIBanned: amIBanned,\n      amIMuted: amIMuted,\n      amIOperator: amIOperator,\n      checkScrollBottom: checkScrollBottom,\n      fetchMore: fetchMore,\n      onScroll: onScroll,\n      handleSendMessage: handleSendMessage,\n      handleFileUpload: handleFileUpload,\n      updateMessage: updateMessage,\n      deleteMessage: deleteMessage,\n      resendMessage: resendMessage,\n      frozen: messagesStore.frozen,\n      disableUserProfile: disableUserProfile,\n      renderUserProfile: renderUserProfile,\n      participants: messagesStore.participants\n    }\n  }, React__default.createElement(UserProfileProvider, {\n    isOpenChannel: true,\n    renderUserProfile: props === null || props === void 0 ? void 0 : props.renderUserProfile,\n    disableUserProfile: (_g = props === null || props === void 0 ? void 0 : props.disableUserProfile) !== null && _g !== void 0 ? _g : config === null || config === void 0 ? void 0 : config.disableUserProfile\n  }, children));\n};\nvar useOpenChannelContext = function () {\n  var context = React__default.useContext(OpenChannelContext);\n  if (!context) throw new Error('OpenChannelContext not found. Use within the OpenChannel module');\n  return context;\n};\nexport { OpenChannelProvider as O, kFormatter as k, useOpenChannelContext as u };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import React__default, { useEffect, useCallback, useState, useReducer, useRef, useMemo } from 'react';\nimport { U as UserProfileProvider } from './bundle-BrTJ5Zbd.js';\nimport { _ as __assign, c as __spreadArray, a as __awaiter, b as __generator } from './bundle-BQi9-O76.js';\nimport { c as compareIds } from './bundle-CZUYMubi.js';\nimport { p as pubSubTopics } from './bundle-b6TpX_JP.js';\nimport { ChannelType } from '@sendbird/chat';\nimport { OpenChannelHandler } from '@sendbird/chat/openChannel';\nimport { u as uuidv4 } from './bundle-etuaqevl.js';\nimport { c as compressImages } from './bundle-DAz5E5O_.js';\nimport { useSendbirdStateContext } from '../useSendbirdStateContext.js';\nimport { b as useGlobalModalContext, c as ModalFooter } from './bundle-CXdo2kR_.js';\nimport { u as useLocalization } from './bundle-cQZ3UZoG.js';\nimport { O as ONE_MiB } from './bundle-DCMGp6rH.js';\nimport './bundle-DhKQeIfP.js';\nimport { ButtonTypes } from '../ui/Button.js';\n\nvar shouldFetchMore = function (messageLength, maxMessages) {\n    if (typeof maxMessages !== 'number') {\n        return true;\n    }\n    return maxMessages > messageLength;\n};\n/* eslint-disable default-param-last */\nvar scrollIntoLast = function (initialTry, scrollRef) {\n    if (initialTry === void 0) { initialTry = 0; }\n    var MAX_TRIES = 10;\n    var currentTry = initialTry;\n    if (currentTry > MAX_TRIES) {\n        return;\n    }\n    try {\n        var scrollDOM = (scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current) || document.querySelector('.sendbird-openchannel-conversation-scroll__container__item-container');\n        // eslint-disable-next-line no-multi-assign\n        if (scrollDOM) {\n            scrollDOM.scrollTop = scrollDOM.scrollHeight;\n        }\n    }\n    catch (error) {\n        setTimeout(function () {\n            scrollIntoLast(currentTry + 1, scrollRef);\n        }, 500 * currentTry);\n    }\n};\nvar kFormatter = function (num) {\n    if (Math.abs(num) > 999999) {\n        return \"\".concat((Math.abs(num) / 1000000).toFixed(1), \"M\");\n    }\n    if (Math.abs(num) > 999) {\n        return \"\".concat((Math.abs(num) / 1000).toFixed(1), \"K\");\n    }\n    return \"\".concat(num);\n};\nvar isOperator = function (openChannel, userId) {\n    var operators = openChannel === null || openChannel === void 0 ? void 0 : openChannel.operators;\n    if (operators.map(function (operator) { return operator.userId; }).indexOf(userId) < 0) {\n        return false;\n    }\n    return true;\n};\nvar isDisabledBecauseFrozen = function (openChannel, userId) {\n    if (!openChannel)\n        return false;\n    var isFrozen = openChannel.isFrozen;\n    return isFrozen && !isOperator(openChannel, userId);\n};\nvar isDisabledBecauseMuted = function (mutedParticipantIds, userId) {\n    return mutedParticipantIds.indexOf(userId) > -1;\n};\nvar fetchWithListQuery = function (listQuery, logger, eachQueryNextCallback) {\n    var fetchList = function (query) {\n        var hasNext = query.hasNext;\n        if (hasNext) {\n            query.next().then(function (users) {\n                eachQueryNextCallback(users);\n                fetchList(query);\n            }).catch(function (error) {\n                logger.warning('OpenChannel | FetchUserList failed', error);\n            });\n        }\n        else {\n            logger.info('OpenChannel | FetchUserList finished');\n        }\n    };\n    logger.info('OpenChannel | FetchUserList start', listQuery);\n    fetchList(listQuery);\n};\n\nvar SET_CURRENT_CHANNEL = 'SET_CURRENT_CHANNEL';\nvar SET_CHANNEL_INVALID = 'SET_CHANNEL_INVALID';\nvar RESET_MESSAGES = 'RESET_MESSAGES';\nvar EXIT_CURRENT_CHANNEL = 'EXIT_CURRENT_CHANNEL';\nvar GET_PREV_MESSAGES_START = 'GET_PREV_MESSAGES_START';\nvar GET_PREV_MESSAGES_SUCESS = 'GET_PREV_MESSAGES_SUCESS';\nvar GET_PREV_MESSAGES_FAIL = 'GET_PREV_MESSAGES_FAIL';\nvar SENDING_MESSAGE_FAILED = 'SENDING_MESSAGE_FAILED';\nvar SENDING_MESSAGE_SUCCEEDED = 'SENDING_MESSAGE_SUCCEEDED';\nvar SENDING_MESSAGE_START = 'SENDING_MESSAGE_START';\nvar RESENDING_MESSAGE_START = 'RESENDING_MESSAGE_START';\nvar FETCH_PARTICIPANT_LIST = 'FETCH_PARTICIPANT_LIST';\nvar FETCH_BANNED_USER_LIST = 'FETCH_BANNED_USER_LIST';\nvar FETCH_MUTED_USER_LIST = 'FETCH_MUTED_USER_LIST';\nvar TRIM_MESSAGE_LIST = 'TRIM_MESSAGE_LIST';\n// event handlers\nvar ON_MESSAGE_RECEIVED = 'ON_MESSAGE_RECEIVED';\nvar ON_MESSAGE_UPDATED = 'ON_MESSAGE_UPDATED';\nvar ON_MESSAGE_DELETED = 'ON_MESSAGE_DELETED';\nvar ON_MESSAGE_DELETED_BY_REQ_ID = 'ON_MESSAGE_DELETED_BY_REQ_ID';\nvar ON_OPERATOR_UPDATED = 'ON_OPERATOR_UPDATED';\nvar ON_USER_ENTERED = 'ON_USER_ENTERED';\nvar ON_USER_EXITED = 'ON_USER_EXITED';\nvar ON_USER_MUTED = 'ON_USER_MUTED';\nvar ON_USER_UNMUTED = 'ON_USER_UNMUTED';\nvar ON_USER_BANNED = 'ON_USER_BANNED';\nvar ON_USER_UNBANNED = 'ON_USER_UNBANNED';\nvar ON_CHANNEL_FROZEN = 'ON_CHANNEL_FROZEN';\nvar ON_CHANNEL_UNFROZEN = 'ON_CHANNEL_UNFROZEN';\nvar ON_CHANNEL_CHANGED = 'ON_CHANNEL_CHANGED';\nvar ON_CHANNEL_DELETED = 'ON_CHANNEL_DELETED';\nvar ON_META_DATA_CREATED = 'ON_META_DATA_CREATED';\nvar ON_META_DATA_UPDATED = 'ON_META_DATA_UPDATED';\nvar ON_META_DATA_DELETED = 'ON_META_DATA_DELETED';\nvar ON_META_COUNTERS_CREATED = 'ON_META_COUNTERS_CREATED';\nvar ON_META_COUNTERS_UPDATED = 'ON_META_COUNTERS_UPDATED';\nvar ON_META_COUNTERS_DELETED = 'ON_META_COUNTERS_DELETED';\nvar ON_MENTION_RECEIVED = 'ON_MENTION_RECEIVED';\n\nfunction reducer(state, action) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    switch (action.type) {\n        case RESET_MESSAGES: {\n            return __assign(__assign({}, state), { allMessages: [] });\n        }\n        case EXIT_CURRENT_CHANNEL: {\n            if (((_a = action.payload) === null || _a === void 0 ? void 0 : _a.url) === ((_b = state.currentOpenChannel) === null || _b === void 0 ? void 0 : _b.url)) {\n                return __assign(__assign({}, state), { currentOpenChannel: null });\n            }\n            return state;\n        }\n        case SET_CURRENT_CHANNEL: {\n            var gottenChannel = action.payload;\n            var operators = gottenChannel.operators;\n            if (!state.isInvalid\n                && state.currentOpenChannel\n                && state.currentOpenChannel.url\n                && (state.currentOpenChannel.url === gottenChannel.url)) {\n                return state;\n            }\n            return __assign(__assign({}, state), { currentOpenChannel: gottenChannel, isInvalid: false, operators: operators, participants: operators, bannedParticipantIds: [], mutedParticipantIds: [] });\n        }\n        case SET_CHANNEL_INVALID: {\n            return __assign(__assign({}, state), { isInvalid: true });\n        }\n        case GET_PREV_MESSAGES_START: {\n            return __assign(__assign({}, state), { loading: true });\n        }\n        case GET_PREV_MESSAGES_SUCESS:\n        case GET_PREV_MESSAGES_FAIL: {\n            var isFailed = (action.type === GET_PREV_MESSAGES_FAIL);\n            var _j = action.payload, _k = _j.currentOpenChannel, currentOpenChannel = _k === void 0 ? {} : _k, _l = _j.messages, messages = _l === void 0 ? [] : _l, hasMore = _j.hasMore, lastMessageTimestamp = _j.lastMessageTimestamp;\n            var actionChannelUrl = currentOpenChannel.url;\n            var receivedMessages_1 = (isFailed ? [] : messages);\n            var _hasMore = isFailed ? false : hasMore;\n            var _lastMessageTimestamp = isFailed ? 0 : lastMessageTimestamp;\n            var stateChannel = state.currentOpenChannel;\n            var stateChannelUrl = stateChannel === null || stateChannel === void 0 ? void 0 : stateChannel.url;\n            if (actionChannelUrl !== stateChannelUrl) {\n                return state;\n            }\n            var filteredAllMessages = state.allMessages.filter(function (message) { return (!(receivedMessages_1.find(function (_a) {\n                var messageId = _a.messageId;\n                return compareIds(messageId, message.messageId);\n            }))); });\n            return __assign(__assign({}, state), { loading: false, initialized: true, hasMore: _hasMore, lastMessageTimestamp: _lastMessageTimestamp, allMessages: __spreadArray(__spreadArray([], receivedMessages_1, true), filteredAllMessages, true) });\n        }\n        case SENDING_MESSAGE_START: {\n            var _m = action.payload, message_1 = _m.message, channel = _m.channel;\n            if ((channel === null || channel === void 0 ? void 0 : channel.url) !== ((_c = state.currentOpenChannel) === null || _c === void 0 ? void 0 : _c.url)\n                || state.allMessages.some(function (m) { return m.reqId === message_1.reqId; })\n            // Handing failed first than sending start issue\n            ) {\n                return state;\n            }\n            return __assign(__assign({}, state), { allMessages: __spreadArray(__spreadArray([], state.allMessages, true), [\n                    message_1,\n                ], false) });\n        }\n        case SENDING_MESSAGE_SUCCEEDED: {\n            var sentMessage_1 = action.payload;\n            var newMessages = state.allMessages.map(function (m) { return (compareIds(m.reqId, sentMessage_1.reqId) ? sentMessage_1 : m); });\n            return __assign(__assign({}, state), { allMessages: newMessages });\n        }\n        case SENDING_MESSAGE_FAILED: {\n            var sentMessage_2 = action.payload;\n            sentMessage_2.sendingStatus = 'failed';\n            if (!(state.allMessages.some(function (m) { return (m === null || m === void 0 ? void 0 : m.reqId) === (sentMessage_2 === null || sentMessage_2 === void 0 ? void 0 : sentMessage_2.reqId); }))) {\n                // Handling failed first than sending start issue\n                return __assign(__assign({}, state), { allMessages: __spreadArray(__spreadArray([], state.allMessages.filter(function (m) { return !compareIds(m.reqId, sentMessage_2); }), true), [\n                        sentMessage_2,\n                    ], false) });\n            }\n            else {\n                return __assign(__assign({}, state), { allMessages: state.allMessages.map(function (m) { return (compareIds(m.reqId, sentMessage_2.reqId) ? sentMessage_2 : m); }) });\n            }\n        }\n        case TRIM_MESSAGE_LIST: {\n            var allMessages = state.allMessages;\n            var messageLimit = (_d = action.payload) === null || _d === void 0 ? void 0 : _d.messageLimit;\n            if (messageLimit\n                && messageLimit > 0\n                && (allMessages === null || allMessages === void 0 ? void 0 : allMessages.length) > messageLimit) {\n                var sliceAt = allMessages.length - messageLimit;\n                return __assign(__assign({}, state), { allMessages: allMessages.slice(sliceAt) });\n            }\n            return state;\n        }\n        case RESENDING_MESSAGE_START: {\n            var eventedChannel = action.payload.channel;\n            var resentMessage_1 = action.payload.message;\n            if (eventedChannel.url !== ((_e = state.currentOpenChannel) === null || _e === void 0 ? void 0 : _e.url)) {\n                return state;\n            }\n            return __assign(__assign({}, state), { allMessages: state.allMessages.map(function (m) { return (compareIds(m.reqId, resentMessage_1.reqId) ? resentMessage_1 : m); }) });\n        }\n        case FETCH_PARTICIPANT_LIST: {\n            var eventedChannel = action.payload.channel;\n            var fetchedParticipantList = action.payload.users;\n            if (eventedChannel.url !== ((_f = state.currentOpenChannel) === null || _f === void 0 ? void 0 : _f.url)) {\n                return state;\n            }\n            return __assign(__assign({}, state), { participants: __spreadArray(__spreadArray([], state.participants, true), fetchedParticipantList, true) });\n        }\n        case FETCH_BANNED_USER_LIST: {\n            var eventedChannel = action.payload.channel;\n            var fetchedBannedUserList = action.payload.users;\n            if ((eventedChannel.url !== ((_g = state.currentOpenChannel) === null || _g === void 0 ? void 0 : _g.url))\n                || !(fetchedBannedUserList.every(function (user) { return typeof user.userId === 'string'; }))) {\n                return state;\n            }\n            return __assign(__assign({}, state), { bannedParticipantIds: __spreadArray(__spreadArray([], state.bannedParticipantIds, true), fetchedBannedUserList.map(function (user) { return user.userId; }), true) });\n        }\n        case FETCH_MUTED_USER_LIST: {\n            var eventedChannel = action.payload.channel;\n            var fetchedMutedUserList = action.payload.users;\n            if ((eventedChannel.url !== ((_h = state.currentOpenChannel) === null || _h === void 0 ? void 0 : _h.url))\n                || !(fetchedMutedUserList.every(function (user) { return typeof user.userId === 'string'; }))) {\n                return state;\n            }\n            return __assign(__assign({}, state), { mutedParticipantIds: __spreadArray(__spreadArray([], state.mutedParticipantIds, true), fetchedMutedUserList.map(function (user) { return user.userId; }), true) });\n        }\n        // events\n        case ON_MESSAGE_RECEIVED: {\n            var eventedChannel = action.payload.channel;\n            var receivedMessage = action.payload.message;\n            var currentOpenChannel = state.currentOpenChannel;\n            if (!compareIds(eventedChannel.url, currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.url)\n                || (!(state.allMessages.map(function (message) { return message.messageId; }).indexOf(receivedMessage.messageId) < 0))) {\n                return state;\n            }\n            return __assign(__assign({}, state), { allMessages: __spreadArray(__spreadArray([], state.allMessages, true), [receivedMessage], false) });\n        }\n        case ON_MESSAGE_UPDATED: {\n            var eventedChannel = action.payload.channel;\n            var updatedMessage_1 = action.payload.message;\n            var currentChannel = state.currentOpenChannel;\n            if (!currentChannel || currentChannel.url && (currentChannel.url !== eventedChannel.url)) {\n                return state;\n            }\n            return __assign(__assign({}, state), { allMessages: state.allMessages.map(function (message) { return (message.isIdentical(updatedMessage_1)\n                    ? updatedMessage_1\n                    : message); }) });\n        }\n        case ON_MESSAGE_DELETED: {\n            var eventedChannel = action.payload.channel;\n            var deletedMessageId_1 = action.payload.messageId;\n            var currentChannel = state.currentOpenChannel;\n            if (!currentChannel || currentChannel.url && (currentChannel.url !== eventedChannel.url)) {\n                return state;\n            }\n            return __assign(__assign({}, state), { allMessages: state.allMessages.filter(function (message) { return (!compareIds(message.messageId, deletedMessageId_1)); }) });\n        }\n        case ON_MESSAGE_DELETED_BY_REQ_ID: {\n            return __assign(__assign({}, state), { allMessages: state.allMessages.filter(function (m) { return (!compareIds(m.reqId, action.payload)); }) });\n        }\n        case ON_OPERATOR_UPDATED: {\n            var eventedChannel = action.payload.channel;\n            var updatedOperators = action.payload.operators;\n            var currentChannel = state.currentOpenChannel;\n            if (!currentChannel || currentChannel.url && (currentChannel.url !== eventedChannel.url)) {\n                return state;\n            }\n            return __assign(__assign({}, state), { currentOpenChannel: eventedChannel, operators: updatedOperators });\n        }\n        case ON_USER_ENTERED: {\n            var eventedChannel = action.payload.channel;\n            var enteredUser = action.payload.user;\n            var currentChannel = state.currentOpenChannel;\n            if (!currentChannel || currentChannel.url && (currentChannel.url !== eventedChannel.url)) {\n                return state;\n            }\n            return __assign(__assign({}, state), { participants: __spreadArray(__spreadArray([], state.participants, true), [enteredUser], false) });\n        }\n        case ON_USER_EXITED: {\n            var eventedChannel = action.payload.channel;\n            var exitedUser_1 = action.payload.user;\n            var currentChannel = state.currentOpenChannel;\n            if (!currentChannel || currentChannel.url && (currentChannel.url !== eventedChannel.url)) {\n                return state;\n            }\n            return __assign(__assign({}, state), { participants: state.participants.filter(function (participant) { return (!compareIds(participant.userId, exitedUser_1.userId)); }) });\n        }\n        case ON_USER_MUTED: {\n            var eventedChannel = action.payload.channel;\n            var mutedUser = action.payload.user;\n            var currentChannel = state.currentOpenChannel;\n            if (!currentChannel\n                || (currentChannel.url && (currentChannel.url !== eventedChannel.url))\n                || state.mutedParticipantIds.indexOf(mutedUser.userId) >= 0) {\n                return state;\n            }\n            return __assign(__assign({}, state), { mutedParticipantIds: __spreadArray(__spreadArray([], state.mutedParticipantIds, true), [mutedUser.userId], false) });\n        }\n        case ON_USER_UNMUTED: {\n            var eventedChannel = action.payload.channel;\n            var unmutedUser_1 = action.payload.user;\n            var currentChannel = state.currentOpenChannel;\n            if (!currentChannel\n                || (currentChannel.url && (currentChannel.url !== eventedChannel.url))\n                || state.mutedParticipantIds.indexOf(unmutedUser_1.userId) < 0) {\n                return state;\n            }\n            return __assign(__assign({}, state), { mutedParticipantIds: state.mutedParticipantIds.filter(function (userId) { return userId !== unmutedUser_1.userId; }) });\n        }\n        case ON_USER_BANNED: {\n            var eventedChannel = action.payload.channel;\n            var bannedUser = action.payload.user;\n            var currentUser = action.payload.currentUser;\n            var currentChannel = state.currentOpenChannel;\n            if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (eventedChannel === null || eventedChannel === void 0 ? void 0 : eventedChannel.url) && (bannedUser === null || bannedUser === void 0 ? void 0 : bannedUser.userId) === (currentUser === null || currentUser === void 0 ? void 0 : currentUser.userId)) {\n                return __assign(__assign({}, state), { currentOpenChannel: null });\n            }\n            else if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (eventedChannel === null || eventedChannel === void 0 ? void 0 : eventedChannel.url)) {\n                return __assign(__assign({}, state), { bannedParticipantIds: __spreadArray(__spreadArray([], state.bannedParticipantIds, true), [bannedUser.userId], false) });\n            }\n            return state;\n        }\n        case ON_USER_UNBANNED: {\n            var eventedChannel = action.payload.channel;\n            var unbannedUser_1 = action.payload.user;\n            var currentChannel = state.currentOpenChannel;\n            if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === (eventedChannel === null || eventedChannel === void 0 ? void 0 : eventedChannel.url)) {\n                return __assign(__assign({}, state), { bannedParticipantIds: state.bannedParticipantIds.filter(function (userId) { return userId !== unbannedUser_1.userId; }) });\n            }\n            return state;\n        }\n        case ON_CHANNEL_FROZEN: {\n            var frozenChannel = action.payload;\n            var currentChannel = state.currentOpenChannel;\n            if (!currentChannel || currentChannel.url && (currentChannel.url !== frozenChannel.url)) {\n                return state;\n            }\n            return __assign(__assign({}, state), { frozen: true });\n        }\n        case ON_CHANNEL_UNFROZEN: {\n            var unfrozenChannel = action.payload;\n            var currentChannel = state.currentOpenChannel;\n            if (!currentChannel || currentChannel.url && (currentChannel.url !== unfrozenChannel.url)) {\n                return state;\n            }\n            return __assign(__assign({}, state), { frozen: false });\n        }\n        case ON_CHANNEL_CHANGED: {\n            var changedChannel = action.payload;\n            var currentChannel = state.currentOpenChannel;\n            if (!currentChannel || currentChannel.url && (currentChannel.url !== changedChannel.url)) {\n                return state;\n            }\n            return __assign(__assign({}, state), { currentOpenChannel: changedChannel });\n        }\n        case ON_CHANNEL_DELETED: {\n            var deletedChannelUrl = action.payload;\n            var currentChannel = state === null || state === void 0 ? void 0 : state.currentOpenChannel;\n            if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === deletedChannelUrl) {\n                return __assign(__assign({}, state), { currentOpenChannel: null });\n            }\n            return state;\n        }\n        case ON_META_DATA_CREATED: {\n            // const eventedChannel = action.payload.channel;\n            // const createdMetaData = action.payload.metaData;\n            // return {\n            //   ...state\n            // };\n            return state;\n        }\n        case ON_META_DATA_UPDATED: {\n            // const eventedChannel = action.payload.channel;\n            // const updatedMetaData = action.payload.metaData;\n            // return {\n            //   ...state\n            // };\n            return state;\n        }\n        case ON_META_DATA_DELETED: {\n            // const eventedChannel = action.payload.channel;\n            // const deletedMetaDataKeys = action.payload.metaDataKeys;\n            // return {\n            //   ...state\n            // };\n            return state;\n        }\n        case ON_META_COUNTERS_CREATED: {\n            // const eventedChannel = action.payload.channel;\n            // const createdMetaCounter = action.payload.metaCounter;\n            // return {\n            //   ...state\n            // };\n            return state;\n        }\n        case ON_META_COUNTERS_UPDATED: {\n            // const eventedChannel = action.payload.channel;\n            // const updatedMetaCounter = action.payload.metaCounter;\n            // return {\n            //   ...state\n            // };\n            return state;\n        }\n        case ON_META_COUNTERS_DELETED: {\n            // const eventedChannel = action.payload.channel;\n            // const deletedMetaCounterKeys = action.payload.metaCounterKeys;\n            // return {\n            //   ...state\n            // };\n            return state;\n        }\n        case ON_MENTION_RECEIVED: {\n            // const eventedChannel = action.payload.channel;\n            // const mentionedMessage = action.payload.message;\n            // return {\n            //   ...state\n            // };\n            return state;\n        }\n        default:\n            return state;\n    }\n}\n\nvar initialState = {\n    allMessages: [],\n    loading: false,\n    initialized: false,\n    currentOpenChannel: null,\n    isInvalid: false,\n    hasMore: false,\n    lastMessageTimestamp: 0,\n    frozen: false,\n    operators: [],\n    participants: [],\n    bannedParticipantIds: [],\n    mutedParticipantIds: [],\n};\n\nfunction useSetChannel(_a, _b) {\n    var channelUrl = _a.channelUrl, sdkInit = _a.sdkInit, fetchingParticipants = _a.fetchingParticipants, userId = _a.userId, currentOpenChannel = _a.currentOpenChannel;\n    var sdk = _b.sdk, logger = _b.logger, messagesDispatcher = _b.messagesDispatcher;\n    useEffect(function () {\n        var _a;\n        if (channelUrl && sdkInit && (sdk === null || sdk === void 0 ? void 0 : sdk.openChannel)) {\n            if (currentOpenChannel && (currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.exit)) {\n                (_a = currentOpenChannel.exit) === null || _a === void 0 ? void 0 : _a.call(currentOpenChannel).then(function () {\n                    logger.info('OpenChannel | useSetChannel: Exit from the previous open channel', currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.url);\n                    messagesDispatcher({\n                        type: EXIT_CURRENT_CHANNEL,\n                        payload: currentOpenChannel,\n                    });\n                });\n            }\n            logger.info('OpenChannel | useSetChannel: Fetching channel', channelUrl);\n            sdk.openChannel.getChannel(channelUrl).then(function (openChannel) {\n                logger.info('OpenChannel | useSetChannel: Succeeded to fetch channel', openChannel);\n                messagesDispatcher({\n                    type: SET_CURRENT_CHANNEL,\n                    payload: openChannel,\n                });\n                openChannel.enter().then(function () {\n                    if (openChannel.isOperator(userId)) { // only operator has a permission to fetch these list\n                        var bannedParticipantListQuery = openChannel.createBannedUserListQuery();\n                        var mutedParticipantListQuery = openChannel.createMutedUserListQuery();\n                        fetchWithListQuery(bannedParticipantListQuery, logger, function (users) {\n                            messagesDispatcher({\n                                type: FETCH_BANNED_USER_LIST,\n                                payload: {\n                                    channel: openChannel,\n                                    users: users,\n                                },\n                            });\n                        });\n                        fetchWithListQuery(mutedParticipantListQuery, logger, function (users) {\n                            messagesDispatcher({\n                                type: FETCH_MUTED_USER_LIST,\n                                payload: {\n                                    channel: openChannel,\n                                    users: users,\n                                },\n                            });\n                        });\n                    }\n                    else {\n                        openChannel.getMyMutedInfo()\n                            .then(function (mutedInfo) {\n                            if (mutedInfo === null || mutedInfo === void 0 ? void 0 : mutedInfo.isMuted) {\n                                messagesDispatcher({\n                                    type: FETCH_MUTED_USER_LIST,\n                                    payload: {\n                                        channel: openChannel,\n                                        users: [sdk === null || sdk === void 0 ? void 0 : sdk.currentUser],\n                                    },\n                                });\n                            }\n                        });\n                    }\n                    if (fetchingParticipants) {\n                        // fetch participants list\n                        var participantListQuery = openChannel.createParticipantListQuery({\n                            limit: openChannel.participantCount,\n                        });\n                        fetchWithListQuery(participantListQuery, logger, function (users) {\n                            messagesDispatcher({\n                                type: FETCH_PARTICIPANT_LIST,\n                                payload: {\n                                    channel: openChannel,\n                                    users: users,\n                                },\n                            });\n                        });\n                    }\n                }).catch(function (error) {\n                    logger.warning('OpenChannel | useSetChannel: Failed to enter channel', { channelUrl: channelUrl, error: error });\n                    messagesDispatcher({\n                        type: SET_CHANNEL_INVALID,\n                        payload: null,\n                    });\n                });\n            }).catch(function (error) {\n                logger.warning('OpenChannel | useSetChannel: Failed to fetch channel', { channelUrl: channelUrl, error: error });\n                messagesDispatcher({\n                    type: SET_CHANNEL_INVALID,\n                    payload: null,\n                });\n            });\n        }\n    }, [channelUrl, sdkInit, fetchingParticipants]);\n}\n\nfunction useHandleChannelEvents(_a, _b) {\n    var currentOpenChannel = _a.currentOpenChannel, checkScrollBottom = _a.checkScrollBottom;\n    var sdk = _b.sdk, logger = _b.logger, messagesDispatcher = _b.messagesDispatcher, scrollRef = _b.scrollRef;\n    useEffect(function () {\n        var _a, _b;\n        var messageReceiverId = uuidv4();\n        if (currentOpenChannel && currentOpenChannel.url && ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.openChannel) === null || _a === void 0 ? void 0 : _a.addOpenChannelHandler)) {\n            logger.info('OpenChannel | useHandleChannelEvents: Setup evnet handler', messageReceiverId);\n            var channelHandlerParams = {\n                onMessageReceived: function (channel, message) {\n                    var scrollToEnd = checkScrollBottom();\n                    var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n                    logger.info('OpenChannel | useHandleChannelEvents: onMessageReceived', { channelUrl: channelUrl, message: message });\n                    messagesDispatcher({\n                        type: ON_MESSAGE_RECEIVED,\n                        payload: { channel: channel, message: message },\n                    });\n                    if (scrollToEnd) {\n                        try {\n                            setTimeout(function () {\n                                scrollIntoLast(0, scrollRef);\n                            });\n                        }\n                        catch (error) {\n                            logger.warning('OpenChannel | onMessageReceived | scroll to end failed');\n                        }\n                    }\n                },\n                onMessageUpdated: function (channel, message) {\n                    var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n                    logger.info('OpenChannel | useHandleChannelEvents: onMessageUpdated', { channelUrl: channelUrl, message: message });\n                    messagesDispatcher({\n                        type: ON_MESSAGE_UPDATED,\n                        payload: { channel: channel, message: message },\n                    });\n                },\n                onMessageDeleted: function (channel, messageId) {\n                    var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n                    logger.info('OpenChannel | useHandleChannelEvents: onMessageDeleted', { channelUrl: channelUrl, messageId: messageId });\n                    messagesDispatcher({\n                        type: ON_MESSAGE_DELETED,\n                        payload: { channel: channel, messageId: messageId },\n                    });\n                },\n                onOperatorUpdated: function (channel, operators) {\n                    var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n                    logger.info('OpenChannel | useHandleChannelEvents: onOperatorUpdated', { channelUrl: channelUrl, operators: operators });\n                    messagesDispatcher({\n                        type: ON_OPERATOR_UPDATED,\n                        payload: { channel: channel, operators: operators },\n                    });\n                },\n                onUserEntered: function (channel, user) {\n                    var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n                    logger.info('OpenChannel | useHandleChannelEvents: onUserEntered', { channelUrl: channelUrl, user: user });\n                    messagesDispatcher({\n                        type: ON_USER_ENTERED,\n                        payload: { channel: channel, user: user },\n                    });\n                },\n                onUserExited: function (channel, user) {\n                    var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n                    logger.info('OpenChannel | useHandleChannelEvents: onUserExited', { channelUrl: channelUrl, user: user });\n                    messagesDispatcher({\n                        type: ON_USER_EXITED,\n                        payload: { channel: channel, user: user },\n                    });\n                },\n                onUserMuted: function (channel, user) {\n                    var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n                    logger.info('OpenChannel | useHandleChannelEvents: onUserMuted', { channelUrl: channelUrl, user: user });\n                    messagesDispatcher({\n                        type: ON_USER_MUTED,\n                        payload: { channel: channel, user: user },\n                    });\n                },\n                onUserUnmuted: function (channel, user) {\n                    var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n                    logger.info('OpenChannel | useHandleChannelEvents: onUserUnmuted', { channelUrl: channelUrl, user: user });\n                    messagesDispatcher({\n                        type: ON_USER_UNMUTED,\n                        payload: { channel: channel, user: user },\n                    });\n                },\n                onUserBanned: function (channel, user) {\n                    var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n                    logger.info('OpenChannel | useHandleChannelEvents: onUserBanned', { channelUrl: channelUrl, user: user });\n                    messagesDispatcher({\n                        type: ON_USER_BANNED,\n                        payload: { channel: channel, user: user, currentUser: sdk === null || sdk === void 0 ? void 0 : sdk.currentUser },\n                    });\n                },\n                onUserUnbanned: function (channel, user) {\n                    var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n                    logger.info('OpenChannel | useHandleChannelEvents: onUserUnbanned', { channelUrl: channelUrl, user: user });\n                    messagesDispatcher({\n                        type: ON_USER_UNBANNED,\n                        payload: { channel: channel, user: user },\n                    });\n                },\n                onChannelFrozen: function (channel) {\n                    logger.info('OpenChannel | useHandleChannelEvents: onChannelFrozen', channel);\n                    messagesDispatcher({\n                        type: ON_CHANNEL_FROZEN,\n                        payload: channel,\n                    });\n                },\n                onChannelUnfrozen: function (channel) {\n                    logger.info('OpenChannel | useHandleChannelEvents: onChannelUnfrozen', channel);\n                    messagesDispatcher({\n                        type: ON_CHANNEL_UNFROZEN,\n                        payload: channel,\n                    });\n                },\n                onChannelChanged: function (channel) {\n                    logger.info('OpenChannel | useHandleChannelEvents: onChannelChanged', channel);\n                    messagesDispatcher({\n                        type: ON_CHANNEL_CHANGED,\n                        payload: channel,\n                    });\n                },\n                onMetaDataCreated: function (channel, metaData) {\n                    var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n                    logger.info('OpenChannel | useHandleChannelEvents: onMetaDataCreated', { channelUrl: channelUrl, metaData: metaData });\n                    messagesDispatcher({\n                        type: ON_META_DATA_CREATED,\n                        payload: { channel: channel, metaData: metaData },\n                    });\n                },\n                onMetaDataUpdated: function (channel, metaData) {\n                    var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n                    logger.info('OpenChannel | useHandleChannelEvents: onMetaDataUpdated', { channelUrl: channelUrl, metaData: metaData });\n                    messagesDispatcher({\n                        type: ON_META_DATA_UPDATED,\n                        payload: { channel: channel, metaData: metaData },\n                    });\n                },\n                onMetaDataDeleted: function (channel, metaDataKeys) {\n                    var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n                    logger.info('OpenChannel | useHandleChannelEvents: onMetaDataDeleted', { channelUrl: channelUrl, metaDataKeys: metaDataKeys });\n                    messagesDispatcher({\n                        type: ON_META_DATA_DELETED,\n                        payload: { channel: channel, metaDataKeys: metaDataKeys },\n                    });\n                },\n                onMetaCounterCreated: function (channel, metaCounter) {\n                    var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n                    logger.info('OpenChannel | useHandleChannelEvents: onMetaCountersCreated', { channelUrl: channelUrl, metaCounter: metaCounter });\n                    messagesDispatcher({\n                        type: ON_META_COUNTERS_CREATED,\n                        payload: { channel: channel, metaCounter: metaCounter },\n                    });\n                },\n                onMetaCounterUpdated: function (channel, metaCounter) {\n                    var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n                    logger.info('OpenChannel | useHandleChannelEvents: onMetaCountersUpdated', { channelUrl: channelUrl, metaCounter: metaCounter });\n                    messagesDispatcher({\n                        type: ON_META_COUNTERS_UPDATED,\n                        payload: { channel: channel, metaCounter: metaCounter },\n                    });\n                },\n                onMetaCounterDeleted: function (channel, metaCounterKeys) {\n                    var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n                    logger.info('OpenChannel | useHandleChannelEvents: onMetaCountersDeleted', { channelUrl: channelUrl, metaCounterKeys: metaCounterKeys });\n                    messagesDispatcher({\n                        type: ON_META_COUNTERS_DELETED,\n                        payload: { channel: channel, metaCounterKeys: metaCounterKeys },\n                    });\n                },\n                onMentionReceived: function (channel, message) {\n                    var channelUrl = channel === null || channel === void 0 ? void 0 : channel.url;\n                    logger.info('OpenChannel | useHandleChannelEvents: onMentionReceived', { channelUrl: channelUrl, message: message });\n                    messagesDispatcher({\n                        type: ON_MENTION_RECEIVED,\n                        payload: { channel: channel, message: message },\n                    });\n                },\n                onChannelDeleted: function (channelUrl, channelType) {\n                    if (channelType === ChannelType.OPEN && (currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.url) === channelUrl) {\n                        messagesDispatcher({\n                            type: ON_CHANNEL_DELETED,\n                            payload: channelUrl,\n                        });\n                    }\n                },\n            };\n            var ChannelHandler = new OpenChannelHandler(channelHandlerParams);\n            (_b = sdk === null || sdk === void 0 ? void 0 : sdk.openChannel) === null || _b === void 0 ? void 0 : _b.addOpenChannelHandler(messageReceiverId, ChannelHandler);\n        }\n        return function () {\n            var _a;\n            if ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.openChannel) === null || _a === void 0 ? void 0 : _a.removeOpenChannelHandler) {\n                logger.info('OpenChannel | useHandleChannelEvents: Removing message receiver handler', messageReceiverId);\n                sdk.openChannel.removeOpenChannelHandler(messageReceiverId);\n            }\n        };\n    }, [currentOpenChannel]);\n}\n\nfunction useInitialMessagesFetch(_a, _b) {\n    var currentOpenChannel = _a.currentOpenChannel, userFilledMessageListParams = _a.userFilledMessageListParams;\n    var logger = _b.logger, messagesDispatcher = _b.messagesDispatcher, scrollRef = _b.scrollRef;\n    useEffect(function () {\n        logger.info('OpenChannel | useInitialMessagesFetch: Setup started', currentOpenChannel);\n        messagesDispatcher({\n            type: RESET_MESSAGES,\n            payload: null,\n        });\n        if (currentOpenChannel && currentOpenChannel.getMessagesByTimestamp) {\n            var messageListParams_1 = {\n                nextResultSize: 0,\n                prevResultSize: 30,\n                isInclusive: true,\n                includeReactions: false,\n            };\n            if (userFilledMessageListParams) {\n                Object.keys(userFilledMessageListParams).forEach(function (key) {\n                    // @ts-ignore\n                    messageListParams_1[key] = userFilledMessageListParams[key];\n                });\n                logger.info('OpenChannel | useInitialMessagesFetch: Used customizedMessageListParams');\n            }\n            logger.info('OpenChannel | useInitialMessagesFetch: Fetching messages', { currentOpenChannel: currentOpenChannel, messageListParams: messageListParams_1 });\n            messagesDispatcher({\n                type: GET_PREV_MESSAGES_START,\n                payload: null,\n            });\n            currentOpenChannel.getMessagesByTimestamp(new Date().getTime(), messageListParams_1).then(function (messages) {\n                logger.info('OpenChannel | useInitialMessagesFetch: Fetching messages succeeded', messages);\n                var hasMore = (messages && messages.length > 0);\n                var lastMessageTimestamp = hasMore ? messages[0].createdAt : null;\n                messagesDispatcher({\n                    type: GET_PREV_MESSAGES_SUCESS,\n                    payload: {\n                        currentOpenChannel: currentOpenChannel,\n                        messages: messages,\n                        hasMore: hasMore,\n                        lastMessageTimestamp: lastMessageTimestamp,\n                    },\n                });\n                setTimeout(function () { scrollIntoLast(0, scrollRef); });\n            }).catch(function (error) {\n                logger.error('OpenChannel | useInitialMessagesFetch: Fetching messages failed', error);\n                messagesDispatcher({\n                    type: GET_PREV_MESSAGES_FAIL,\n                    payload: {\n                        currentOpenChannel: currentOpenChannel,\n                        messages: [],\n                        hasMore: false,\n                        lastMessageTimestamp: 0,\n                    },\n                });\n            });\n        }\n    }, [currentOpenChannel, userFilledMessageListParams]);\n}\n\nfunction useScrollCallback(_a, _b) {\n    var currentOpenChannel = _a.currentOpenChannel, lastMessageTimestamp = _a.lastMessageTimestamp, fetchMore = _a.fetchMore;\n    var sdk = _b.sdk, logger = _b.logger, messagesDispatcher = _b.messagesDispatcher, hasMore = _b.hasMore, userFilledMessageListParams = _b.userFilledMessageListParams;\n    return useCallback(function (callback) {\n        if (fetchMore && hasMore) {\n            logger.info('OpenChannel | useScrollCallback: start');\n            var messageListParams_1 = {\n                prevResultSize: 30,\n                includeReactions: false,\n                nextResultSize: 0,\n            };\n            if (userFilledMessageListParams) {\n                Object.keys(userFilledMessageListParams).forEach(function (key) {\n                    // @ts-ignore\n                    messageListParams_1[key] = userFilledMessageListParams[key];\n                });\n                logger.info('OpenChannel | useScrollCallback: Used userFilledMessageListParams', userFilledMessageListParams);\n            }\n            logger.info('OpenChannel | useScrollCallback: Fetching messages', { currentOpenChannel: currentOpenChannel, messageListParams: messageListParams_1 });\n            currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.getMessagesByTimestamp(lastMessageTimestamp || new Date().getTime(), messageListParams_1).then(function (messages) {\n                logger.info('OpenChannel | useScrollCallback: Fetching messages succeeded', messages);\n                var hasMore = (messages && messages.length > 0);\n                var lastMessageTimestamp = hasMore ? messages[0].createdAt : null;\n                messagesDispatcher({\n                    type: GET_PREV_MESSAGES_SUCESS,\n                    payload: {\n                        currentOpenChannel: currentOpenChannel,\n                        messages: messages,\n                        hasMore: hasMore,\n                        lastMessageTimestamp: lastMessageTimestamp,\n                    },\n                });\n                setTimeout(function () {\n                    callback();\n                });\n            }).catch(function (error) {\n                logger.error('OpenChannel | useScrollCallback: Fetching messages failed', error);\n                messagesDispatcher({\n                    type: GET_PREV_MESSAGES_FAIL,\n                    payload: {\n                        currentOpenChannel: currentOpenChannel,\n                        messages: [],\n                        hasMore: false,\n                        lastMessageTimestamp: 0,\n                    },\n                });\n            });\n        }\n    }, [currentOpenChannel, lastMessageTimestamp, fetchMore, sdk]);\n}\n\nfunction useCheckScrollBottom(_a, _b) {\n    var conversationScrollRef = _a.conversationScrollRef;\n    var logger = _b.logger;\n    return useCallback(function () {\n        var isBottom = true;\n        if (conversationScrollRef && (conversationScrollRef === null || conversationScrollRef === void 0 ? void 0 : conversationScrollRef.current)) {\n            try {\n                var conversationScroll = conversationScrollRef.current;\n                isBottom = conversationScroll.scrollHeight <= conversationScroll.scrollTop + conversationScroll.clientHeight;\n            }\n            catch (error) {\n                logger.error('OpenChannel | useCheckScrollBottom', error);\n            }\n        }\n        return isBottom;\n    }, [conversationScrollRef]);\n}\n\nfunction useSendMessageCallback(_a, _b) {\n    var currentOpenChannel = _a.currentOpenChannel, onBeforeSendUserMessage = _a.onBeforeSendUserMessage, messageInputRef = _a.messageInputRef;\n    var sdk = _b.sdk, logger = _b.logger, messagesDispatcher = _b.messagesDispatcher, scrollRef = _b.scrollRef;\n    return useCallback(function () {\n        var _a;\n        if (sdk) {\n            var text = (_a = messageInputRef.current) === null || _a === void 0 ? void 0 : _a.innerText;\n            var createParamsDefault = function (txt) {\n                var message = txt;\n                var params = {\n                    message: message,\n                };\n                return params;\n            };\n            var createCustomParams = onBeforeSendUserMessage && typeof onBeforeSendUserMessage === 'function';\n            if (createCustomParams) {\n                logger.info('OpenChannel | useSendMessageCallback: Creating params using onBeforeSendUserMessage', onBeforeSendUserMessage);\n            }\n            var params = onBeforeSendUserMessage ? onBeforeSendUserMessage(text !== null && text !== void 0 ? text : '') : createParamsDefault(text !== null && text !== void 0 ? text : '');\n            logger.info('OpenChannel | useSendMessageCallback: Sending message has started', params);\n            var pendingMsg_1;\n            currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.sendUserMessage(params).onPending(function (pendingMessage) {\n                messagesDispatcher({\n                    type: SENDING_MESSAGE_START,\n                    payload: {\n                        message: pendingMessage,\n                        channel: currentOpenChannel,\n                    },\n                });\n                pendingMsg_1 = pendingMessage;\n                setTimeout(function () { return scrollIntoLast(0, scrollRef); });\n            }).onSucceeded(function (message) {\n                logger.info('OpenChannel | useSendMessageCallback: Sending message succeeded', message);\n                messagesDispatcher({\n                    type: SENDING_MESSAGE_SUCCEEDED,\n                    payload: message,\n                });\n            }).onFailed(function (error) {\n                logger.warning('OpenChannel | useSendMessageCallback: Sending message failed', error);\n                messagesDispatcher({\n                    type: SENDING_MESSAGE_FAILED,\n                    payload: pendingMsg_1,\n                });\n                // https://sendbird.com/docs/chat/v3/javascript/guides/error-codes#2-server-error-codes\n                // TODO: Do we need to handle the error cases?\n                // @ts-ignore\n                if ((error === null || error === void 0 ? void 0 : error.code) === 900041) {\n                    messagesDispatcher({\n                        type: ON_USER_MUTED,\n                        payload: {\n                            channel: currentOpenChannel,\n                            user: sdk.currentUser,\n                        },\n                    });\n                }\n            });\n        }\n    }, [currentOpenChannel, onBeforeSendUserMessage, messageInputRef]);\n}\n\nfunction useFileUploadCallback(_a, _b) {\n    var _this = this;\n    var currentOpenChannel = _a.currentOpenChannel, _c = _a.imageCompression, imageCompression = _c === void 0 ? {} : _c, onBeforeSendFileMessage = _a.onBeforeSendFileMessage;\n    var sdk = _b.sdk, logger = _b.logger, messagesDispatcher = _b.messagesDispatcher, scrollRef = _b.scrollRef;\n    var stringSet = useLocalization().stringSet;\n    var openModal = useGlobalModalContext().openModal;\n    var config = useSendbirdStateContext().config;\n    var uikitUploadSizeLimit = config.uikitUploadSizeLimit;\n    return useCallback(function (files) { return __awaiter(_this, void 0, void 0, function () {\n        var file_1, createCustomParams, createParamsDefault, compressedFiles, compressedFile, params;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!sdk) return [3 /*break*/, 2];\n                    file_1 = Array.isArray(files) ? files[0] : files;\n                    createCustomParams = onBeforeSendFileMessage && typeof onBeforeSendFileMessage === 'function';\n                    createParamsDefault = function (file) {\n                        var params = {};\n                        params.file = file;\n                        return params;\n                    };\n                    /**\n                     * Validate file sizes\n                     * The default value of uikitUploadSizeLimit is 25MiB\n                     */\n                    if (file_1.size > uikitUploadSizeLimit) {\n                        logger.info(\"OpenChannel | useFileUploadCallback: Cannot upload file size exceeding \".concat(uikitUploadSizeLimit));\n                        openModal({\n                            modalProps: {\n                                titleText: stringSet.FILE_UPLOAD_NOTIFICATION__SIZE_LIMIT.replace('%d', \"\".concat(Math.floor(uikitUploadSizeLimit / ONE_MiB))),\n                                hideFooter: true,\n                            },\n                            childElement: function (_a) {\n                                var closeModal = _a.closeModal;\n                                return (React__default.createElement(ModalFooter, { type: ButtonTypes.PRIMARY, submitText: stringSet.BUTTON__OK, hideCancelButton: true, onCancel: closeModal, onSubmit: closeModal }));\n                            },\n                        });\n                        return [2 /*return*/];\n                    }\n                    return [4 /*yield*/, compressImages({\n                            files: [file_1],\n                            imageCompression: imageCompression,\n                            logger: logger,\n                        })];\n                case 1:\n                    compressedFiles = (_a.sent()).compressedFiles;\n                    compressedFile = compressedFiles[0];\n                    // Send FileMessage\n                    if (createCustomParams) {\n                        logger.info('OpenChannel | useFileUploadCallback: Creating params using onBeforeSendFileMessage', onBeforeSendFileMessage);\n                    }\n                    params = onBeforeSendFileMessage ? onBeforeSendFileMessage(compressedFile) : createParamsDefault(compressedFile);\n                    logger.info('OpenChannel | useFileUploadCallback: Uploading file message start', params);\n                    currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.sendFileMessage(params).onPending(function (pendingMessage) {\n                        messagesDispatcher({\n                            type: SENDING_MESSAGE_START,\n                            payload: {\n                                // TODO: remove data pollution\n                                message: __assign(__assign({}, pendingMessage), { url: URL.createObjectURL(file_1), \n                                    // pending thumbnail message seems to be failed\n                                    requestState: 'pending', isUserMessage: pendingMessage.isUserMessage, isFileMessage: pendingMessage.isFileMessage, isAdminMessage: pendingMessage.isAdminMessage, isMultipleFilesMessage: pendingMessage.isMultipleFilesMessage }),\n                                channel: currentOpenChannel,\n                            },\n                        });\n                        setTimeout(function () { return scrollIntoLast(0, scrollRef); });\n                    }).onSucceeded(function (message) {\n                        logger.info('OpenChannel | useFileUploadCallback: Sending message succeeded', message);\n                        messagesDispatcher({\n                            type: SENDING_MESSAGE_SUCCEEDED,\n                            payload: message,\n                        });\n                    }).onFailed(function (error, message) {\n                        logger.error('OpenChannel | useFileUploadCallback: Sending file message failed', { message: message, error: error });\n                        // @ts-ignore\n                        message.localUrl = URL.createObjectURL(file_1);\n                        // @ts-ignore\n                        message.file = file_1;\n                        messagesDispatcher({\n                            type: SENDING_MESSAGE_FAILED,\n                            payload: message,\n                        });\n                    });\n                    _a.label = 2;\n                case 2: return [2 /*return*/];\n            }\n        });\n    }); }, [currentOpenChannel, onBeforeSendFileMessage, imageCompression]);\n}\n\nfunction useUpdateMessageCallback(_a, _b) {\n    var currentOpenChannel = _a.currentOpenChannel, onBeforeSendUserMessage = _a.onBeforeSendUserMessage;\n    var logger = _b.logger, messagesDispatcher = _b.messagesDispatcher;\n    return useCallback(function (messageId, text, callback) {\n        var createParamsDefault = function (txt) {\n            return {\n                message: txt,\n            };\n        };\n        if (onBeforeSendUserMessage && typeof onBeforeSendUserMessage === 'function') {\n            logger.info('OpenChannel | useUpdateMessageCallback: Creating params using onBeforeUpdateUserMessage');\n        }\n        var params = onBeforeSendUserMessage ? onBeforeSendUserMessage(text) : createParamsDefault(text);\n        currentOpenChannel.updateUserMessage(messageId, params)\n            .then(function (message) {\n            if (callback) {\n                callback();\n            }\n            logger.info('OpenChannel | useUpdateMessageCallback: Updating message succeeded', { message: message, params: params });\n            messagesDispatcher({\n                type: ON_MESSAGE_UPDATED,\n                payload: {\n                    channel: currentOpenChannel,\n                    message: message,\n                },\n            });\n        });\n    }, [currentOpenChannel, onBeforeSendUserMessage]);\n}\n\nfunction useDeleteMessageCallback(_a, _b) {\n    var currentOpenChannel = _a.currentOpenChannel;\n    var logger = _b.logger, messagesDispatcher = _b.messagesDispatcher;\n    return useCallback(function (message, callback) {\n        logger.info('OpenChannel | useDeleteMessageCallback: Deleting message', message);\n        var sendingStatus = message.sendingStatus;\n        logger.info('OpenChannel | useDeleteMessageCallback: Deleting message requestState', sendingStatus);\n        if (sendingStatus === 'failed' || sendingStatus === 'pending') {\n            logger.info('OpenChannel | useDeleteMessageCallback: Deleted message from local', message);\n            messagesDispatcher({\n                type: ON_MESSAGE_DELETED_BY_REQ_ID,\n                payload: message.reqId,\n            });\n            if (callback) {\n                callback();\n            }\n        }\n        else {\n            if (!(message.messageType === 'file' || message.messageType === 'user')) {\n                return;\n            }\n            var messageToDelete = message;\n            currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.deleteMessage(messageToDelete).then(function () {\n                logger.info('OpenChannel | useDeleteMessageCallback: Deleting message on server', sendingStatus);\n                if (callback) {\n                    callback();\n                }\n                logger.info('OpenChannel | useDeleteMessageCallback: Deleting message succeeded', message);\n                messagesDispatcher({\n                    type: ON_MESSAGE_DELETED,\n                    payload: {\n                        channel: currentOpenChannel,\n                        messageId: message.messageId,\n                    },\n                });\n            }).catch(function (error) {\n                logger.warning('OpenChannel | useDeleteMessageCallback: Deleting message failed', error);\n            });\n        }\n    }, [currentOpenChannel]);\n}\n\nfunction useResendMessageCallback(_a, _b) {\n    var currentOpenChannel = _a.currentOpenChannel;\n    var logger = _b.logger, messagesDispatcher = _b.messagesDispatcher;\n    return useCallback(function (failedMessage) {\n        logger.info('OpenChannel | useResendMessageCallback: Resending message has started', failedMessage);\n        if (typeof (failedMessage === null || failedMessage === void 0 ? void 0 : failedMessage.isResendable) === 'boolean'\n            && failedMessage.isResendable) {\n            // userMessage\n            if (failedMessage.isUserMessage()) {\n                currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.resendMessage(failedMessage).onPending(function (message) {\n                    messagesDispatcher({\n                        type: RESENDING_MESSAGE_START,\n                        payload: {\n                            channel: currentOpenChannel,\n                            message: message,\n                        },\n                    });\n                }).onSucceeded(function (message) {\n                    logger.info('OpenChannel | useResendMessageCallback: Reseding message succeeded', message);\n                    messagesDispatcher({\n                        type: SENDING_MESSAGE_SUCCEEDED,\n                        payload: message,\n                    });\n                }).onFailed(function (error, message) {\n                    logger.warning('OpenChannel | useResendMessageCallback: Resending message failed', error);\n                    messagesDispatcher({\n                        type: SENDING_MESSAGE_FAILED,\n                        payload: message,\n                    });\n                });\n            }\n            // fileMessage\n            if (failedMessage.isFileMessage()) {\n                currentOpenChannel === null || currentOpenChannel === void 0 ? void 0 : currentOpenChannel.resendMessage(failedMessage).onPending(function (message) {\n                    messagesDispatcher({\n                        type: RESENDING_MESSAGE_START,\n                        payload: {\n                            channel: currentOpenChannel,\n                            message: message,\n                        },\n                    });\n                }).onSucceeded(function (message) {\n                    logger.info('OpenChannel | useResendMessageCallback: Resending file message succeeded', message);\n                    messagesDispatcher({\n                        type: SENDING_MESSAGE_SUCCEEDED,\n                        payload: message,\n                    });\n                }).onFailed(function (error, message) {\n                    logger.warning('OpenChannel | useResendMessageCallback: Resending file message failed', error);\n                    messagesDispatcher({\n                        type: SENDING_MESSAGE_FAILED,\n                        payload: message,\n                    });\n                });\n            }\n        }\n        else {\n            // to alert user on console\n            // eslint-disable-next-line no-console\n            console.error('OpenChannel | useResendMessageCallback: Message is not resendable');\n            logger.warning('OpenChannel | useResendMessageCallback: Message is not resendable', failedMessage);\n        }\n    }, [currentOpenChannel]);\n}\n\nvar THROTTLE_TIMER = 5000;\n// to trim message list so that we wont keep thousands of messages in memory\n// We are throttling here; not debouncing\n// it will be called once very 5 sec if messagesLength, messageLimit changes\n// we check if messagesLength > messageLimit before dispatching action\nfunction useTrimMessageList(_a, _b) {\n    var messagesLength = _a.messagesLength, messageLimit = _a.messageLimit;\n    var messagesDispatcher = _b.messagesDispatcher, logger = _b.logger;\n    var _c = useState(false), inProgress = _c[0], setInProgress = _c[1];\n    useEffect(function () {\n        if (inProgress) {\n            return;\n        }\n        if (typeof messagesLength === 'number' && typeof messageLimit === 'number' && messagesLength > messageLimit) {\n            logger.info('Trimming MessageList');\n            messagesDispatcher({\n                type: TRIM_MESSAGE_LIST,\n                payload: { messageLimit: messageLimit },\n            });\n        }\n        setInProgress(true);\n        setTimeout(function () { setInProgress(false); }, THROTTLE_TIMER);\n    }, [messagesLength, messageLimit]);\n}\n\nvar OpenChannelContext = React__default.createContext(null);\nvar OpenChannelProvider = function (props) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    var channelUrl = props.channelUrl, children = props.children, _h = props.isMessageGroupingEnabled, isMessageGroupingEnabled = _h === void 0 ? true : _h, queries = props.queries, onBeforeSendUserMessage = props.onBeforeSendUserMessage, messageLimit = props.messageLimit, onBeforeSendFileMessage = props.onBeforeSendFileMessage, onChatHeaderActionClick = props.onChatHeaderActionClick, onBackClick = props.onBackClick, disableUserProfile = props.disableUserProfile, renderUserProfile = props.renderUserProfile;\n    // We didn't decide to support fetching participant list\n    var fetchingParticipants = false;\n    var globalStore = useSendbirdStateContext();\n    var sdk = (_b = (_a = globalStore === null || globalStore === void 0 ? void 0 : globalStore.stores) === null || _a === void 0 ? void 0 : _a.sdkStore) === null || _b === void 0 ? void 0 : _b.sdk;\n    var sdkInit = (_d = (_c = globalStore === null || globalStore === void 0 ? void 0 : globalStore.stores) === null || _c === void 0 ? void 0 : _c.sdkStore) === null || _d === void 0 ? void 0 : _d.initialized;\n    var user = (_f = (_e = globalStore === null || globalStore === void 0 ? void 0 : globalStore.stores) === null || _e === void 0 ? void 0 : _e.userStore) === null || _f === void 0 ? void 0 : _f.user;\n    var config = globalStore === null || globalStore === void 0 ? void 0 : globalStore.config;\n    var userId = config.userId, isOnline = config.isOnline, logger = config.logger, pubSub = config.pubSub, imageCompression = config.imageCompression;\n    // hook variables\n    var _j = useReducer(reducer, initialState), messagesStore = _j[0], messagesDispatcher = _j[1];\n    var allMessages = messagesStore.allMessages, loading = messagesStore.loading, initialized = messagesStore.initialized, currentOpenChannel = messagesStore.currentOpenChannel, isInvalid = messagesStore.isInvalid, hasMore = messagesStore.hasMore, lastMessageTimestamp = messagesStore.lastMessageTimestamp, operators = messagesStore.operators, bannedParticipantIds = messagesStore.bannedParticipantIds, mutedParticipantIds = messagesStore.mutedParticipantIds;\n    // ref\n    var messageInputRef = useRef(null); // useSendMessageCallback\n    var conversationScrollRef = useRef(null); // useScrollAfterSendMessageCallback\n    // const\n    var userFilledMessageListParams = queries === null || queries === void 0 ? void 0 : queries.messageListParams;\n    var disabled = !initialized\n        || !isOnline\n        || isDisabledBecauseFrozen(currentOpenChannel, userId)\n        || isDisabledBecauseMuted(mutedParticipantIds, userId);\n    // useMemo\n    var amIBanned = useMemo(function () {\n        return bannedParticipantIds.indexOf(user.userId) >= 0;\n    }, [channelUrl, bannedParticipantIds, user]);\n    var amIMuted = useMemo(function () {\n        return mutedParticipantIds.indexOf(user.userId) >= 0;\n    }, [channelUrl, mutedParticipantIds, user]);\n    var amIOperator = useMemo(function () {\n        return operators.map(function (operator) { return operator.userId; }).indexOf(user.userId) >= 0;\n    }, [channelUrl, operators, user]);\n    // use hooks\n    useSetChannel({ channelUrl: channelUrl, sdkInit: sdkInit, fetchingParticipants: fetchingParticipants, userId: userId, currentOpenChannel: currentOpenChannel }, { sdk: sdk, logger: logger, messagesDispatcher: messagesDispatcher });\n    var checkScrollBottom = useCheckScrollBottom({ conversationScrollRef: conversationScrollRef }, { logger: logger });\n    useHandleChannelEvents({ currentOpenChannel: currentOpenChannel, checkScrollBottom: checkScrollBottom }, { sdk: sdk, logger: logger, messagesDispatcher: messagesDispatcher, scrollRef: conversationScrollRef });\n    useInitialMessagesFetch({ currentOpenChannel: currentOpenChannel, userFilledMessageListParams: userFilledMessageListParams }, { logger: logger, messagesDispatcher: messagesDispatcher, scrollRef: conversationScrollRef });\n    var fetchMore = shouldFetchMore(allMessages === null || allMessages === void 0 ? void 0 : allMessages.length, messageLimit);\n    // do not fetch more for streaming\n    var onScroll = useScrollCallback({ currentOpenChannel: currentOpenChannel, lastMessageTimestamp: lastMessageTimestamp, fetchMore: fetchMore }, { sdk: sdk, logger: logger, messagesDispatcher: messagesDispatcher, hasMore: hasMore, userFilledMessageListParams: userFilledMessageListParams });\n    var handleSendMessage = useSendMessageCallback({ currentOpenChannel: currentOpenChannel, onBeforeSendUserMessage: onBeforeSendUserMessage, checkScrollBottom: checkScrollBottom, messageInputRef: messageInputRef }, { sdk: sdk, logger: logger, messagesDispatcher: messagesDispatcher, scrollRef: conversationScrollRef });\n    var handleFileUpload = useFileUploadCallback({ currentOpenChannel: currentOpenChannel, onBeforeSendFileMessage: onBeforeSendFileMessage, checkScrollBottom: checkScrollBottom, imageCompression: imageCompression }, { sdk: sdk, logger: logger, messagesDispatcher: messagesDispatcher, scrollRef: conversationScrollRef });\n    var updateMessage = useUpdateMessageCallback({ currentOpenChannel: currentOpenChannel, onBeforeSendUserMessage: onBeforeSendUserMessage }, { logger: logger, messagesDispatcher: messagesDispatcher });\n    var deleteMessage = useDeleteMessageCallback({ currentOpenChannel: currentOpenChannel }, { logger: logger, messagesDispatcher: messagesDispatcher });\n    var resendMessage = useResendMessageCallback({ currentOpenChannel: currentOpenChannel }, { logger: logger, messagesDispatcher: messagesDispatcher });\n    useTrimMessageList({ messagesLength: allMessages === null || allMessages === void 0 ? void 0 : allMessages.length, messageLimit: messageLimit }, { messagesDispatcher: messagesDispatcher, logger: logger });\n    // handle API calls from withSendbird\n    useEffect(function () {\n        var subscriber = new Map();\n        if (!pubSub || !pubSub.subscribe) {\n            return;\n        }\n        subscriber.set(pubSubTopics.SEND_USER_MESSAGE, pubSub.subscribe(pubSubTopics.SEND_USER_MESSAGE, function (msg) {\n            var channel = msg.channel, message = msg.message;\n            scrollIntoLast(0, conversationScrollRef);\n            if (channel && (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url))) {\n                messagesDispatcher({\n                    type: SENDING_MESSAGE_SUCCEEDED,\n                    payload: message,\n                });\n            }\n        }));\n        subscriber.set(pubSubTopics.SEND_MESSAGE_START, pubSub.subscribe(pubSubTopics.SEND_MESSAGE_START, function (msg) {\n            var channel = msg.channel, message = msg.message;\n            if (channel && (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url))) {\n                messagesDispatcher({\n                    type: SENDING_MESSAGE_START,\n                    payload: { message: message, channel: channel },\n                });\n            }\n        }));\n        subscriber.set(pubSubTopics.SEND_FILE_MESSAGE, pubSub.subscribe(pubSubTopics.SEND_FILE_MESSAGE, function (msg) {\n            var channel = msg.channel, message = msg.message;\n            scrollIntoLast(0, conversationScrollRef);\n            if (channel && (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url))) {\n                messagesDispatcher({\n                    type: SENDING_MESSAGE_SUCCEEDED,\n                    payload: { message: message, channel: channel },\n                });\n            }\n        }));\n        subscriber.set(pubSubTopics.UPDATE_USER_MESSAGE, pubSub.subscribe(pubSubTopics.UPDATE_USER_MESSAGE, function (msg) {\n            var channel = msg.channel, message = msg.message, fromSelector = msg.fromSelector;\n            if (fromSelector && channel && (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url))) {\n                messagesDispatcher({\n                    type: ON_MESSAGE_UPDATED,\n                    payload: { channel: channel, message: message },\n                });\n            }\n        }));\n        subscriber.set(pubSubTopics.DELETE_MESSAGE, pubSub.subscribe(pubSubTopics.DELETE_MESSAGE, function (msg) {\n            var channel = msg.channel, messageId = msg.messageId;\n            if (channel && (channelUrl === (channel === null || channel === void 0 ? void 0 : channel.url))) {\n                messagesDispatcher({\n                    type: ON_MESSAGE_DELETED,\n                    payload: messageId,\n                });\n            }\n        }));\n        return function () {\n            if (subscriber) {\n                subscriber.forEach(function (s) {\n                    try {\n                        s.remove();\n                    }\n                    catch (_a) {\n                        //\n                    }\n                });\n            }\n        };\n    }, [channelUrl, sdkInit]);\n    return (React__default.createElement(OpenChannelContext.Provider, { value: {\n            // props\n            channelUrl: channelUrl,\n            children: children,\n            isMessageGroupingEnabled: isMessageGroupingEnabled,\n            queries: queries,\n            onBeforeSendUserMessage: onBeforeSendUserMessage,\n            messageLimit: messageLimit,\n            onBeforeSendFileMessage: onBeforeSendFileMessage,\n            onChatHeaderActionClick: onChatHeaderActionClick,\n            onBackClick: onBackClick,\n            // store\n            allMessages: allMessages,\n            loading: loading,\n            initialized: initialized,\n            currentOpenChannel: currentOpenChannel,\n            isInvalid: isInvalid,\n            hasMore: hasMore,\n            lastMessageTimestamp: lastMessageTimestamp,\n            operators: operators,\n            bannedParticipantIds: bannedParticipantIds,\n            mutedParticipantIds: mutedParticipantIds,\n            // derived/utils\n            messageInputRef: messageInputRef,\n            conversationScrollRef: conversationScrollRef,\n            disabled: disabled,\n            amIBanned: amIBanned,\n            amIMuted: amIMuted,\n            amIOperator: amIOperator,\n            checkScrollBottom: checkScrollBottom,\n            fetchMore: fetchMore,\n            onScroll: onScroll,\n            handleSendMessage: handleSendMessage,\n            handleFileUpload: handleFileUpload,\n            updateMessage: updateMessage,\n            deleteMessage: deleteMessage,\n            resendMessage: resendMessage,\n            frozen: messagesStore.frozen,\n            disableUserProfile: disableUserProfile,\n            renderUserProfile: renderUserProfile,\n            participants: messagesStore.participants,\n        } },\n        React__default.createElement(UserProfileProvider, { isOpenChannel: true, renderUserProfile: props === null || props === void 0 ? void 0 : props.renderUserProfile, disableUserProfile: (_g = props === null || props === void 0 ? void 0 : props.disableUserProfile) !== null && _g !== void 0 ? _g : config === null || config === void 0 ? void 0 : config.disableUserProfile }, children)));\n};\nvar useOpenChannelContext = function () {\n    var context = React__default.useContext(OpenChannelContext);\n    if (!context)\n        throw new Error('OpenChannelContext not found. Use within the OpenChannel module');\n    return context;\n};\n\nexport { OpenChannelProvider as O, kFormatter as k, useOpenChannelContext as u };\n//# sourceMappingURL=bundle-CoPuVBn-.js.map\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module"}