{"ast":null,"code":"import { S as SCROLL_BUFFER } from './bundle-DCMGp6rH.js';\nimport { u as useThrottleCallback } from './bundle-DSn10d8F.js';\nimport { a as isAboutSame } from './bundle-CMLImr6T.js';\nimport { usePreservedCallback } from '@sendbird/uikit-tools';\nvar DELAY = 100;\nfunction calcScrollBottom(scrollHeight, scrollTop) {\n  return scrollHeight - scrollTop;\n}\nfunction useHandleOnScrollCallback(_a) {\n  var hasMore = _a.hasMore,\n    hasNext = _a.hasNext,\n    onScroll = _a.onScroll,\n    scrollRef = _a.scrollRef,\n    setShowScrollDownButton = _a.setShowScrollDownButton;\n  var scrollCb = usePreservedCallback(function () {\n    var element = scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current;\n    if (element == null) return;\n    var scrollTop = element.scrollTop,\n      scrollHeight = element.scrollHeight,\n      clientHeight = element.clientHeight;\n    // https://sendbird.atlassian.net/browse/SBISSUE-11759\n    // the edge case where channel is inside a page that already has scroll\n    // scrollintoView will move the whole page, which we dont want\n    var scrollBottom = calcScrollBottom(scrollHeight, scrollTop);\n    // even if there is more to fetch or not,\n    // we still have to show the scroll to bottom button\n    if (typeof setShowScrollDownButton === 'function') {\n      setShowScrollDownButton(scrollHeight > scrollTop + clientHeight + 1);\n    }\n    // Load previous messages\n    // 1. check if hasMore(hasPrevious) and reached to top\n    // 2. load previous messages (onScroll)\n    // 3. maintain scroll position (sets the scroll position to the bottom of the new messages)\n    if (hasMore && isAboutSame(scrollTop, 0, SCROLL_BUFFER)) {\n      onScroll(function () {\n        var messagesAreAddedToView = element.scrollHeight > scrollHeight;\n        if (messagesAreAddedToView) element.scrollTop = element.scrollHeight - scrollBottom;\n      });\n    }\n    // Load next messages\n    // 1. check if hasNext and reached to bottom\n    // 2. load next messages (onScroll)\n    // 3. maintain scroll position (sets the scroll position to the top of the new messages)\n    if (hasNext && isAboutSame(clientHeight + scrollTop, scrollHeight, SCROLL_BUFFER)) {\n      onScroll(function () {\n        var messagesAreAddedToView = element.scrollHeight > scrollHeight;\n        if (messagesAreAddedToView) element.scrollTop = scrollTop;\n      });\n    }\n  });\n  return useThrottleCallback(scrollCb, DELAY, {\n    trailing: true\n  });\n}\nexport { useHandleOnScrollCallback as u };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import { S as SCROLL_BUFFER } from './bundle-DCMGp6rH.js';\nimport { u as useThrottleCallback } from './bundle-DSn10d8F.js';\nimport { a as isAboutSame } from './bundle-CMLImr6T.js';\nimport { usePreservedCallback } from '@sendbird/uikit-tools';\n\nvar DELAY = 100;\nfunction calcScrollBottom(scrollHeight, scrollTop) {\n    return scrollHeight - scrollTop;\n}\nfunction useHandleOnScrollCallback(_a) {\n    var hasMore = _a.hasMore, hasNext = _a.hasNext, onScroll = _a.onScroll, scrollRef = _a.scrollRef, setShowScrollDownButton = _a.setShowScrollDownButton;\n    var scrollCb = usePreservedCallback(function () {\n        var element = scrollRef === null || scrollRef === void 0 ? void 0 : scrollRef.current;\n        if (element == null)\n            return;\n        var scrollTop = element.scrollTop, scrollHeight = element.scrollHeight, clientHeight = element.clientHeight;\n        // https://sendbird.atlassian.net/browse/SBISSUE-11759\n        // the edge case where channel is inside a page that already has scroll\n        // scrollintoView will move the whole page, which we dont want\n        var scrollBottom = calcScrollBottom(scrollHeight, scrollTop);\n        // even if there is more to fetch or not,\n        // we still have to show the scroll to bottom button\n        if (typeof setShowScrollDownButton === 'function') {\n            setShowScrollDownButton(scrollHeight > scrollTop + clientHeight + 1);\n        }\n        // Load previous messages\n        // 1. check if hasMore(hasPrevious) and reached to top\n        // 2. load previous messages (onScroll)\n        // 3. maintain scroll position (sets the scroll position to the bottom of the new messages)\n        if (hasMore && isAboutSame(scrollTop, 0, SCROLL_BUFFER)) {\n            onScroll(function () {\n                var messagesAreAddedToView = element.scrollHeight > scrollHeight;\n                if (messagesAreAddedToView)\n                    element.scrollTop = element.scrollHeight - scrollBottom;\n            });\n        }\n        // Load next messages\n        // 1. check if hasNext and reached to bottom\n        // 2. load next messages (onScroll)\n        // 3. maintain scroll position (sets the scroll position to the top of the new messages)\n        if (hasNext && isAboutSame(clientHeight + scrollTop, scrollHeight, SCROLL_BUFFER)) {\n            onScroll(function () {\n                var messagesAreAddedToView = element.scrollHeight > scrollHeight;\n                if (messagesAreAddedToView)\n                    element.scrollTop = scrollTop;\n            });\n        }\n    });\n    return useThrottleCallback(scrollCb, DELAY, { trailing: true });\n}\n\nexport { useHandleOnScrollCallback as u };\n//# sourceMappingURL=bundle-ClMRT1R_.js.map\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module"}