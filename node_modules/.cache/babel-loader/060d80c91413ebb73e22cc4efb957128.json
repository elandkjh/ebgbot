{"ast":null,"code":"import { ConnectionHandler } from '@sendbird/chat';\nimport { useState, useEffect, useLayoutEffect, useMemo } from 'react';\nimport { u as uuidv4 } from './bundle-etuaqevl.js';\nimport { a as __awaiter, b as __generator } from './bundle-BQi9-O76.js';\nfunction useOnlineStatus(sdk, logger) {\n  var _a, _b;\n  var _c = useState(\n    // window is undefined in SSR env\n    typeof window !== 'undefined' ? (_b = (_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.onLine) !== null && _b !== void 0 ? _b : true : true),\n    isOnline = _c[0],\n    setIsOnline = _c[1];\n  useEffect(function () {\n    var uniqueHandlerId = uuidv4();\n    try {\n      logger.warning('sdk changed', uniqueHandlerId);\n      var handler = new ConnectionHandler({\n        onDisconnected: function () {\n          setIsOnline(false);\n          logger.warning('onDisconnected', {\n            isOnline: isOnline\n          });\n        },\n        onReconnectStarted: function () {\n          setIsOnline(false);\n          logger.warning('onReconnectStarted', {\n            isOnline: isOnline\n          });\n        },\n        onReconnectSucceeded: function () {\n          setIsOnline(true);\n          logger.warning('onReconnectSucceeded', {\n            isOnline: isOnline\n          });\n        },\n        onReconnectFailed: function () {\n          sdk.reconnect();\n          logger.warning('onReconnectFailed');\n        }\n      });\n      if (sdk === null || sdk === void 0 ? void 0 : sdk.addConnectionHandler) {\n        // workaround -> addConnectionHandler invalidates session handler\n        // provided through configureSession\n        sdk.addConnectionHandler(uniqueHandlerId, handler);\n        logger.info('Added ConnectionHandler', uniqueHandlerId);\n      }\n    } catch (_a) {\n      //\n    }\n    return function () {\n      try {\n        sdk.removeConnectionHandler(uniqueHandlerId);\n        logger.info('Removed ConnectionHandler', uniqueHandlerId);\n      } catch (_a) {\n        //\n      }\n    };\n  }, [sdk]);\n  useEffect(function () {\n    var tryReconnect = function () {\n      try {\n        logger.warning('Try reconnecting SDK');\n        if (sdk.connectionState !== 'OPEN') {\n          // connection is not broken yet\n          sdk.reconnect();\n        }\n      } catch (_a) {\n        //\n      }\n    };\n    // addEventListener version\n    window.addEventListener('online', tryReconnect);\n    return function () {\n      window.removeEventListener('online', tryReconnect);\n    };\n  }, [sdk]);\n  // add offline-class to body\n  useEffect(function () {\n    var body = document.querySelector('body');\n    if (!isOnline && !(sdk === null || sdk === void 0 ? void 0 : sdk.isCacheEnabled)) {\n      try {\n        body === null || body === void 0 ? void 0 : body.classList.add('sendbird__offline');\n        logger.info('Added class sendbird__offline to body');\n      } catch (e) {\n        //\n      }\n    } else {\n      try {\n        body === null || body === void 0 ? void 0 : body.classList.remove('sendbird__offline');\n        logger.info('Removed class sendbird__offline from body');\n      } catch (e) {\n        //\n      }\n    }\n  }, [isOnline, sdk === null || sdk === void 0 ? void 0 : sdk.isCacheEnabled]);\n  return isOnline;\n}\nvar TIMEOUT = 2000;\n/*\n  * This is a factory function that returns a scheduler.\n  * The scheduler is a queue that calls the callback function on intervals.\n  * If interval is empty, the callback function is called immediately.\n  * If interval is not empty, the callback function is called after the interval.\n*/\nfunction schedulerFactory(_a) {\n  var logger = _a.logger,\n    timeout = _a.timeout,\n    cb = _a.cb;\n  var queue = [];\n  var interval = null;\n  var push = function (channel) {\n    var channelPresent = queue.find(function (c) {\n      return c.url === channel.url;\n    });\n    if (!channelPresent) {\n      queue.push(channel);\n    } else {\n      logger.info('Channel: Mark as read already in queue', {\n        channel: channel\n      });\n    }\n    // start the interval if it's not already running\n    if (interval) {\n      return;\n    }\n    var item = queue.shift();\n    if (item) {\n      cb(item);\n    }\n    interval = setInterval(function () {\n      if (queue.length === 0 && interval) {\n        clearInterval(interval);\n        interval = null;\n        return;\n      }\n      var item = queue.shift();\n      if (item) {\n        cb(item);\n      }\n    }, timeout || TIMEOUT);\n  };\n  var clear = function () {\n    queue = [];\n    if (interval) {\n      clearInterval(interval);\n      interval = null;\n    }\n  };\n  return {\n    push: push,\n    clear: clear,\n    getQueue: function () {\n      return queue;\n    }\n  };\n}\n\n// this hook accepts a callback to run component is unmounted\nfunction useUnmount(callback, deps) {\n  if (deps === void 0) {\n    deps = [];\n  }\n  useLayoutEffect(function () {\n    return function () {\n      callback();\n    };\n  }, deps);\n}\nfunction useMarkAsDeliveredScheduler(_a, _b) {\n  var _this = this;\n  var isConnected = _a.isConnected;\n  var logger = _b.logger;\n  var markAsDeliveredScheduler = useMemo(function () {\n    return schedulerFactory({\n      logger: logger,\n      cb: function (channel) {\n        return __awaiter(_this, void 0, void 0, function () {\n          var error_1;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                _a.trys.push([0, 2,, 3]);\n                return [4 /*yield*/, channel.markAsDelivered()];\n              case 1:\n                _a.sent();\n                return [3 /*break*/, 3];\n              case 2:\n                error_1 = _a.sent();\n                logger.warning('Channel: Mark as delivered failed', {\n                  channel: channel,\n                  error: error_1\n                });\n                return [3 /*break*/, 3];\n              case 3:\n                return [2 /*return*/];\n            }\n          });\n        });\n      }\n    });\n  }, []);\n  useEffect(function () {\n    // for simplicity, we clear the queue when the connection is lost\n    if (!isConnected) {\n      markAsDeliveredScheduler.clear();\n    }\n  }, [isConnected]);\n  useUnmount(function () {\n    markAsDeliveredScheduler.clear();\n  });\n  return markAsDeliveredScheduler;\n}\nexport { useMarkAsDeliveredScheduler as a, useUnmount as b, schedulerFactory as s, useOnlineStatus as u };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import { ConnectionHandler } from '@sendbird/chat';\nimport { useState, useEffect, useLayoutEffect, useMemo } from 'react';\nimport { u as uuidv4 } from './bundle-etuaqevl.js';\nimport { a as __awaiter, b as __generator } from './bundle-BQi9-O76.js';\n\nfunction useOnlineStatus(sdk, logger) {\n    var _a, _b;\n    var _c = useState(\n    // window is undefined in SSR env\n    typeof window !== 'undefined'\n        ? ((_b = (_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.onLine) !== null && _b !== void 0 ? _b : true)\n        : true), isOnline = _c[0], setIsOnline = _c[1];\n    useEffect(function () {\n        var uniqueHandlerId = uuidv4();\n        try {\n            logger.warning('sdk changed', uniqueHandlerId);\n            var handler = new ConnectionHandler({\n                onDisconnected: function () {\n                    setIsOnline(false);\n                    logger.warning('onDisconnected', { isOnline: isOnline });\n                },\n                onReconnectStarted: function () {\n                    setIsOnline(false);\n                    logger.warning('onReconnectStarted', { isOnline: isOnline });\n                },\n                onReconnectSucceeded: function () {\n                    setIsOnline(true);\n                    logger.warning('onReconnectSucceeded', { isOnline: isOnline });\n                },\n                onReconnectFailed: function () {\n                    sdk.reconnect();\n                    logger.warning('onReconnectFailed');\n                },\n            });\n            if (sdk === null || sdk === void 0 ? void 0 : sdk.addConnectionHandler) {\n                // workaround -> addConnectionHandler invalidates session handler\n                // provided through configureSession\n                sdk.addConnectionHandler(uniqueHandlerId, handler);\n                logger.info('Added ConnectionHandler', uniqueHandlerId);\n            }\n        }\n        catch (_a) {\n            //\n        }\n        return function () {\n            try {\n                sdk.removeConnectionHandler(uniqueHandlerId);\n                logger.info('Removed ConnectionHandler', uniqueHandlerId);\n            }\n            catch (_a) {\n                //\n            }\n        };\n    }, [sdk]);\n    useEffect(function () {\n        var tryReconnect = function () {\n            try {\n                logger.warning('Try reconnecting SDK');\n                if (sdk.connectionState !== 'OPEN') { // connection is not broken yet\n                    sdk.reconnect();\n                }\n            }\n            catch (_a) {\n                //\n            }\n        };\n        // addEventListener version\n        window.addEventListener('online', tryReconnect);\n        return function () {\n            window.removeEventListener('online', tryReconnect);\n        };\n    }, [sdk]);\n    // add offline-class to body\n    useEffect(function () {\n        var body = document.querySelector('body');\n        if (!isOnline && !(sdk === null || sdk === void 0 ? void 0 : sdk.isCacheEnabled)) {\n            try {\n                body === null || body === void 0 ? void 0 : body.classList.add('sendbird__offline');\n                logger.info('Added class sendbird__offline to body');\n            }\n            catch (e) {\n                //\n            }\n        }\n        else {\n            try {\n                body === null || body === void 0 ? void 0 : body.classList.remove('sendbird__offline');\n                logger.info('Removed class sendbird__offline from body');\n            }\n            catch (e) {\n                //\n            }\n        }\n    }, [isOnline, sdk === null || sdk === void 0 ? void 0 : sdk.isCacheEnabled]);\n    return isOnline;\n}\n\nvar TIMEOUT = 2000;\n/*\n  * This is a factory function that returns a scheduler.\n  * The scheduler is a queue that calls the callback function on intervals.\n  * If interval is empty, the callback function is called immediately.\n  * If interval is not empty, the callback function is called after the interval.\n*/\nfunction schedulerFactory(_a) {\n    var logger = _a.logger, timeout = _a.timeout, cb = _a.cb;\n    var queue = [];\n    var interval = null;\n    var push = function (channel) {\n        var channelPresent = queue.find(function (c) { return c.url === channel.url; });\n        if (!channelPresent) {\n            queue.push(channel);\n        }\n        else {\n            logger.info('Channel: Mark as read already in queue', { channel: channel });\n        }\n        // start the interval if it's not already running\n        if (interval) {\n            return;\n        }\n        var item = queue.shift();\n        if (item) {\n            cb(item);\n        }\n        interval = setInterval(function () {\n            if (queue.length === 0 && interval) {\n                clearInterval(interval);\n                interval = null;\n                return;\n            }\n            var item = queue.shift();\n            if (item) {\n                cb(item);\n            }\n        }, (timeout || TIMEOUT));\n    };\n    var clear = function () {\n        queue = [];\n        if (interval) {\n            clearInterval(interval);\n            interval = null;\n        }\n    };\n    return {\n        push: push,\n        clear: clear,\n        getQueue: function () { return queue; },\n    };\n}\n\n// this hook accepts a callback to run component is unmounted\nfunction useUnmount(callback, deps) {\n    if (deps === void 0) { deps = []; }\n    useLayoutEffect(function () {\n        return function () {\n            callback();\n        };\n    }, deps);\n}\n\nfunction useMarkAsDeliveredScheduler(_a, _b) {\n    var _this = this;\n    var isConnected = _a.isConnected;\n    var logger = _b.logger;\n    var markAsDeliveredScheduler = useMemo(function () { return schedulerFactory({\n        logger: logger,\n        cb: function (channel) { return __awaiter(_this, void 0, void 0, function () {\n            var error_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, channel.markAsDelivered()];\n                    case 1:\n                        _a.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        error_1 = _a.sent();\n                        logger.warning('Channel: Mark as delivered failed', { channel: channel, error: error_1 });\n                        return [3 /*break*/, 3];\n                    case 3: return [2 /*return*/];\n                }\n            });\n        }); },\n    }); }, []);\n    useEffect(function () {\n        // for simplicity, we clear the queue when the connection is lost\n        if (!isConnected) {\n            markAsDeliveredScheduler.clear();\n        }\n    }, [isConnected]);\n    useUnmount(function () { markAsDeliveredScheduler.clear(); });\n    return markAsDeliveredScheduler;\n}\n\nexport { useMarkAsDeliveredScheduler as a, useUnmount as b, schedulerFactory as s, useOnlineStatus as u };\n//# sourceMappingURL=bundle-Soz6sOqr.js.map\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module"}