{"ast":null,"code":"import { _ as __assign, a as __awaiter, b as __generator } from '../chunks/bundle-BQi9-O76.js';\nimport React__default, { useRef, useState, useLayoutEffect, useCallback, useMemo, useEffect, useContext } from 'react';\nimport { MessageMetaArray, ReplyType } from '@sendbird/chat/message';\nimport { MessageFilter } from '@sendbird/chat/groupChannel';\nimport { useIIFE, useGroupChannelMessages, useAsyncEffect, useAsyncLayoutEffect, usePreservedCallback } from '@sendbird/uikit-tools';\nimport { U as UserProfileProvider } from '../chunks/bundle-BrTJ5Zbd.js';\nimport { useSendbirdStateContext } from '../useSendbirdStateContext.js';\nimport { u as useToggleReactionCallback } from '../chunks/bundle-y29vL7zu.js';\nimport { g as getCaseResolvedReplyType, a as getCaseResolvedThreadReplySelectType } from '../chunks/bundle-fHeMHhND.js';\nimport { c as isContextMenuClosed, d as getMessageTopOffset } from '../chunks/bundle-C3ktHDOc.js';\nimport { p as pubSubFactory } from '../chunks/bundle-Df65wuUZ.js';\nimport { p as pubSubTopics } from '../chunks/bundle-b6TpX_JP.js';\nimport { e as VOICE_MESSAGE_FILE_NAME, a as VOICE_MESSAGE_MIME_TYPE, M as META_ARRAY_VOICE_DURATION_KEY, f as META_ARRAY_MESSAGE_TYPE_KEY, g as META_ARRAY_MESSAGE_TYPE_VALUE__VOICE } from '../chunks/bundle-DCMGp6rH.js';\nimport { g as getIsReactionEnabled } from '../chunks/bundle-BNDaXsLn.js';\nimport '../withSendbird.js';\nfunction useMessageListScroll(behavior, deps) {\n  if (deps === void 0) {\n    deps = [];\n  }\n  var scrollRef = useRef(null);\n  var scrollPositionRef = useRef(0);\n  var scrollDistanceFromBottomRef = useRef(0);\n  var scrollPubSub = useState(function () {\n    return pubSubFactory({\n      publishSynchronous: true\n    });\n  })[0];\n  var _a = useState(true),\n    isScrollBottomReached = _a[0],\n    setIsScrollBottomReached = _a[1];\n  // SideEffect: Reset scroll state\n  useLayoutEffect(function () {\n    scrollPositionRef.current = 0;\n    scrollDistanceFromBottomRef.current = 0;\n    setIsScrollBottomReached(true);\n    if (scrollRef.current) scrollRef.current.scrollTop = scrollRef.current.scrollHeight;\n  }, deps);\n  useLayoutEffect(function () {\n    var unsubscribes = [];\n    unsubscribes.push(scrollPubSub.subscribe('scrollToBottom', function (_a) {\n      var resolve = _a.resolve,\n        animated = _a.animated;\n      runCallback(function () {\n        if (!scrollRef.current) {\n          if (resolve) resolve();\n          return;\n        }\n        if (scrollRef.current.scroll) {\n          scrollRef.current.scroll({\n            top: scrollRef.current.scrollHeight,\n            behavior: getScrollBehavior(behavior, animated)\n          });\n        } else {\n          scrollRef.current.scrollTop = scrollRef.current.scrollHeight;\n        }\n        // Update data by manual update\n        scrollDistanceFromBottomRef.current = 0;\n        setIsScrollBottomReached(true);\n        if (resolve) resolve();\n      });\n    }));\n    unsubscribes.push(scrollPubSub.subscribe('scroll', function (_a) {\n      var top = _a.top,\n        animated = _a.animated,\n        lazy = _a.lazy,\n        resolve = _a.resolve;\n      runCallback(function () {\n        if (!scrollRef.current) return;\n        var _a = scrollRef.current,\n          scrollTop = _a.scrollTop,\n          scrollHeight = _a.scrollHeight,\n          clientHeight = _a.clientHeight;\n        if (scrollRef.current.scroll) {\n          scrollRef.current.scroll({\n            top: top,\n            behavior: getScrollBehavior(behavior, animated)\n          });\n        } else if (typeof top === 'number') {\n          scrollRef.current.scrollTop = top;\n        }\n        // Update data by manual update\n        scrollDistanceFromBottomRef.current = Math.max(0, scrollHeight - scrollTop - clientHeight);\n        setIsScrollBottomReached(scrollDistanceFromBottomRef.current === 0);\n        if (resolve) resolve();\n      }, lazy);\n    }));\n    return function () {\n      unsubscribes.forEach(function (_a) {\n        var remove = _a.remove;\n        return remove();\n      });\n    };\n  }, [behavior]);\n  return {\n    scrollRef: scrollRef,\n    scrollPubSub: scrollPubSub,\n    isScrollBottomReached: isScrollBottomReached,\n    setIsScrollBottomReached: setIsScrollBottomReached,\n    scrollDistanceFromBottomRef: scrollDistanceFromBottomRef,\n    scrollPositionRef: scrollPositionRef\n  };\n}\nfunction runCallback(callback, lazy) {\n  if (lazy === void 0) {\n    lazy = true;\n  }\n  if (lazy) {\n    setTimeout(function () {\n      callback();\n    });\n  } else {\n    callback();\n  }\n}\nfunction getScrollBehavior(behavior, animated) {\n  if (typeof animated === 'boolean') return animated ? 'smooth' : 'auto';\n  return behavior;\n}\nvar pass = function (value) {\n  return value;\n};\n/**\n * @description This hook controls common processes related to message sending, updating.\n * */\nfunction useMessageActions(params) {\n  var _this = this;\n  var _a = params.onBeforeSendUserMessage,\n    onBeforeSendUserMessage = _a === void 0 ? pass : _a,\n    _b = params.onBeforeSendFileMessage,\n    onBeforeSendFileMessage = _b === void 0 ? pass : _b,\n    _c = params.onBeforeUpdateUserMessage,\n    onBeforeUpdateUserMessage = _c === void 0 ? pass : _c,\n    _d = params.onBeforeSendVoiceMessage,\n    onBeforeSendVoiceMessage = _d === void 0 ? pass : _d,\n    _e = params.onBeforeSendMultipleFilesMessage,\n    onBeforeSendMultipleFilesMessage = _e === void 0 ? pass : _e,\n    sendFileMessage = params.sendFileMessage,\n    sendMultipleFilesMessage = params.sendMultipleFilesMessage,\n    sendUserMessage = params.sendUserMessage,\n    updateUserMessage = params.updateUserMessage,\n    scrollToBottom = params.scrollToBottom,\n    quoteMessage = params.quoteMessage,\n    replyType = params.replyType;\n  var buildInternalMessageParams = useCallback(function (basicParams) {\n    var messageParams = __assign({}, basicParams);\n    if (params.quoteMessage && replyType !== 'NONE') {\n      messageParams.isReplyToChannel = true;\n      messageParams.parentMessageId = quoteMessage === null || quoteMessage === void 0 ? void 0 : quoteMessage.messageId;\n    }\n    return messageParams;\n  }, [replyType, quoteMessage]);\n  return {\n    sendUserMessage: useCallback(function (params) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var internalParams, processedParams;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              internalParams = buildInternalMessageParams(params);\n              return [4 /*yield*/, onBeforeSendUserMessage(internalParams)];\n            case 1:\n              processedParams = _a.sent();\n              return [2 /*return*/, sendUserMessage(processedParams, function () {\n                return scrollToBottom();\n              })];\n          }\n        });\n      });\n    }, [buildInternalMessageParams, sendUserMessage, scrollToBottom]),\n    sendFileMessage: useCallback(function (params) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var internalParams, processedParams;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              internalParams = buildInternalMessageParams(params);\n              return [4 /*yield*/, onBeforeSendFileMessage(internalParams)];\n            case 1:\n              processedParams = _a.sent();\n              return [2 /*return*/, sendFileMessage(processedParams, function () {\n                return scrollToBottom();\n              })];\n          }\n        });\n      });\n    }, [buildInternalMessageParams, sendFileMessage, scrollToBottom]),\n    sendMultipleFilesMessage: useCallback(function (params) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var internalParams, processedParams;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              internalParams = buildInternalMessageParams(params);\n              return [4 /*yield*/, onBeforeSendMultipleFilesMessage(internalParams)];\n            case 1:\n              processedParams = _a.sent();\n              return [2 /*return*/, sendMultipleFilesMessage(processedParams, function () {\n                return scrollToBottom();\n              })];\n          }\n        });\n      });\n    }, [buildInternalMessageParams, sendMultipleFilesMessage, scrollToBottom]),\n    sendVoiceMessage: useCallback(function (params, duration) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var internalParams, processedParams;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              internalParams = buildInternalMessageParams(__assign(__assign({}, params), {\n                fileName: VOICE_MESSAGE_FILE_NAME,\n                mimeType: VOICE_MESSAGE_MIME_TYPE,\n                metaArrays: [new MessageMetaArray({\n                  key: META_ARRAY_VOICE_DURATION_KEY,\n                  value: [\"\".concat(duration)]\n                }), new MessageMetaArray({\n                  key: META_ARRAY_MESSAGE_TYPE_KEY,\n                  value: [META_ARRAY_MESSAGE_TYPE_VALUE__VOICE]\n                })]\n              }));\n              return [4 /*yield*/, onBeforeSendVoiceMessage(internalParams)];\n            case 1:\n              processedParams = _a.sent();\n              return [2 /*return*/, sendFileMessage(processedParams, function () {\n                return scrollToBottom();\n              })];\n          }\n        });\n      });\n    }, [buildInternalMessageParams, sendFileMessage, scrollToBottom]),\n    updateUserMessage: useCallback(function (messageId, params) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var internalParams, processedParams;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              internalParams = buildInternalMessageParams(params);\n              return [4 /*yield*/, onBeforeUpdateUserMessage(internalParams)];\n            case 1:\n              processedParams = _a.sent();\n              return [2 /*return*/, updateUserMessage(messageId, processedParams)];\n          }\n        });\n      });\n    }, [buildInternalMessageParams, updateUserMessage])\n  };\n}\nvar GroupChannelContext = React__default.createContext(null);\nvar GroupChannelProvider = function (props) {\n  var _a, _b, _c;\n  var channelUrl = props.channelUrl,\n    children = props.children,\n    moduleReactionEnabled = props.isReactionEnabled,\n    moduleReplyType = props.replyType,\n    moduleThreadReplySelectType = props.threadReplySelectType,\n    _d = props.isMessageGroupingEnabled,\n    isMessageGroupingEnabled = _d === void 0 ? true : _d,\n    isMultipleFilesMessageEnabled = props.isMultipleFilesMessageEnabled,\n    showSearchIcon = props.showSearchIcon,\n    _e = props.disableMarkAsRead,\n    disableMarkAsRead = _e === void 0 ? false : _e,\n    _f = props.scrollBehavior,\n    scrollBehavior = _f === void 0 ? 'auto' : _f,\n    startingPoint = props.startingPoint,\n    _animatedMessageId = props.animatedMessageId,\n    messageListQueryParams = props.messageListQueryParams,\n    onBeforeSendUserMessage = props.onBeforeSendUserMessage,\n    onBeforeSendFileMessage = props.onBeforeSendFileMessage,\n    onBeforeSendVoiceMessage = props.onBeforeSendVoiceMessage,\n    onBeforeSendMultipleFilesMessage = props.onBeforeSendMultipleFilesMessage,\n    onBeforeUpdateUserMessage = props.onBeforeUpdateUserMessage,\n    onBeforeDownloadFileMessage = props.onBeforeDownloadFileMessage,\n    onMessageAnimated = props.onMessageAnimated,\n    onBackClick = props.onBackClick,\n    onChatHeaderActionClick = props.onChatHeaderActionClick,\n    onReplyInThreadClick = props.onReplyInThreadClick,\n    onSearchClick = props.onSearchClick,\n    onQuoteMessageClick = props.onQuoteMessageClick,\n    renderUserMentionItem = props.renderUserMentionItem;\n  // Global context\n  var _g = useSendbirdStateContext(),\n    config = _g.config,\n    stores = _g.stores;\n  var sdkStore = stores.sdkStore;\n  var markAsReadScheduler = config.markAsReadScheduler,\n    logger = config.logger;\n  // State\n  var _h = useState(null),\n    quoteMessage = _h[0],\n    setQuoteMessage = _h[1];\n  var _j = useState(null),\n    animatedMessageId = _j[0],\n    setAnimatedMessageId = _j[1];\n  var _k = useState(null),\n    currentChannel = _k[0],\n    setCurrentChannel = _k[1];\n  var _l = useState(null),\n    fetchChannelError = _l[0],\n    setFetchChannelError = _l[1];\n  // Ref\n  var _m = useMessageListScroll(scrollBehavior, [currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url]),\n    scrollRef = _m.scrollRef,\n    scrollPubSub = _m.scrollPubSub,\n    scrollDistanceFromBottomRef = _m.scrollDistanceFromBottomRef,\n    isScrollBottomReached = _m.isScrollBottomReached,\n    setIsScrollBottomReached = _m.setIsScrollBottomReached,\n    scrollPositionRef = _m.scrollPositionRef;\n  var messageInputRef = useRef(null);\n  var toggleReaction = useToggleReactionCallback(currentChannel, logger);\n  var replyType = getCaseResolvedReplyType(moduleReplyType !== null && moduleReplyType !== void 0 ? moduleReplyType : config.groupChannel.replyType).upperCase;\n  var threadReplySelectType = getCaseResolvedThreadReplySelectType(moduleThreadReplySelectType !== null && moduleThreadReplySelectType !== void 0 ? moduleThreadReplySelectType : config.groupChannel.threadReplySelectType).upperCase;\n  var chatReplyType = useIIFE(function () {\n    if (replyType === 'NONE') return ReplyType.NONE;\n    return ReplyType.ONLY_REPLY_TO_CHANNEL;\n  });\n  var isReactionEnabled = getIsReactionEnabled({\n    channel: currentChannel,\n    config: config,\n    moduleLevel: moduleReactionEnabled\n  });\n  var nicknamesMap = useMemo(function () {\n    var _a;\n    return new Map(((_a = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.members) !== null && _a !== void 0 ? _a : []).map(function (_a) {\n      var userId = _a.userId,\n        nickname = _a.nickname;\n      return [userId, nickname];\n    }));\n  }, [currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.members]);\n  var messageDataSource = useGroupChannelMessages(sdkStore.sdk, currentChannel, {\n    startingPoint: startingPoint,\n    replyType: chatReplyType,\n    collectionCreator: getCollectionCreator(currentChannel, messageListQueryParams),\n    shouldCountNewMessages: function () {\n      return !isScrollBottomReached;\n    },\n    markAsRead: function (channels) {\n      if (isScrollBottomReached && !disableMarkAsRead) {\n        channels.forEach(function (it) {\n          return markAsReadScheduler.push(it);\n        });\n      }\n    },\n    onMessagesReceived: function () {\n      // FIXME: onMessagesReceived called with onApiResult\n      if (isScrollBottomReached && isContextMenuClosed()) {\n        scrollPubSub.publish('scrollToBottom', {});\n      }\n    },\n    onChannelDeleted: function () {\n      setCurrentChannel(null);\n      setFetchChannelError(null);\n    },\n    onCurrentUserBanned: function () {\n      setCurrentChannel(null);\n      setFetchChannelError(null);\n    },\n    onChannelUpdated: function (channel) {\n      return setCurrentChannel(channel);\n    },\n    logger: logger\n  });\n  // SideEffect: Fetch and set to current channel by channelUrl prop.\n  useAsyncEffect(function () {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var channel, error_1;\n      var _a;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (!(sdkStore.initialized && channelUrl)) return [3 /*break*/, 5];\n            _b.label = 1;\n          case 1:\n            _b.trys.push([1, 3, 4, 5]);\n            return [4 /*yield*/, sdkStore.sdk.groupChannel.getChannel(channelUrl)];\n          case 2:\n            channel = _b.sent();\n            setCurrentChannel(channel);\n            setFetchChannelError(null);\n            return [3 /*break*/, 5];\n          case 3:\n            error_1 = _b.sent();\n            setCurrentChannel(null);\n            setFetchChannelError(error_1);\n            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, 'GroupChannelProvider: error when fetching channel', error_1);\n            return [3 /*break*/, 5];\n          case 4:\n            // Reset states when channel changes\n            setQuoteMessage(null);\n            setAnimatedMessageId(null);\n            return [7 /*endfinally*/];\n          case 5:\n            return [2 /*return*/];\n        }\n      });\n    });\n  }, [sdkStore.initialized, sdkStore.sdk, channelUrl]);\n  // SideEffect: Scroll to the bottom\n  //  - On the initialized message list\n  //  - On messages sent from the thread\n  useAsyncLayoutEffect(function () {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var onSentMessageFromOtherModule, subscribes;\n      return __generator(this, function (_a) {\n        if (messageDataSource.initialized) {\n          scrollPubSub.publish('scrollToBottom', {});\n        }\n        onSentMessageFromOtherModule = function (data) {\n          if (data.channel.url === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url)) scrollPubSub.publish('scrollToBottom', {});\n        };\n        subscribes = [config.pubSub.subscribe(pubSubTopics.SEND_USER_MESSAGE, onSentMessageFromOtherModule), config.pubSub.subscribe(pubSubTopics.SEND_FILE_MESSAGE, onSentMessageFromOtherModule)];\n        return [2 /*return*/, function () {\n          subscribes.forEach(function (subscribe) {\n            return subscribe.remove();\n          });\n        }];\n      });\n    });\n  }, [messageDataSource.initialized, currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url]);\n  // SideEffect: Reset MessageCollection with startingPoint prop.\n  useEffect(function () {\n    if (typeof startingPoint === 'number') {\n      // We do not handle animation for message search here.\n      // Please update the animatedMessageId prop to trigger the animation.\n      scrollToMessage(startingPoint, 0, false, false);\n    }\n  }, [startingPoint]);\n  // SideEffect: Update animatedMessageId prop to state.\n  useEffect(function () {\n    if (_animatedMessageId) setAnimatedMessageId(_animatedMessageId);\n  }, [_animatedMessageId]);\n  var scrollToBottom = usePreservedCallback(function (animated) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!scrollRef.current) return [2 /*return*/];\n            setAnimatedMessageId(null);\n            setIsScrollBottomReached(true);\n            if (!(config.isOnline && messageDataSource.hasNext())) return [3 /*break*/, 2];\n            return [4 /*yield*/, messageDataSource.resetWithStartingPoint(Number.MAX_SAFE_INTEGER)];\n          case 1:\n            _a.sent();\n            scrollPubSub.publish('scrollToBottom', {\n              animated: animated\n            });\n            return [3 /*break*/, 3];\n          case 2:\n            scrollPubSub.publish('scrollToBottom', {\n              animated: animated\n            });\n            _a.label = 3;\n          case 3:\n            if (currentChannel && !messageDataSource.hasNext()) {\n              messageDataSource.resetNewMessages();\n              if (!disableMarkAsRead) markAsReadScheduler.push(currentChannel);\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  });\n  var scrollToMessage = usePreservedCallback(function (createdAt, messageId, messageFocusAnimated, scrollAnimated) {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var element, parentNode, clickHandler, message, topOffset;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            element = scrollRef.current;\n            parentNode = element === null || element === void 0 ? void 0 : element.parentNode;\n            clickHandler = {\n              activate: function () {\n                if (!element || !parentNode) return;\n                element.style.pointerEvents = 'auto';\n                parentNode.style.cursor = 'auto';\n              },\n              deactivate: function () {\n                if (!element || !parentNode) return;\n                element.style.pointerEvents = 'none';\n                parentNode.style.cursor = 'wait';\n              }\n            };\n            clickHandler.deactivate();\n            setAnimatedMessageId(null);\n            message = messageDataSource.messages.find(function (it) {\n              return it.messageId === messageId || it.createdAt === createdAt;\n            });\n            if (!message) return [3 /*break*/, 1];\n            topOffset = getMessageTopOffset(message.createdAt);\n            if (topOffset) scrollPubSub.publish('scroll', {\n              top: topOffset,\n              animated: scrollAnimated\n            });\n            if (messageFocusAnimated !== null && messageFocusAnimated !== void 0 ? messageFocusAnimated : true) setAnimatedMessageId(messageId);\n            return [3 /*break*/, 3];\n          case 1:\n            return [4 /*yield*/, messageDataSource.resetWithStartingPoint(createdAt)];\n          case 2:\n            _a.sent();\n            setTimeout(function () {\n              var topOffset = getMessageTopOffset(createdAt);\n              if (topOffset) scrollPubSub.publish('scroll', {\n                top: topOffset,\n                lazy: false,\n                animated: scrollAnimated\n              });\n              if (messageFocusAnimated !== null && messageFocusAnimated !== void 0 ? messageFocusAnimated : true) setAnimatedMessageId(messageId);\n            });\n            _a.label = 3;\n          case 3:\n            clickHandler.activate();\n            return [2 /*return*/];\n        }\n      });\n    });\n  });\n  var messageActions = useMessageActions(__assign(__assign(__assign({}, props), messageDataSource), {\n    scrollToBottom: scrollToBottom,\n    quoteMessage: quoteMessage,\n    replyType: replyType\n  }));\n  return React__default.createElement(GroupChannelContext.Provider, {\n    value: __assign(__assign({\n      // # Props\n      channelUrl: channelUrl,\n      isReactionEnabled: isReactionEnabled,\n      isMessageGroupingEnabled: isMessageGroupingEnabled,\n      isMultipleFilesMessageEnabled: isMultipleFilesMessageEnabled,\n      showSearchIcon: showSearchIcon !== null && showSearchIcon !== void 0 ? showSearchIcon : config.groupChannelSettings.enableMessageSearch,\n      replyType: replyType,\n      threadReplySelectType: threadReplySelectType,\n      disableMarkAsRead: disableMarkAsRead,\n      scrollBehavior: scrollBehavior,\n      // # Custom Props\n      messageListQueryParams: messageListQueryParams,\n      // ## Message\n      onBeforeSendUserMessage: onBeforeSendUserMessage,\n      onBeforeSendFileMessage: onBeforeSendFileMessage,\n      onBeforeSendVoiceMessage: onBeforeSendVoiceMessage,\n      onBeforeSendMultipleFilesMessage: onBeforeSendMultipleFilesMessage,\n      onBeforeUpdateUserMessage: onBeforeUpdateUserMessage,\n      onBeforeDownloadFileMessage: onBeforeDownloadFileMessage,\n      // ## Focusing\n      onMessageAnimated: onMessageAnimated,\n      // ## Click\n      onBackClick: onBackClick,\n      onChatHeaderActionClick: onChatHeaderActionClick,\n      onReplyInThreadClick: onReplyInThreadClick,\n      onSearchClick: onSearchClick,\n      onQuoteMessageClick: onQuoteMessageClick,\n      // ## Custom render\n      renderUserMentionItem: renderUserMentionItem,\n      // Internal Interface\n      currentChannel: currentChannel,\n      fetchChannelError: fetchChannelError,\n      nicknamesMap: nicknamesMap,\n      scrollRef: scrollRef,\n      scrollDistanceFromBottomRef: scrollDistanceFromBottomRef,\n      scrollPositionRef: scrollPositionRef,\n      scrollPubSub: scrollPubSub,\n      messageInputRef: messageInputRef,\n      quoteMessage: quoteMessage,\n      setQuoteMessage: setQuoteMessage,\n      animatedMessageId: animatedMessageId,\n      setAnimatedMessageId: setAnimatedMessageId,\n      isScrollBottomReached: isScrollBottomReached,\n      setIsScrollBottomReached: setIsScrollBottomReached,\n      scrollToBottom: scrollToBottom,\n      scrollToMessage: scrollToMessage,\n      toggleReaction: toggleReaction\n    }, messageDataSource), messageActions)\n  }, React__default.createElement(UserProfileProvider, {\n    disableUserProfile: (_a = props === null || props === void 0 ? void 0 : props.disableUserProfile) !== null && _a !== void 0 ? _a : config === null || config === void 0 ? void 0 : config.disableUserProfile,\n    renderUserProfile: (_b = props === null || props === void 0 ? void 0 : props.renderUserProfile) !== null && _b !== void 0 ? _b : config === null || config === void 0 ? void 0 : config.renderUserProfile,\n    onUserProfileMessage: (_c = props === null || props === void 0 ? void 0 : props.onUserProfileMessage) !== null && _c !== void 0 ? _c : config === null || config === void 0 ? void 0 : config.onUserProfileMessage\n  }, children));\n};\nvar useGroupChannelContext = function () {\n  var context = useContext(GroupChannelContext);\n  if (!context) throw new Error('GroupChannelContext not found. Use within the GroupChannel module.');\n  return context;\n};\nfunction getCollectionCreator(groupChannel, messageListQueryParams) {\n  return function (defaultParams) {\n    var params = __assign(__assign(__assign({}, defaultParams), {\n      prevResultLimit: 30,\n      nextResultLimit: 30\n    }), messageListQueryParams);\n    return groupChannel.createMessageCollection(__assign(__assign({}, params), {\n      filter: new MessageFilter(params)\n    }));\n  };\n}\nexport { GroupChannelContext, GroupChannelProvider, useGroupChannelContext };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import { _ as __assign, a as __awaiter, b as __generator } from '../chunks/bundle-BQi9-O76.js';\nimport React__default, { useRef, useState, useLayoutEffect, useCallback, useMemo, useEffect, useContext } from 'react';\nimport { MessageMetaArray, ReplyType } from '@sendbird/chat/message';\nimport { MessageFilter } from '@sendbird/chat/groupChannel';\nimport { useIIFE, useGroupChannelMessages, useAsyncEffect, useAsyncLayoutEffect, usePreservedCallback } from '@sendbird/uikit-tools';\nimport { U as UserProfileProvider } from '../chunks/bundle-BrTJ5Zbd.js';\nimport { useSendbirdStateContext } from '../useSendbirdStateContext.js';\nimport { u as useToggleReactionCallback } from '../chunks/bundle-y29vL7zu.js';\nimport { g as getCaseResolvedReplyType, a as getCaseResolvedThreadReplySelectType } from '../chunks/bundle-fHeMHhND.js';\nimport { c as isContextMenuClosed, d as getMessageTopOffset } from '../chunks/bundle-C3ktHDOc.js';\nimport { p as pubSubFactory } from '../chunks/bundle-Df65wuUZ.js';\nimport { p as pubSubTopics } from '../chunks/bundle-b6TpX_JP.js';\nimport { e as VOICE_MESSAGE_FILE_NAME, a as VOICE_MESSAGE_MIME_TYPE, M as META_ARRAY_VOICE_DURATION_KEY, f as META_ARRAY_MESSAGE_TYPE_KEY, g as META_ARRAY_MESSAGE_TYPE_VALUE__VOICE } from '../chunks/bundle-DCMGp6rH.js';\nimport { g as getIsReactionEnabled } from '../chunks/bundle-BNDaXsLn.js';\nimport '../withSendbird.js';\n\nfunction useMessageListScroll(behavior, deps) {\n    if (deps === void 0) { deps = []; }\n    var scrollRef = useRef(null);\n    var scrollPositionRef = useRef(0);\n    var scrollDistanceFromBottomRef = useRef(0);\n    var scrollPubSub = useState(function () { return pubSubFactory({ publishSynchronous: true }); })[0];\n    var _a = useState(true), isScrollBottomReached = _a[0], setIsScrollBottomReached = _a[1];\n    // SideEffect: Reset scroll state\n    useLayoutEffect(function () {\n        scrollPositionRef.current = 0;\n        scrollDistanceFromBottomRef.current = 0;\n        setIsScrollBottomReached(true);\n        if (scrollRef.current)\n            scrollRef.current.scrollTop = scrollRef.current.scrollHeight;\n    }, deps);\n    useLayoutEffect(function () {\n        var unsubscribes = [];\n        unsubscribes.push(scrollPubSub.subscribe('scrollToBottom', function (_a) {\n            var resolve = _a.resolve, animated = _a.animated;\n            runCallback(function () {\n                if (!scrollRef.current) {\n                    if (resolve)\n                        resolve();\n                    return;\n                }\n                if (scrollRef.current.scroll) {\n                    scrollRef.current.scroll({ top: scrollRef.current.scrollHeight, behavior: getScrollBehavior(behavior, animated) });\n                }\n                else {\n                    scrollRef.current.scrollTop = scrollRef.current.scrollHeight;\n                }\n                // Update data by manual update\n                scrollDistanceFromBottomRef.current = 0;\n                setIsScrollBottomReached(true);\n                if (resolve)\n                    resolve();\n            });\n        }));\n        unsubscribes.push(scrollPubSub.subscribe('scroll', function (_a) {\n            var top = _a.top, animated = _a.animated, lazy = _a.lazy, resolve = _a.resolve;\n            runCallback(function () {\n                if (!scrollRef.current)\n                    return;\n                var _a = scrollRef.current, scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;\n                if (scrollRef.current.scroll) {\n                    scrollRef.current.scroll({ top: top, behavior: getScrollBehavior(behavior, animated) });\n                }\n                else if (typeof top === 'number') {\n                    scrollRef.current.scrollTop = top;\n                }\n                // Update data by manual update\n                scrollDistanceFromBottomRef.current = Math.max(0, scrollHeight - scrollTop - clientHeight);\n                setIsScrollBottomReached(scrollDistanceFromBottomRef.current === 0);\n                if (resolve)\n                    resolve();\n            }, lazy);\n        }));\n        return function () {\n            unsubscribes.forEach(function (_a) {\n                var remove = _a.remove;\n                return remove();\n            });\n        };\n    }, [behavior]);\n    return {\n        scrollRef: scrollRef,\n        scrollPubSub: scrollPubSub,\n        isScrollBottomReached: isScrollBottomReached,\n        setIsScrollBottomReached: setIsScrollBottomReached,\n        scrollDistanceFromBottomRef: scrollDistanceFromBottomRef,\n        scrollPositionRef: scrollPositionRef,\n    };\n}\nfunction runCallback(callback, lazy) {\n    if (lazy === void 0) { lazy = true; }\n    if (lazy) {\n        setTimeout(function () {\n            callback();\n        });\n    }\n    else {\n        callback();\n    }\n}\nfunction getScrollBehavior(behavior, animated) {\n    if (typeof animated === 'boolean')\n        return animated ? 'smooth' : 'auto';\n    return behavior;\n}\n\nvar pass = function (value) { return value; };\n/**\n * @description This hook controls common processes related to message sending, updating.\n * */\nfunction useMessageActions(params) {\n    var _this = this;\n    var _a = params.onBeforeSendUserMessage, onBeforeSendUserMessage = _a === void 0 ? pass : _a, _b = params.onBeforeSendFileMessage, onBeforeSendFileMessage = _b === void 0 ? pass : _b, _c = params.onBeforeUpdateUserMessage, onBeforeUpdateUserMessage = _c === void 0 ? pass : _c, _d = params.onBeforeSendVoiceMessage, onBeforeSendVoiceMessage = _d === void 0 ? pass : _d, _e = params.onBeforeSendMultipleFilesMessage, onBeforeSendMultipleFilesMessage = _e === void 0 ? pass : _e, sendFileMessage = params.sendFileMessage, sendMultipleFilesMessage = params.sendMultipleFilesMessage, sendUserMessage = params.sendUserMessage, updateUserMessage = params.updateUserMessage, scrollToBottom = params.scrollToBottom, quoteMessage = params.quoteMessage, replyType = params.replyType;\n    var buildInternalMessageParams = useCallback(function (basicParams) {\n        var messageParams = __assign({}, basicParams);\n        if (params.quoteMessage && replyType !== 'NONE') {\n            messageParams.isReplyToChannel = true;\n            messageParams.parentMessageId = quoteMessage === null || quoteMessage === void 0 ? void 0 : quoteMessage.messageId;\n        }\n        return messageParams;\n    }, [replyType, quoteMessage]);\n    return {\n        sendUserMessage: useCallback(function (params) { return __awaiter(_this, void 0, void 0, function () {\n            var internalParams, processedParams;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        internalParams = buildInternalMessageParams(params);\n                        return [4 /*yield*/, onBeforeSendUserMessage(internalParams)];\n                    case 1:\n                        processedParams = _a.sent();\n                        return [2 /*return*/, sendUserMessage(processedParams, function () { return scrollToBottom(); })];\n                }\n            });\n        }); }, [buildInternalMessageParams, sendUserMessage, scrollToBottom]),\n        sendFileMessage: useCallback(function (params) { return __awaiter(_this, void 0, void 0, function () {\n            var internalParams, processedParams;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        internalParams = buildInternalMessageParams(params);\n                        return [4 /*yield*/, onBeforeSendFileMessage(internalParams)];\n                    case 1:\n                        processedParams = _a.sent();\n                        return [2 /*return*/, sendFileMessage(processedParams, function () { return scrollToBottom(); })];\n                }\n            });\n        }); }, [buildInternalMessageParams, sendFileMessage, scrollToBottom]),\n        sendMultipleFilesMessage: useCallback(function (params) { return __awaiter(_this, void 0, void 0, function () {\n            var internalParams, processedParams;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        internalParams = buildInternalMessageParams(params);\n                        return [4 /*yield*/, onBeforeSendMultipleFilesMessage(internalParams)];\n                    case 1:\n                        processedParams = _a.sent();\n                        return [2 /*return*/, sendMultipleFilesMessage(processedParams, function () { return scrollToBottom(); })];\n                }\n            });\n        }); }, [buildInternalMessageParams, sendMultipleFilesMessage, scrollToBottom]),\n        sendVoiceMessage: useCallback(function (params, duration) { return __awaiter(_this, void 0, void 0, function () {\n            var internalParams, processedParams;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        internalParams = buildInternalMessageParams(__assign(__assign({}, params), { fileName: VOICE_MESSAGE_FILE_NAME, mimeType: VOICE_MESSAGE_MIME_TYPE, metaArrays: [\n                                new MessageMetaArray({\n                                    key: META_ARRAY_VOICE_DURATION_KEY,\n                                    value: [\"\".concat(duration)],\n                                }),\n                                new MessageMetaArray({\n                                    key: META_ARRAY_MESSAGE_TYPE_KEY,\n                                    value: [META_ARRAY_MESSAGE_TYPE_VALUE__VOICE],\n                                }),\n                            ] }));\n                        return [4 /*yield*/, onBeforeSendVoiceMessage(internalParams)];\n                    case 1:\n                        processedParams = _a.sent();\n                        return [2 /*return*/, sendFileMessage(processedParams, function () { return scrollToBottom(); })];\n                }\n            });\n        }); }, [buildInternalMessageParams, sendFileMessage, scrollToBottom]),\n        updateUserMessage: useCallback(function (messageId, params) { return __awaiter(_this, void 0, void 0, function () {\n            var internalParams, processedParams;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        internalParams = buildInternalMessageParams(params);\n                        return [4 /*yield*/, onBeforeUpdateUserMessage(internalParams)];\n                    case 1:\n                        processedParams = _a.sent();\n                        return [2 /*return*/, updateUserMessage(messageId, processedParams)];\n                }\n            });\n        }); }, [buildInternalMessageParams, updateUserMessage]),\n    };\n}\n\nvar GroupChannelContext = React__default.createContext(null);\nvar GroupChannelProvider = function (props) {\n    var _a, _b, _c;\n    var channelUrl = props.channelUrl, children = props.children, moduleReactionEnabled = props.isReactionEnabled, moduleReplyType = props.replyType, moduleThreadReplySelectType = props.threadReplySelectType, _d = props.isMessageGroupingEnabled, isMessageGroupingEnabled = _d === void 0 ? true : _d, isMultipleFilesMessageEnabled = props.isMultipleFilesMessageEnabled, showSearchIcon = props.showSearchIcon, _e = props.disableMarkAsRead, disableMarkAsRead = _e === void 0 ? false : _e, _f = props.scrollBehavior, scrollBehavior = _f === void 0 ? 'auto' : _f, startingPoint = props.startingPoint, _animatedMessageId = props.animatedMessageId, messageListQueryParams = props.messageListQueryParams, onBeforeSendUserMessage = props.onBeforeSendUserMessage, onBeforeSendFileMessage = props.onBeforeSendFileMessage, onBeforeSendVoiceMessage = props.onBeforeSendVoiceMessage, onBeforeSendMultipleFilesMessage = props.onBeforeSendMultipleFilesMessage, onBeforeUpdateUserMessage = props.onBeforeUpdateUserMessage, onBeforeDownloadFileMessage = props.onBeforeDownloadFileMessage, onMessageAnimated = props.onMessageAnimated, onBackClick = props.onBackClick, onChatHeaderActionClick = props.onChatHeaderActionClick, onReplyInThreadClick = props.onReplyInThreadClick, onSearchClick = props.onSearchClick, onQuoteMessageClick = props.onQuoteMessageClick, renderUserMentionItem = props.renderUserMentionItem;\n    // Global context\n    var _g = useSendbirdStateContext(), config = _g.config, stores = _g.stores;\n    var sdkStore = stores.sdkStore;\n    var markAsReadScheduler = config.markAsReadScheduler, logger = config.logger;\n    // State\n    var _h = useState(null), quoteMessage = _h[0], setQuoteMessage = _h[1];\n    var _j = useState(null), animatedMessageId = _j[0], setAnimatedMessageId = _j[1];\n    var _k = useState(null), currentChannel = _k[0], setCurrentChannel = _k[1];\n    var _l = useState(null), fetchChannelError = _l[0], setFetchChannelError = _l[1];\n    // Ref\n    var _m = useMessageListScroll(scrollBehavior, [currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url]), scrollRef = _m.scrollRef, scrollPubSub = _m.scrollPubSub, scrollDistanceFromBottomRef = _m.scrollDistanceFromBottomRef, isScrollBottomReached = _m.isScrollBottomReached, setIsScrollBottomReached = _m.setIsScrollBottomReached, scrollPositionRef = _m.scrollPositionRef;\n    var messageInputRef = useRef(null);\n    var toggleReaction = useToggleReactionCallback(currentChannel, logger);\n    var replyType = getCaseResolvedReplyType(moduleReplyType !== null && moduleReplyType !== void 0 ? moduleReplyType : config.groupChannel.replyType).upperCase;\n    var threadReplySelectType = getCaseResolvedThreadReplySelectType(moduleThreadReplySelectType !== null && moduleThreadReplySelectType !== void 0 ? moduleThreadReplySelectType : config.groupChannel.threadReplySelectType).upperCase;\n    var chatReplyType = useIIFE(function () {\n        if (replyType === 'NONE')\n            return ReplyType.NONE;\n        return ReplyType.ONLY_REPLY_TO_CHANNEL;\n    });\n    var isReactionEnabled = getIsReactionEnabled({\n        channel: currentChannel,\n        config: config,\n        moduleLevel: moduleReactionEnabled,\n    });\n    var nicknamesMap = useMemo(function () { var _a; return new Map(((_a = currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.members) !== null && _a !== void 0 ? _a : []).map(function (_a) {\n        var userId = _a.userId, nickname = _a.nickname;\n        return [userId, nickname];\n    })); }, [currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.members]);\n    var messageDataSource = useGroupChannelMessages(sdkStore.sdk, currentChannel, {\n        startingPoint: startingPoint,\n        replyType: chatReplyType,\n        collectionCreator: getCollectionCreator(currentChannel, messageListQueryParams),\n        shouldCountNewMessages: function () { return !isScrollBottomReached; },\n        markAsRead: function (channels) {\n            if (isScrollBottomReached && !disableMarkAsRead) {\n                channels.forEach(function (it) { return markAsReadScheduler.push(it); });\n            }\n        },\n        onMessagesReceived: function () {\n            // FIXME: onMessagesReceived called with onApiResult\n            if (isScrollBottomReached && isContextMenuClosed()) {\n                scrollPubSub.publish('scrollToBottom', {});\n            }\n        },\n        onChannelDeleted: function () {\n            setCurrentChannel(null);\n            setFetchChannelError(null);\n        },\n        onCurrentUserBanned: function () {\n            setCurrentChannel(null);\n            setFetchChannelError(null);\n        },\n        onChannelUpdated: function (channel) { return setCurrentChannel(channel); },\n        logger: logger,\n    });\n    // SideEffect: Fetch and set to current channel by channelUrl prop.\n    useAsyncEffect(function () { return __awaiter(void 0, void 0, void 0, function () {\n        var channel, error_1;\n        var _a;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    if (!(sdkStore.initialized && channelUrl)) return [3 /*break*/, 5];\n                    _b.label = 1;\n                case 1:\n                    _b.trys.push([1, 3, 4, 5]);\n                    return [4 /*yield*/, sdkStore.sdk.groupChannel.getChannel(channelUrl)];\n                case 2:\n                    channel = _b.sent();\n                    setCurrentChannel(channel);\n                    setFetchChannelError(null);\n                    return [3 /*break*/, 5];\n                case 3:\n                    error_1 = _b.sent();\n                    setCurrentChannel(null);\n                    setFetchChannelError(error_1);\n                    (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, 'GroupChannelProvider: error when fetching channel', error_1);\n                    return [3 /*break*/, 5];\n                case 4:\n                    // Reset states when channel changes\n                    setQuoteMessage(null);\n                    setAnimatedMessageId(null);\n                    return [7 /*endfinally*/];\n                case 5: return [2 /*return*/];\n            }\n        });\n    }); }, [sdkStore.initialized, sdkStore.sdk, channelUrl]);\n    // SideEffect: Scroll to the bottom\n    //  - On the initialized message list\n    //  - On messages sent from the thread\n    useAsyncLayoutEffect(function () { return __awaiter(void 0, void 0, void 0, function () {\n        var onSentMessageFromOtherModule, subscribes;\n        return __generator(this, function (_a) {\n            if (messageDataSource.initialized) {\n                scrollPubSub.publish('scrollToBottom', {});\n            }\n            onSentMessageFromOtherModule = function (data) {\n                if (data.channel.url === (currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url))\n                    scrollPubSub.publish('scrollToBottom', {});\n            };\n            subscribes = [\n                config.pubSub.subscribe(pubSubTopics.SEND_USER_MESSAGE, onSentMessageFromOtherModule),\n                config.pubSub.subscribe(pubSubTopics.SEND_FILE_MESSAGE, onSentMessageFromOtherModule),\n            ];\n            return [2 /*return*/, function () {\n                    subscribes.forEach(function (subscribe) { return subscribe.remove(); });\n                }];\n        });\n    }); }, [messageDataSource.initialized, currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url]);\n    // SideEffect: Reset MessageCollection with startingPoint prop.\n    useEffect(function () {\n        if (typeof startingPoint === 'number') {\n            // We do not handle animation for message search here.\n            // Please update the animatedMessageId prop to trigger the animation.\n            scrollToMessage(startingPoint, 0, false, false);\n        }\n    }, [startingPoint]);\n    // SideEffect: Update animatedMessageId prop to state.\n    useEffect(function () {\n        if (_animatedMessageId)\n            setAnimatedMessageId(_animatedMessageId);\n    }, [_animatedMessageId]);\n    var scrollToBottom = usePreservedCallback(function (animated) { return __awaiter(void 0, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!scrollRef.current)\n                        return [2 /*return*/];\n                    setAnimatedMessageId(null);\n                    setIsScrollBottomReached(true);\n                    if (!(config.isOnline && messageDataSource.hasNext())) return [3 /*break*/, 2];\n                    return [4 /*yield*/, messageDataSource.resetWithStartingPoint(Number.MAX_SAFE_INTEGER)];\n                case 1:\n                    _a.sent();\n                    scrollPubSub.publish('scrollToBottom', { animated: animated });\n                    return [3 /*break*/, 3];\n                case 2:\n                    scrollPubSub.publish('scrollToBottom', { animated: animated });\n                    _a.label = 3;\n                case 3:\n                    if (currentChannel && !messageDataSource.hasNext()) {\n                        messageDataSource.resetNewMessages();\n                        if (!disableMarkAsRead)\n                            markAsReadScheduler.push(currentChannel);\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    }); });\n    var scrollToMessage = usePreservedCallback(function (createdAt, messageId, messageFocusAnimated, scrollAnimated) { return __awaiter(void 0, void 0, void 0, function () {\n        var element, parentNode, clickHandler, message, topOffset;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    element = scrollRef.current;\n                    parentNode = element === null || element === void 0 ? void 0 : element.parentNode;\n                    clickHandler = {\n                        activate: function () {\n                            if (!element || !parentNode)\n                                return;\n                            element.style.pointerEvents = 'auto';\n                            parentNode.style.cursor = 'auto';\n                        },\n                        deactivate: function () {\n                            if (!element || !parentNode)\n                                return;\n                            element.style.pointerEvents = 'none';\n                            parentNode.style.cursor = 'wait';\n                        },\n                    };\n                    clickHandler.deactivate();\n                    setAnimatedMessageId(null);\n                    message = messageDataSource.messages.find(function (it) { return it.messageId === messageId || it.createdAt === createdAt; });\n                    if (!message) return [3 /*break*/, 1];\n                    topOffset = getMessageTopOffset(message.createdAt);\n                    if (topOffset)\n                        scrollPubSub.publish('scroll', { top: topOffset, animated: scrollAnimated });\n                    if (messageFocusAnimated !== null && messageFocusAnimated !== void 0 ? messageFocusAnimated : true)\n                        setAnimatedMessageId(messageId);\n                    return [3 /*break*/, 3];\n                case 1: return [4 /*yield*/, messageDataSource.resetWithStartingPoint(createdAt)];\n                case 2:\n                    _a.sent();\n                    setTimeout(function () {\n                        var topOffset = getMessageTopOffset(createdAt);\n                        if (topOffset)\n                            scrollPubSub.publish('scroll', { top: topOffset, lazy: false, animated: scrollAnimated });\n                        if (messageFocusAnimated !== null && messageFocusAnimated !== void 0 ? messageFocusAnimated : true)\n                            setAnimatedMessageId(messageId);\n                    });\n                    _a.label = 3;\n                case 3:\n                    clickHandler.activate();\n                    return [2 /*return*/];\n            }\n        });\n    }); });\n    var messageActions = useMessageActions(__assign(__assign(__assign({}, props), messageDataSource), { scrollToBottom: scrollToBottom, quoteMessage: quoteMessage, replyType: replyType }));\n    return (React__default.createElement(GroupChannelContext.Provider, { value: __assign(__assign({ \n            // # Props\n            channelUrl: channelUrl, isReactionEnabled: isReactionEnabled, isMessageGroupingEnabled: isMessageGroupingEnabled, isMultipleFilesMessageEnabled: isMultipleFilesMessageEnabled, showSearchIcon: showSearchIcon !== null && showSearchIcon !== void 0 ? showSearchIcon : config.groupChannelSettings.enableMessageSearch, replyType: replyType, threadReplySelectType: threadReplySelectType, disableMarkAsRead: disableMarkAsRead, scrollBehavior: scrollBehavior, \n            // # Custom Props\n            messageListQueryParams: messageListQueryParams, \n            // ## Message\n            onBeforeSendUserMessage: onBeforeSendUserMessage, onBeforeSendFileMessage: onBeforeSendFileMessage, onBeforeSendVoiceMessage: onBeforeSendVoiceMessage, onBeforeSendMultipleFilesMessage: onBeforeSendMultipleFilesMessage, onBeforeUpdateUserMessage: onBeforeUpdateUserMessage, onBeforeDownloadFileMessage: onBeforeDownloadFileMessage, \n            // ## Focusing\n            onMessageAnimated: onMessageAnimated, \n            // ## Click\n            onBackClick: onBackClick, onChatHeaderActionClick: onChatHeaderActionClick, onReplyInThreadClick: onReplyInThreadClick, onSearchClick: onSearchClick, onQuoteMessageClick: onQuoteMessageClick, \n            // ## Custom render\n            renderUserMentionItem: renderUserMentionItem, \n            // Internal Interface\n            currentChannel: currentChannel, fetchChannelError: fetchChannelError, nicknamesMap: nicknamesMap, scrollRef: scrollRef, scrollDistanceFromBottomRef: scrollDistanceFromBottomRef, scrollPositionRef: scrollPositionRef, scrollPubSub: scrollPubSub, messageInputRef: messageInputRef, quoteMessage: quoteMessage, setQuoteMessage: setQuoteMessage, animatedMessageId: animatedMessageId, setAnimatedMessageId: setAnimatedMessageId, isScrollBottomReached: isScrollBottomReached, setIsScrollBottomReached: setIsScrollBottomReached, scrollToBottom: scrollToBottom, scrollToMessage: scrollToMessage, toggleReaction: toggleReaction }, messageDataSource), messageActions) },\n        React__default.createElement(UserProfileProvider, { disableUserProfile: (_a = props === null || props === void 0 ? void 0 : props.disableUserProfile) !== null && _a !== void 0 ? _a : config === null || config === void 0 ? void 0 : config.disableUserProfile, renderUserProfile: (_b = props === null || props === void 0 ? void 0 : props.renderUserProfile) !== null && _b !== void 0 ? _b : config === null || config === void 0 ? void 0 : config.renderUserProfile, onUserProfileMessage: (_c = props === null || props === void 0 ? void 0 : props.onUserProfileMessage) !== null && _c !== void 0 ? _c : config === null || config === void 0 ? void 0 : config.onUserProfileMessage }, children)));\n};\nvar useGroupChannelContext = function () {\n    var context = useContext(GroupChannelContext);\n    if (!context)\n        throw new Error('GroupChannelContext not found. Use within the GroupChannel module.');\n    return context;\n};\nfunction getCollectionCreator(groupChannel, messageListQueryParams) {\n    return function (defaultParams) {\n        var params = __assign(__assign(__assign({}, defaultParams), { prevResultLimit: 30, nextResultLimit: 30 }), messageListQueryParams);\n        return groupChannel.createMessageCollection(__assign(__assign({}, params), { filter: new MessageFilter(params) }));\n    };\n}\n\nexport { GroupChannelContext, GroupChannelProvider, useGroupChannelContext };\n//# sourceMappingURL=context.js.map\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module"}