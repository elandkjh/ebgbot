{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { useEffect, useLayoutEffect, useRef } from 'react';\nimport { CollectionEventSource } from '@sendbird/chat';\nimport { MessageCollectionInitPolicy, MessageFilter } from '@sendbird/chat/groupChannel';\nimport { ReplyType } from '@sendbird/chat/message';\nimport { sbuConstants } from '../../constants/sbuConstants.js';\nimport { isDifferentChannel } from '../../utils/channel.js';\nimport { isMyMessage, isSendableMessage } from '../../utils/message.js';\nimport { isNotEmptyArray } from '../../utils/validators.js';\nimport { useAsyncEffect } from '../useAsyncEffect.js';\nimport { useForceUpdate } from '../useForceUpdate.js';\nimport { useGroupChannelHandler } from '../useGroupChannelHandler.js';\nimport { usePreservedCallback } from '../usePreservedCallback.js';\nimport { useChannelThreadMessagesReducer } from './reducer.js';\nfunction isThreadedMessage(message, parentMessage) {\n  return message.parentMessageId === parentMessage.messageId;\n}\nexport const useGroupChannelThreadMessages = (sdk, channel, parentMessage, options = {}) => {\n  var _a, _b, _c, _d, _e;\n  const internalOptions = useRef(options); // to keep reference of options in event handler\n  internalOptions.current = options;\n  const channelRef = useRef(channel); // to keep reference of channel in event handler\n  channelRef.current = channel;\n  const parentMessageRef = useRef(parentMessage); // to keep reference of parent message in event handler\n  parentMessageRef.current = parentMessage;\n  const startingPoint = useRef(((_a = internalOptions.current) === null || _a === void 0 ? void 0 : _a.startingPoint) || Number.MAX_SAFE_INTEGER);\n  startingPoint.current = ((_b = internalOptions.current) === null || _b === void 0 ? void 0 : _b.startingPoint) || Number.MAX_SAFE_INTEGER;\n  const prevFetchSize = sbuConstants.collection.message.defaultLimit.prev;\n  const nextFetchSize = sbuConstants.collection.message.defaultLimit.next;\n  const logger = internalOptions.current.logger;\n  const isFetching = useRef({\n    prev: false,\n    next: false\n  });\n  const forceUpdate = useForceUpdate();\n  const collectionRef = useRef({\n    initialized: false,\n    apiInitialized: false,\n    instance: null\n  });\n  const {\n    initialized,\n    loading,\n    refreshing,\n    hasPreviousMessages,\n    hasNextMessages,\n    oldestMessageTimeStamp,\n    latestMessageTimeStamp,\n    messages,\n    newMessages,\n    updateMessages,\n    updateNewMessages,\n    deleteNewMessages,\n    deleteMessages,\n    updateInitialized,\n    updateLoading,\n    updateRefreshing,\n    updateHasPreviousMessages,\n    updateHasNextMessages\n  } = useChannelThreadMessagesReducer(options === null || options === void 0 ? void 0 : options.sortComparator);\n  const markAsReadBySource = usePreservedCallback(source => {\n    var _a, _b, _c, _d;\n    if (!channelRef.current || !channelRef.current.url) {\n      return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n    }\n    try {\n      switch (source) {\n        case CollectionEventSource.EVENT_MESSAGE_RECEIVED:\n        case CollectionEventSource.EVENT_MESSAGE_SENT_SUCCESS:\n        case CollectionEventSource.SYNC_MESSAGE_FILL:\n        case undefined:\n          (_c = (_b = internalOptions.current).markAsRead) === null || _c === void 0 ? void 0 : _c.call(_b, [channelRef.current]);\n          break;\n      }\n    } catch (e) {\n      (_d = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _d === void 0 ? void 0 : _d.call(logger, '[useGroupChannelThreadMessages/markAsReadBySource]', e);\n    }\n  });\n  const updateNewMessagesReceived = usePreservedCallback((source, messages) => {\n    var _a, _b, _c, _d, _e;\n    const incomingMessages = messages.filter(it => {\n      var _a;\n      return isThreadedMessage(it, parentMessageRef.current) && !isMyMessage(it, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n    });\n    if (incomingMessages.length > 0) {\n      switch (source) {\n        case CollectionEventSource.EVENT_MESSAGE_RECEIVED:\n        case CollectionEventSource.SYNC_MESSAGE_FILL:\n          {\n            if ((_b = (_a = internalOptions.current).shouldCountNewMessages) === null || _b === void 0 ? void 0 : _b.call(_a)) {\n              updateNewMessages(incomingMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n            }\n            (_e = (_d = internalOptions.current).onMessagesReceived) === null || _e === void 0 ? void 0 : _e.call(_d, incomingMessages);\n            break;\n          }\n      }\n    }\n  });\n  useAsyncEffect(() => __awaiter(void 0, void 0, void 0, function* () {\n    var _f, _g, _h, _j, _k;\n    const messages = yield (_f = channelRef.current) === null || _f === void 0 ? void 0 : _f.getMessagesByMessageId((_g = parentMessageRef.current) === null || _g === void 0 ? void 0 : _g.messageId, {\n      prevResultSize: 1,\n      nextResultSize: 1,\n      isInclusive: true,\n      includeThreadInfo: true,\n      includeMetaArray: true,\n      includeReactions: (_h = internalOptions.current.isReactionEnabled) !== null && _h !== void 0 ? _h : false\n    });\n    const parentMessage = messages === null || messages === void 0 ? void 0 : messages.find(message => {\n      return message.messageId === parentMessageRef.current.messageId;\n    });\n    if (parentMessage) {\n      parentMessageRef.current = parentMessage;\n      (_k = (_j = internalOptions.current).onParentMessageUpdated) === null || _k === void 0 ? void 0 : _k.call(_j, parentMessage);\n    }\n  }), [(_c = channelRef.current) === null || _c === void 0 ? void 0 : _c.url, internalOptions.current.isReactionEnabled]);\n  const init = usePreservedCallback(startingPoint => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise(resolve => {\n      var _a, _b, _c;\n      if (!channelRef.current || !channelRef.current.url) {\n        return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      }\n      if (!parentMessageRef.current) {\n        return (_b = logger === null || logger === void 0 ? void 0 : logger.error) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelThreadMessages] parent message is required');\n      }\n      if (collectionRef.current.instance) collectionRef.current.instance.dispose();\n      markAsReadBySource();\n      updateNewMessages([], true, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n      const updateUnsentMessages = () => {\n        var _a, _b;\n        const {\n          pendingMessages,\n          failedMessages\n        } = (_a = collectionRef.current.instance) !== null && _a !== void 0 ? _a : {};\n        let filteredMessages;\n        if (isNotEmptyArray(pendingMessages)) {\n          filteredMessages = pendingMessages.filter(message => isThreadedMessage(message, parentMessageRef.current));\n        }\n        if (isNotEmptyArray(failedMessages)) {\n          filteredMessages = failedMessages.filter(message => isThreadedMessage(message, parentMessageRef.current));\n        }\n        if (isNotEmptyArray(filteredMessages)) updateMessages(filteredMessages, false, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId);\n      };\n      setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {\n        var _d, _e, _f, _g;\n        try {\n          if (parentMessageRef.current) {\n            const params = {\n              prevResultSize: prevFetchSize,\n              nextResultSize: nextFetchSize,\n              isInclusive: true,\n              includeReactions: (_d = internalOptions.current.isReactionEnabled) !== null && _d !== void 0 ? _d : false\n            };\n            const {\n              threadedMessages\n            } = yield parentMessageRef.current.getThreadedMessagesByTimestamp(startingPoint, params);\n            if (isNotEmptyArray(threadedMessages)) {\n              const prevMessagesCount = threadedMessages.filter(message => message.createdAt < startingPoint).length;\n              const nextMessagesCount = threadedMessages.filter(message => message.createdAt > startingPoint).length;\n              updateHasPreviousMessages(prevMessagesCount >= prevFetchSize);\n              updateHasNextMessages(nextMessagesCount >= nextFetchSize);\n              updateMessages(threadedMessages, true, (_e = sdk.currentUser) === null || _e === void 0 ? void 0 : _e.userId);\n            }\n          } else {\n            (_f = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _f === void 0 ? void 0 : _f.call(logger, '[useGroupChannelThreadMessages] parent message is required');\n          }\n          resolve();\n        } catch (error) {\n          (_g = logger === null || logger === void 0 ? void 0 : logger.error) === null || _g === void 0 ? void 0 : _g.call(logger, '[useGroupChannelThreadMessages] Initialize thread list failed.', error);\n        }\n      }));\n      const collectionInstance = channelRef.current.createMessageCollection({\n        prevResultLimit: prevFetchSize,\n        nextResultLimit: nextFetchSize,\n        startingPoint: startingPoint - 1,\n        filter: new MessageFilter({\n          replyType: ReplyType.ALL\n        })\n      });\n      collectionRef.current = {\n        apiInitialized: false,\n        initialized: false,\n        instance: collectionInstance\n      };\n      collectionInstance.setMessageCollectionHandler({\n        onMessagesAdded: (ctx, __, messages) => {\n          var _a;\n          const filteredMessages = messages.filter(message => isThreadedMessage(message, parentMessageRef.current));\n          if (isNotEmptyArray(filteredMessages)) {\n            markAsReadBySource(ctx.source);\n            updateNewMessagesReceived(ctx.source, filteredMessages);\n            updateMessages(filteredMessages, false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n          }\n        },\n        onMessagesUpdated: (ctx, __, messages) => {\n          var _a, _b, _c, _d, _e;\n          const filteredMessages = messages.filter(message => isThreadedMessage(message, parentMessageRef.current));\n          const parentMessage = messages.find(message => message.messageId === parentMessageRef.current.messageId);\n          if (parentMessage) {\n            parentMessageRef.current = parentMessage;\n            (_b = (_a = internalOptions.current).onParentMessageUpdated) === null || _b === void 0 ? void 0 : _b.call(_a, parentMessage);\n          }\n          if (isNotEmptyArray(filteredMessages)) {\n            markAsReadBySource(ctx.source);\n            updateNewMessagesReceived(ctx.source, filteredMessages); // NOTE: admin message is not added via onMessagesAdded handler, not checked yet is this a bug.\n            updateMessages(filteredMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n            if (ctx.source === CollectionEventSource.EVENT_MESSAGE_UPDATED) {\n              (_e = (_d = internalOptions.current).onMessagesUpdated) === null || _e === void 0 ? void 0 : _e.call(_d, filteredMessages);\n            }\n          }\n        },\n        onMessagesDeleted: (_, __, ___, messages) => {\n          var _a, _b;\n          const parentMessage = messages.find(message => message.messageId === parentMessageRef.current.messageId);\n          if (parentMessage) {\n            (_b = (_a = internalOptions.current).onParentMessageDeleted) === null || _b === void 0 ? void 0 : _b.call(_a);\n          }\n          const filteredMessages = messages.filter(message => isThreadedMessage(message, parentMessageRef.current));\n          if (isNotEmptyArray(filteredMessages)) {\n            const msgIds = filteredMessages.map(it => it.messageId);\n            const reqIds = filteredMessages.filter(isSendableMessage).map(it => it.reqId);\n            deleteMessages(msgIds, reqIds);\n            deleteNewMessages(msgIds, reqIds);\n          }\n        },\n        onChannelDeleted: (_, channelUrl) => {\n          var _a, _b;\n          (_b = (_a = internalOptions.current).onChannelDeleted) === null || _b === void 0 ? void 0 : _b.call(_a, channelUrl);\n        },\n        onChannelUpdated: (_, channel) => {\n          var _a, _b;\n          forceUpdate();\n          (_b = (_a = internalOptions.current).onChannelUpdated) === null || _b === void 0 ? void 0 : _b.call(_a, channel);\n        },\n        onHugeGapDetected: () => {\n          init(startingPoint);\n        }\n      });\n      collectionInstance.initialize(MessageCollectionInitPolicy.CACHE_AND_REPLACE_BY_API).onCacheResult((err, messages) => {\n        var _a, _b, _c;\n        if (err) {\n          sdk.isCacheEnabled && ((_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages/onCacheResult]', err));\n        } else if (messages) {\n          (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelThreadMessages/onCacheResult]', 'message length:', messages.length);\n          const filteredMessages = messages.filter(message => isThreadedMessage(message, parentMessageRef.current));\n          if (isNotEmptyArray(filteredMessages)) {\n            updateMessages(filteredMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n            updateUnsentMessages();\n          }\n        }\n      }).onApiResult((err, messages) => {\n        var _a, _b, _c;\n        if (err) {\n          (_a = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages/onApiResult]', err);\n        } else if (messages) {\n          (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelThreadMessages/onApiResult]', 'message length:', messages.length);\n          const filteredMessages = messages.filter(message => isThreadedMessage(message, parentMessageRef.current));\n          if (isNotEmptyArray(filteredMessages)) {\n            updateMessages(filteredMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n            if (sdk.isCacheEnabled) updateUnsentMessages();\n          }\n        }\n        collectionRef.current.initialized = true;\n        collectionRef.current.apiInitialized = true;\n      });\n    });\n  }));\n  useGroupChannelHandler(sdk, {\n    onUserBanned(eventChannel, bannedUser) {\n      var _a, _b, _c;\n      if (eventChannel.isGroupChannel() && !isDifferentChannel(eventChannel, channelRef.current)) {\n        if (bannedUser.userId === ((_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId)) {\n          (_c = (_b = internalOptions.current).onCurrentUserBanned) === null || _c === void 0 ? void 0 : _c.call(_b);\n        } else {\n          forceUpdate();\n        }\n      }\n    }\n  });\n  useLayoutEffect(() => {\n    const timeout = setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {\n      if (sdk.currentUser && channelRef.current) {\n        updateInitialized(false);\n        updateLoading(true);\n        yield init(startingPoint.current);\n        updateLoading(false);\n        updateInitialized(true);\n      }\n    }));\n    return () => clearTimeout(timeout);\n  }, [sdk, (_d = sdk.currentUser) === null || _d === void 0 ? void 0 : _d.userId, (_e = channelRef.current) === null || _e === void 0 ? void 0 : _e.url, startingPoint.current]);\n  useEffect(() => {\n    return () => {\n      if (collectionRef.current.instance) collectionRef.current.instance.dispose();\n    };\n  }, []);\n  const refresh = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n    if (sdk.currentUser && channelRef.current) {\n      updateRefreshing(true);\n      yield init(startingPoint.current);\n      updateRefreshing(false);\n    }\n  }));\n  const loadPrevious = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n    var _l, _m, _o, _p;\n    if (!channelRef.current || !channelRef.current.url || !parentMessageRef.current) {\n      (_l = logger === null || logger === void 0 ? void 0 : logger.error) === null || _l === void 0 ? void 0 : _l.call(logger, '[useGroupChannelThreadMessages] channel or parent message is required');\n      return;\n    }\n    if (hasPreviousMessages && !isFetching.current.prev) {\n      try {\n        isFetching.current.prev = true;\n        const params = {\n          prevResultSize: prevFetchSize,\n          nextResultSize: 0,\n          isInclusive: false,\n          includeReactions: (_m = internalOptions.current.isReactionEnabled) !== null && _m !== void 0 ? _m : false\n        };\n        const {\n          threadedMessages\n        } = yield parentMessageRef.current.getThreadedMessagesByTimestamp(oldestMessageTimeStamp, params);\n        if (isNotEmptyArray(threadedMessages)) {\n          updateHasPreviousMessages(threadedMessages.length >= prevFetchSize);\n          updateMessages(threadedMessages, false, (_o = sdk.currentUser) === null || _o === void 0 ? void 0 : _o.userId);\n        }\n      } catch (error) {\n        (_p = logger === null || logger === void 0 ? void 0 : logger.error) === null || _p === void 0 ? void 0 : _p.call(logger, '[useGroupChannelThreadMessages] loadPrevious thread list failed.', error);\n      } finally {\n        isFetching.current.prev = false;\n      }\n    }\n  }));\n  const hasPrevious = usePreservedCallback(() => {\n    return hasPreviousMessages;\n  });\n  const loadNext = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n    var _q, _r, _s, _t;\n    if (!channelRef.current || !channelRef.current.url || !parentMessageRef.current) {\n      (_q = logger === null || logger === void 0 ? void 0 : logger.error) === null || _q === void 0 ? void 0 : _q.call(logger, '[useGroupChannelThreadMessages] channel or parent message is required');\n      return;\n    }\n    if (hasNextMessages && !isFetching.current.next) {\n      try {\n        isFetching.current.prev = true;\n        const params = {\n          prevResultSize: 0,\n          nextResultSize: nextFetchSize,\n          isInclusive: false,\n          includeReactions: (_r = internalOptions.current.isReactionEnabled) !== null && _r !== void 0 ? _r : false\n        };\n        const {\n          threadedMessages\n        } = yield parentMessageRef.current.getThreadedMessagesByTimestamp(latestMessageTimeStamp, params);\n        updateHasNextMessages(threadedMessages.length >= nextFetchSize);\n        updateMessages(threadedMessages, false, (_s = sdk.currentUser) === null || _s === void 0 ? void 0 : _s.userId);\n      } catch (error) {\n        (_t = logger === null || logger === void 0 ? void 0 : logger.error) === null || _t === void 0 ? void 0 : _t.call(logger, '[useGroupChannelThreadMessages] loadNext thread list failed.', error);\n      } finally {\n        isFetching.current.next = false;\n      }\n    }\n  }));\n  const hasNext = usePreservedCallback(() => {\n    return hasNextMessages;\n  });\n  const sendUserMessage = usePreservedCallback((params, onPending) => {\n    var _a;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise((resolve, reject) => {\n      channelRef.current.sendUserMessage(params).onPending(pendingMessage => {\n        var _a;\n        if (pendingMessage.channelUrl === channelRef.current.url) {\n          updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n      }).onSucceeded(sentMessage => {\n        var _a;\n        if (sentMessage.channelUrl === channelRef.current.url) {\n          updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        resolve(sentMessage);\n      }).onFailed((err, failedMessage) => {\n        var _a;\n        if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n          updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        reject(err);\n      });\n    });\n  });\n  const sendFileMessage = usePreservedCallback((params, onPending) => {\n    var _a;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise((resolve, reject) => {\n      channelRef.current.sendFileMessage(params).onPending(pendingMessage => {\n        var _a;\n        if (pendingMessage.channelUrl === channelRef.current.url) {\n          updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n      }).onSucceeded(sentMessage => {\n        var _a;\n        if (sentMessage.channelUrl === channelRef.current.url) {\n          updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        resolve(sentMessage);\n      }).onFailed((err, failedMessage) => {\n        var _a;\n        if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n          updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        reject(err);\n      });\n    });\n  });\n  const sendFileMessages = usePreservedCallback((paramsList, onPending) => __awaiter(void 0, void 0, void 0, function* () {\n    var _u;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_u = logger === null || logger === void 0 ? void 0 : logger.error) === null || _u === void 0 ? void 0 : _u.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise(resolve => {\n      const messages = [];\n      channelRef.current.sendFileMessages(paramsList).onPending(pendingMessage => {\n        var _a;\n        if (pendingMessage.channelUrl === channelRef.current.url) {\n          updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n      }).onSucceeded(sentMessage => {\n        var _a;\n        if (sentMessage.isFileMessage() && sentMessage.channelUrl === channelRef.current.url) {\n          updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n          messages.push(sentMessage);\n        }\n        if (messages.length === paramsList.length) resolve(messages);\n      }).onFailed((_, failedMessage) => {\n        var _a;\n        if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n          updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n          messages.push(failedMessage);\n        } else {\n          // NOTE: Since failedMessage is nullable by type, to resolve the promise, handle pushing null even when there is no failedMessage.\n          messages.push(null);\n        }\n        if (messages.length === paramsList.length) resolve(messages);\n      });\n    });\n  }));\n  const sendMultipleFilesMessage = usePreservedCallback((params, onPending) => {\n    var _a;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise((resolve, reject) => {\n      channelRef.current.sendMultipleFilesMessage(params).onPending(pendingMessage => {\n        var _a;\n        if (pendingMessage.channelUrl === channelRef.current.url) {\n          updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n      }).onFileUploaded(() => {\n        // Just re-render to use updated message.messageParams\n        forceUpdate();\n      }).onSucceeded(sentMessage => {\n        var _a;\n        if (sentMessage.channelUrl === channelRef.current.url) {\n          updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        resolve(sentMessage);\n      }).onFailed((err, failedMessage) => {\n        var _a;\n        if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n          updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        reject(err);\n      });\n    });\n  });\n  const updateUserMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {\n    var _v, _w;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_v = logger === null || logger === void 0 ? void 0 : logger.error) === null || _v === void 0 ? void 0 : _v.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    const updatedMessage = yield channelRef.current.updateUserMessage(messageId, params);\n    if (updatedMessage.channelUrl === channelRef.current.url && isThreadedMessage(updatedMessage, parentMessageRef.current)) {\n      updateMessages([updatedMessage], false, (_w = sdk.currentUser) === null || _w === void 0 ? void 0 : _w.userId);\n    }\n    return updatedMessage;\n  }));\n  const updateFileMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {\n    var _x, _y;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_x = logger === null || logger === void 0 ? void 0 : logger.error) === null || _x === void 0 ? void 0 : _x.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    const updatedMessage = yield channelRef.current.updateFileMessage(messageId, params);\n    if (updatedMessage.channelUrl === channelRef.current.url && isThreadedMessage(updatedMessage, parentMessageRef.current)) {\n      updateMessages([updatedMessage], false, (_y = sdk.currentUser) === null || _y === void 0 ? void 0 : _y.userId);\n    }\n    return updatedMessage;\n  }));\n  const resendMessage = usePreservedCallback(failedMessage => __awaiter(void 0, void 0, void 0, function* () {\n    var _z;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_z = logger === null || logger === void 0 ? void 0 : logger.error) === null || _z === void 0 ? void 0 : _z.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise((resolve, reject) => {\n      let handler = undefined;\n      if (failedMessage.isUserMessage()) handler = channelRef.current.resendMessage(failedMessage);\n      if (failedMessage.isFileMessage()) handler = channelRef.current.resendMessage(failedMessage);\n      if (failedMessage.isMultipleFilesMessage()) handler = channelRef.current.resendMessage(failedMessage);\n      if (handler) {\n        if ('onPending' in handler) {\n          handler.onPending(message => {\n            var _a;\n            if (message.channelUrl === channelRef.current.url) {\n              updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n            }\n          });\n        }\n        if ('onFileUploaded' in handler) {\n          handler.onFileUploaded(() => {\n            // Just re-render to use updated message.messageParams\n            forceUpdate();\n          });\n        }\n        if ('onSucceeded' in handler) {\n          handler.onSucceeded(message => {\n            var _a;\n            if (message.channelUrl === channelRef.current.url) {\n              updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n            }\n            resolve(message);\n          });\n        }\n        if ('onFailed' in handler) {\n          handler.onFailed((err, message) => {\n            var _a;\n            if (message && message.channelUrl === channelRef.current.url) {\n              updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n            }\n            reject(err);\n          });\n        }\n      }\n    });\n  }));\n  const deleteMessage = usePreservedCallback(message => __awaiter(void 0, void 0, void 0, function* () {\n    var _0, _1;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_0 = logger === null || logger === void 0 ? void 0 : logger.error) === null || _0 === void 0 ? void 0 : _0.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    if (message.sendingStatus === 'succeeded') {\n      if (message.isUserMessage()) yield channelRef.current.deleteMessage(message);\n      if (message.isFileMessage()) yield channelRef.current.deleteMessage(message);\n      if (message.isMultipleFilesMessage()) yield channelRef.current.deleteMessage(message);\n    } else {\n      try {\n        yield (_1 = collectionRef.current.instance) === null || _1 === void 0 ? void 0 : _1.removeFailedMessage(message.reqId);\n      } finally {\n        deleteMessages([message.messageId], [message.reqId]);\n      }\n    }\n  }));\n  const resetNewMessages = usePreservedCallback(() => {\n    var _a;\n    updateNewMessages([], true, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n  });\n  const resetWithStartingPoint = usePreservedCallback(startingPoint => __awaiter(void 0, void 0, void 0, function* () {\n    var _2;\n    if (sdk.currentUser && channelRef.current) {\n      updateLoading(true);\n      updateMessages([], true, (_2 = sdk.currentUser) === null || _2 === void 0 ? void 0 : _2.userId);\n      yield init(startingPoint);\n      updateLoading(false);\n    }\n  }));\n  return {\n    /**\n     * Initialized state, only available on first render\n     * */\n    initialized,\n    /**\n     * Loading state, status is changes on first mount or when the resetWithStartingPoint is called.\n     * */\n    loading,\n    /**\n     * Refreshing state, status is changes when the refresh is called.\n     * */\n    refreshing,\n    /**\n     * Get messages, this state is for render\n     * For example, if a user receives a new messages while searching for an old message\n     * for this case, new messages will be included here.\n     * */\n    messages,\n    /**\n     * If the `shouldCountNewMessages()` is true, only then push in the newMessages state.\n     * (Return false for the `shouldCountNewMessages()` if the message scroll is the most recent; otherwise, return true.)\n     *\n     * A new message means a message that meets the below conditions\n     * - Not admin message\n     * - Not updated message\n     * - Not current user's message\n     * */\n    newMessages,\n    /**\n     * Reset new message list\n     * @return {void}\n     * */\n    resetNewMessages,\n    /**\n     * Reset message list and create a new collection for latest messages\n     * @return {Promise<void>}\n     * */\n    refresh,\n    /**\n     * Load previous messages to state\n     * @return {Promise<void>}\n     * */\n    loadPrevious,\n    /**\n     * Check if there are more previous messages to fetch\n     * @return {boolean}\n     * */\n    hasPrevious,\n    /**\n     * Load next messages to state\n     * @return {Promise<void>}\n     * */\n    loadNext,\n    /**\n     * Check if there are more next messages to fetch\n     * @return {boolean}\n     * */\n    hasNext,\n    /**\n     * Send user message\n     * @param {UserMessageCreateParams} params user message create params\n     * @param {function} [onPending] pending message callback\n     * @return {Promise<UserMessage>} succeeded message\n     * */\n    sendUserMessage,\n    /**\n     * Send file message\n     * @param {FileMessageCreateParams} params file message create params\n     * @param {function} [onPending] pending message callback\n     * @return {Promise<FileMessage>} succeeded message\n     * */\n    sendFileMessage,\n    /**\n     * Send file messages\n     * @param {FileMessageCreateParams[]} paramList file message create params\n     * @param {function} [onPending] pending message callback for each message request\n     * @return {Promise<FileMessage[]>} succeeded or failed message\n     * */\n    sendFileMessages,\n    /**\n     * Send multiple files message\n     * @param {MultipleFilesMessageCreateParams} params multiple files message create params\n     * @param {function} [onPending] pending message callback\n     * @return {Promise<MultipleFilesMessage>} succeeded message\n     * */\n    sendMultipleFilesMessage,\n    /**\n     * Update user message\n     * @param {number} messageId\n     * @param {UserMessageUpdateParams} params user message update params\n     * @return {Promise<UserMessage>}\n     * */\n    updateUserMessage,\n    /**\n     * Update file message\n     * @param {number} messageId\n     * @param {FileMessageUpdateParams} params file message update params\n     * @return {Promise<FileMessage>}\n     * */\n    updateFileMessage,\n    /**\n     * Resend failed message\n     * @template {UserMessage | FileMessage | MultipleFilesMessage} T\n     * @param {T} failedMessage message to resend\n     * @return {Promise<T>}\n     * */\n    resendMessage,\n    /**\n     * Delete a message\n     * @template {UserMessage | FileMessage | MultipleFilesMessage} T\n     * @param {T} message succeeded or failed message\n     * @return {Promise<void>}\n     * */\n    deleteMessage,\n    /**\n     * Reset message list and create a new collection with starting point\n     * @param {number} startingPoint\n     * @param {function} callback\n     * @return {void}\n     * */\n    resetWithStartingPoint\n  };\n};","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","useEffect","useLayoutEffect","useRef","CollectionEventSource","MessageCollectionInitPolicy","MessageFilter","ReplyType","sbuConstants","isDifferentChannel","isMyMessage","isSendableMessage","isNotEmptyArray","useAsyncEffect","useForceUpdate","useGroupChannelHandler","usePreservedCallback","useChannelThreadMessagesReducer","isThreadedMessage","message","parentMessage","parentMessageId","messageId","useGroupChannelThreadMessages","sdk","channel","options","_a","_b","_c","_d","_e","internalOptions","current","channelRef","parentMessageRef","startingPoint","Number","MAX_SAFE_INTEGER","prevFetchSize","collection","defaultLimit","prev","nextFetchSize","logger","isFetching","forceUpdate","collectionRef","initialized","apiInitialized","instance","loading","refreshing","hasPreviousMessages","hasNextMessages","oldestMessageTimeStamp","latestMessageTimeStamp","messages","newMessages","updateMessages","updateNewMessages","deleteNewMessages","deleteMessages","updateInitialized","updateLoading","updateRefreshing","updateHasPreviousMessages","updateHasNextMessages","sortComparator","markAsReadBySource","source","url","error","call","EVENT_MESSAGE_RECEIVED","EVENT_MESSAGE_SENT_SUCCESS","SYNC_MESSAGE_FILL","undefined","markAsRead","warn","updateNewMessagesReceived","incomingMessages","filter","it","currentUser","userId","length","shouldCountNewMessages","onMessagesReceived","_f","_g","_h","_j","_k","getMessagesByMessageId","prevResultSize","nextResultSize","isInclusive","includeThreadInfo","includeMetaArray","includeReactions","isReactionEnabled","find","onParentMessageUpdated","init","dispose","updateUnsentMessages","pendingMessages","failedMessages","filteredMessages","setTimeout","params","threadedMessages","getThreadedMessagesByTimestamp","prevMessagesCount","createdAt","nextMessagesCount","collectionInstance","createMessageCollection","prevResultLimit","nextResultLimit","replyType","ALL","setMessageCollectionHandler","onMessagesAdded","ctx","__","onMessagesUpdated","EVENT_MESSAGE_UPDATED","onMessagesDeleted","_","___","onParentMessageDeleted","msgIds","map","reqIds","reqId","onChannelDeleted","channelUrl","onChannelUpdated","onHugeGapDetected","initialize","CACHE_AND_REPLACE_BY_API","onCacheResult","err","isCacheEnabled","debug","onApiResult","onUserBanned","eventChannel","bannedUser","isGroupChannel","onCurrentUserBanned","timeout","clearTimeout","refresh","loadPrevious","_l","_m","_o","_p","hasPrevious","loadNext","_q","_r","_s","_t","hasNext","sendUserMessage","onPending","Error","pendingMessage","onSucceeded","sentMessage","onFailed","failedMessage","sendFileMessage","sendFileMessages","paramsList","_u","isFileMessage","push","sendMultipleFilesMessage","onFileUploaded","updateUserMessage","_v","_w","updatedMessage","updateFileMessage","_x","_y","resendMessage","_z","handler","isUserMessage","isMultipleFilesMessage","deleteMessage","_0","_1","sendingStatus","removeFailedMessage","resetNewMessages","resetWithStartingPoint","_2"],"sources":["D:/ebgbot/node_modules/@sendbird/uikit-react/node_modules/@sendbird/uikit-tools/dist/esm/hooks/useGroupChannelThreadMessages/index.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { useEffect, useLayoutEffect, useRef } from 'react';\nimport { CollectionEventSource } from '@sendbird/chat';\nimport { MessageCollectionInitPolicy, MessageFilter } from '@sendbird/chat/groupChannel';\nimport { ReplyType } from '@sendbird/chat/message';\nimport { sbuConstants } from '../../constants/sbuConstants.js';\nimport { isDifferentChannel } from '../../utils/channel.js';\nimport { isMyMessage, isSendableMessage } from '../../utils/message.js';\nimport { isNotEmptyArray } from '../../utils/validators.js';\nimport { useAsyncEffect } from '../useAsyncEffect.js';\nimport { useForceUpdate } from '../useForceUpdate.js';\nimport { useGroupChannelHandler } from '../useGroupChannelHandler.js';\nimport { usePreservedCallback } from '../usePreservedCallback.js';\nimport { useChannelThreadMessagesReducer } from './reducer.js';\nfunction isThreadedMessage(message, parentMessage) {\n    return message.parentMessageId === parentMessage.messageId;\n}\nexport const useGroupChannelThreadMessages = (sdk, channel, parentMessage, options = {}) => {\n    var _a, _b, _c, _d, _e;\n    const internalOptions = useRef(options); // to keep reference of options in event handler\n    internalOptions.current = options;\n    const channelRef = useRef(channel); // to keep reference of channel in event handler\n    channelRef.current = channel;\n    const parentMessageRef = useRef(parentMessage); // to keep reference of parent message in event handler\n    parentMessageRef.current = parentMessage;\n    const startingPoint = useRef(((_a = internalOptions.current) === null || _a === void 0 ? void 0 : _a.startingPoint) || Number.MAX_SAFE_INTEGER);\n    startingPoint.current = ((_b = internalOptions.current) === null || _b === void 0 ? void 0 : _b.startingPoint) || Number.MAX_SAFE_INTEGER;\n    const prevFetchSize = sbuConstants.collection.message.defaultLimit.prev;\n    const nextFetchSize = sbuConstants.collection.message.defaultLimit.next;\n    const logger = internalOptions.current.logger;\n    const isFetching = useRef({ prev: false, next: false });\n    const forceUpdate = useForceUpdate();\n    const collectionRef = useRef({\n        initialized: false,\n        apiInitialized: false,\n        instance: null,\n    });\n    const { initialized, loading, refreshing, hasPreviousMessages, hasNextMessages, oldestMessageTimeStamp, latestMessageTimeStamp, messages, newMessages, updateMessages, updateNewMessages, deleteNewMessages, deleteMessages, updateInitialized, updateLoading, updateRefreshing, updateHasPreviousMessages, updateHasNextMessages, } = useChannelThreadMessagesReducer(options === null || options === void 0 ? void 0 : options.sortComparator);\n    const markAsReadBySource = usePreservedCallback((source) => {\n        var _a, _b, _c, _d;\n        if (!channelRef.current || !channelRef.current.url) {\n            return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n        }\n        try {\n            switch (source) {\n                case CollectionEventSource.EVENT_MESSAGE_RECEIVED:\n                case CollectionEventSource.EVENT_MESSAGE_SENT_SUCCESS:\n                case CollectionEventSource.SYNC_MESSAGE_FILL:\n                case undefined:\n                    (_c = (_b = internalOptions.current).markAsRead) === null || _c === void 0 ? void 0 : _c.call(_b, [channelRef.current]);\n                    break;\n            }\n        }\n        catch (e) {\n            (_d = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _d === void 0 ? void 0 : _d.call(logger, '[useGroupChannelThreadMessages/markAsReadBySource]', e);\n        }\n    });\n    const updateNewMessagesReceived = usePreservedCallback((source, messages) => {\n        var _a, _b, _c, _d, _e;\n        const incomingMessages = messages.filter((it) => { var _a; return isThreadedMessage(it, parentMessageRef.current) && !isMyMessage(it, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId); });\n        if (incomingMessages.length > 0) {\n            switch (source) {\n                case CollectionEventSource.EVENT_MESSAGE_RECEIVED:\n                case CollectionEventSource.SYNC_MESSAGE_FILL: {\n                    if ((_b = (_a = internalOptions.current).shouldCountNewMessages) === null || _b === void 0 ? void 0 : _b.call(_a)) {\n                        updateNewMessages(incomingMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n                    }\n                    (_e = (_d = internalOptions.current).onMessagesReceived) === null || _e === void 0 ? void 0 : _e.call(_d, incomingMessages);\n                    break;\n                }\n            }\n        }\n    });\n    useAsyncEffect(() => __awaiter(void 0, void 0, void 0, function* () {\n        var _f, _g, _h, _j, _k;\n        const messages = yield ((_f = channelRef.current) === null || _f === void 0 ? void 0 : _f.getMessagesByMessageId((_g = parentMessageRef.current) === null || _g === void 0 ? void 0 : _g.messageId, {\n            prevResultSize: 1,\n            nextResultSize: 1,\n            isInclusive: true,\n            includeThreadInfo: true,\n            includeMetaArray: true,\n            includeReactions: (_h = internalOptions.current.isReactionEnabled) !== null && _h !== void 0 ? _h : false,\n        }));\n        const parentMessage = messages === null || messages === void 0 ? void 0 : messages.find((message) => {\n            return message.messageId === parentMessageRef.current.messageId;\n        });\n        if (parentMessage) {\n            parentMessageRef.current = parentMessage;\n            (_k = (_j = internalOptions.current).onParentMessageUpdated) === null || _k === void 0 ? void 0 : _k.call(_j, parentMessage);\n        }\n    }), [(_c = channelRef.current) === null || _c === void 0 ? void 0 : _c.url, internalOptions.current.isReactionEnabled]);\n    const init = usePreservedCallback((startingPoint) => __awaiter(void 0, void 0, void 0, function* () {\n        return new Promise((resolve) => {\n            var _a, _b, _c;\n            if (!channelRef.current || !channelRef.current.url) {\n                return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            }\n            if (!parentMessageRef.current) {\n                return (_b = logger === null || logger === void 0 ? void 0 : logger.error) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelThreadMessages] parent message is required');\n            }\n            if (collectionRef.current.instance)\n                collectionRef.current.instance.dispose();\n            markAsReadBySource();\n            updateNewMessages([], true, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n            const updateUnsentMessages = () => {\n                var _a, _b;\n                const { pendingMessages, failedMessages } = (_a = collectionRef.current.instance) !== null && _a !== void 0 ? _a : {};\n                let filteredMessages;\n                if (isNotEmptyArray(pendingMessages)) {\n                    filteredMessages = pendingMessages.filter((message) => isThreadedMessage(message, parentMessageRef.current));\n                }\n                if (isNotEmptyArray(failedMessages)) {\n                    filteredMessages = failedMessages.filter((message) => isThreadedMessage(message, parentMessageRef.current));\n                }\n                if (isNotEmptyArray(filteredMessages))\n                    updateMessages(filteredMessages, false, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId);\n            };\n            setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {\n                var _d, _e, _f, _g;\n                try {\n                    if (parentMessageRef.current) {\n                        const params = {\n                            prevResultSize: prevFetchSize,\n                            nextResultSize: nextFetchSize,\n                            isInclusive: true,\n                            includeReactions: (_d = internalOptions.current.isReactionEnabled) !== null && _d !== void 0 ? _d : false,\n                        };\n                        const { threadedMessages } = yield parentMessageRef.current.getThreadedMessagesByTimestamp(startingPoint, params);\n                        if (isNotEmptyArray(threadedMessages)) {\n                            const prevMessagesCount = threadedMessages.filter((message) => message.createdAt < startingPoint).length;\n                            const nextMessagesCount = threadedMessages.filter((message) => message.createdAt > startingPoint).length;\n                            updateHasPreviousMessages(prevMessagesCount >= prevFetchSize);\n                            updateHasNextMessages(nextMessagesCount >= nextFetchSize);\n                            updateMessages(threadedMessages, true, (_e = sdk.currentUser) === null || _e === void 0 ? void 0 : _e.userId);\n                        }\n                    }\n                    else {\n                        (_f = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _f === void 0 ? void 0 : _f.call(logger, '[useGroupChannelThreadMessages] parent message is required');\n                    }\n                    resolve();\n                }\n                catch (error) {\n                    (_g = logger === null || logger === void 0 ? void 0 : logger.error) === null || _g === void 0 ? void 0 : _g.call(logger, '[useGroupChannelThreadMessages] Initialize thread list failed.', error);\n                }\n            }));\n            const collectionInstance = channelRef.current.createMessageCollection({\n                prevResultLimit: prevFetchSize,\n                nextResultLimit: nextFetchSize,\n                startingPoint: startingPoint - 1,\n                filter: new MessageFilter({ replyType: ReplyType.ALL }),\n            });\n            collectionRef.current = { apiInitialized: false, initialized: false, instance: collectionInstance };\n            collectionInstance.setMessageCollectionHandler({\n                onMessagesAdded: (ctx, __, messages) => {\n                    var _a;\n                    const filteredMessages = messages.filter((message) => isThreadedMessage(message, parentMessageRef.current));\n                    if (isNotEmptyArray(filteredMessages)) {\n                        markAsReadBySource(ctx.source);\n                        updateNewMessagesReceived(ctx.source, filteredMessages);\n                        updateMessages(filteredMessages, false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                    }\n                },\n                onMessagesUpdated: (ctx, __, messages) => {\n                    var _a, _b, _c, _d, _e;\n                    const filteredMessages = messages.filter((message) => isThreadedMessage(message, parentMessageRef.current));\n                    const parentMessage = messages.find((message) => message.messageId === parentMessageRef.current.messageId);\n                    if (parentMessage) {\n                        parentMessageRef.current = parentMessage;\n                        (_b = (_a = internalOptions.current).onParentMessageUpdated) === null || _b === void 0 ? void 0 : _b.call(_a, parentMessage);\n                    }\n                    if (isNotEmptyArray(filteredMessages)) {\n                        markAsReadBySource(ctx.source);\n                        updateNewMessagesReceived(ctx.source, filteredMessages); // NOTE: admin message is not added via onMessagesAdded handler, not checked yet is this a bug.\n                        updateMessages(filteredMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n                        if (ctx.source === CollectionEventSource.EVENT_MESSAGE_UPDATED) {\n                            (_e = (_d = internalOptions.current).onMessagesUpdated) === null || _e === void 0 ? void 0 : _e.call(_d, filteredMessages);\n                        }\n                    }\n                },\n                onMessagesDeleted: (_, __, ___, messages) => {\n                    var _a, _b;\n                    const parentMessage = messages.find((message) => message.messageId === parentMessageRef.current.messageId);\n                    if (parentMessage) {\n                        (_b = (_a = internalOptions.current).onParentMessageDeleted) === null || _b === void 0 ? void 0 : _b.call(_a);\n                    }\n                    const filteredMessages = messages.filter((message) => isThreadedMessage(message, parentMessageRef.current));\n                    if (isNotEmptyArray(filteredMessages)) {\n                        const msgIds = filteredMessages.map((it) => it.messageId);\n                        const reqIds = filteredMessages.filter(isSendableMessage).map((it) => it.reqId);\n                        deleteMessages(msgIds, reqIds);\n                        deleteNewMessages(msgIds, reqIds);\n                    }\n                },\n                onChannelDeleted: (_, channelUrl) => {\n                    var _a, _b;\n                    (_b = (_a = internalOptions.current).onChannelDeleted) === null || _b === void 0 ? void 0 : _b.call(_a, channelUrl);\n                },\n                onChannelUpdated: (_, channel) => {\n                    var _a, _b;\n                    forceUpdate();\n                    (_b = (_a = internalOptions.current).onChannelUpdated) === null || _b === void 0 ? void 0 : _b.call(_a, channel);\n                },\n                onHugeGapDetected: () => {\n                    init(startingPoint);\n                },\n            });\n            collectionInstance\n                .initialize(MessageCollectionInitPolicy.CACHE_AND_REPLACE_BY_API)\n                .onCacheResult((err, messages) => {\n                var _a, _b, _c;\n                if (err) {\n                    sdk.isCacheEnabled && ((_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages/onCacheResult]', err));\n                }\n                else if (messages) {\n                    (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelThreadMessages/onCacheResult]', 'message length:', messages.length);\n                    const filteredMessages = messages.filter((message) => isThreadedMessage(message, parentMessageRef.current));\n                    if (isNotEmptyArray(filteredMessages)) {\n                        updateMessages(filteredMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n                        updateUnsentMessages();\n                    }\n                }\n            })\n                .onApiResult((err, messages) => {\n                var _a, _b, _c;\n                if (err) {\n                    (_a = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages/onApiResult]', err);\n                }\n                else if (messages) {\n                    (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelThreadMessages/onApiResult]', 'message length:', messages.length);\n                    const filteredMessages = messages.filter((message) => isThreadedMessage(message, parentMessageRef.current));\n                    if (isNotEmptyArray(filteredMessages)) {\n                        updateMessages(filteredMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n                        if (sdk.isCacheEnabled)\n                            updateUnsentMessages();\n                    }\n                }\n                collectionRef.current.initialized = true;\n                collectionRef.current.apiInitialized = true;\n            });\n        });\n    }));\n    useGroupChannelHandler(sdk, {\n        onUserBanned(eventChannel, bannedUser) {\n            var _a, _b, _c;\n            if (eventChannel.isGroupChannel() && !isDifferentChannel(eventChannel, channelRef.current)) {\n                if (bannedUser.userId === ((_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId)) {\n                    (_c = (_b = internalOptions.current).onCurrentUserBanned) === null || _c === void 0 ? void 0 : _c.call(_b);\n                }\n                else {\n                    forceUpdate();\n                }\n            }\n        },\n    });\n    useLayoutEffect(() => {\n        const timeout = setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {\n            if (sdk.currentUser && channelRef.current) {\n                updateInitialized(false);\n                updateLoading(true);\n                yield init(startingPoint.current);\n                updateLoading(false);\n                updateInitialized(true);\n            }\n        }));\n        return () => clearTimeout(timeout);\n    }, [sdk, (_d = sdk.currentUser) === null || _d === void 0 ? void 0 : _d.userId, (_e = channelRef.current) === null || _e === void 0 ? void 0 : _e.url, startingPoint.current]);\n    useEffect(() => {\n        return () => {\n            if (collectionRef.current.instance)\n                collectionRef.current.instance.dispose();\n        };\n    }, []);\n    const refresh = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        if (sdk.currentUser && channelRef.current) {\n            updateRefreshing(true);\n            yield init(startingPoint.current);\n            updateRefreshing(false);\n        }\n    }));\n    const loadPrevious = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        var _l, _m, _o, _p;\n        if (!channelRef.current || !channelRef.current.url || !parentMessageRef.current) {\n            (_l = logger === null || logger === void 0 ? void 0 : logger.error) === null || _l === void 0 ? void 0 : _l.call(logger, '[useGroupChannelThreadMessages] channel or parent message is required');\n            return;\n        }\n        if (hasPreviousMessages && !isFetching.current.prev) {\n            try {\n                isFetching.current.prev = true;\n                const params = {\n                    prevResultSize: prevFetchSize,\n                    nextResultSize: 0,\n                    isInclusive: false,\n                    includeReactions: (_m = internalOptions.current.isReactionEnabled) !== null && _m !== void 0 ? _m : false,\n                };\n                const { threadedMessages } = yield parentMessageRef.current.getThreadedMessagesByTimestamp(oldestMessageTimeStamp, params);\n                if (isNotEmptyArray(threadedMessages)) {\n                    updateHasPreviousMessages(threadedMessages.length >= prevFetchSize);\n                    updateMessages(threadedMessages, false, (_o = sdk.currentUser) === null || _o === void 0 ? void 0 : _o.userId);\n                }\n            }\n            catch (error) {\n                (_p = logger === null || logger === void 0 ? void 0 : logger.error) === null || _p === void 0 ? void 0 : _p.call(logger, '[useGroupChannelThreadMessages] loadPrevious thread list failed.', error);\n            }\n            finally {\n                isFetching.current.prev = false;\n            }\n        }\n    }));\n    const hasPrevious = usePreservedCallback(() => {\n        return hasPreviousMessages;\n    });\n    const loadNext = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        var _q, _r, _s, _t;\n        if (!channelRef.current || !channelRef.current.url || !parentMessageRef.current) {\n            (_q = logger === null || logger === void 0 ? void 0 : logger.error) === null || _q === void 0 ? void 0 : _q.call(logger, '[useGroupChannelThreadMessages] channel or parent message is required');\n            return;\n        }\n        if (hasNextMessages && !isFetching.current.next) {\n            try {\n                isFetching.current.prev = true;\n                const params = {\n                    prevResultSize: 0,\n                    nextResultSize: nextFetchSize,\n                    isInclusive: false,\n                    includeReactions: (_r = internalOptions.current.isReactionEnabled) !== null && _r !== void 0 ? _r : false,\n                };\n                const { threadedMessages } = yield parentMessageRef.current.getThreadedMessagesByTimestamp(latestMessageTimeStamp, params);\n                updateHasNextMessages(threadedMessages.length >= nextFetchSize);\n                updateMessages(threadedMessages, false, (_s = sdk.currentUser) === null || _s === void 0 ? void 0 : _s.userId);\n            }\n            catch (error) {\n                (_t = logger === null || logger === void 0 ? void 0 : logger.error) === null || _t === void 0 ? void 0 : _t.call(logger, '[useGroupChannelThreadMessages] loadNext thread list failed.', error);\n            }\n            finally {\n                isFetching.current.next = false;\n            }\n        }\n    }));\n    const hasNext = usePreservedCallback(() => {\n        return hasNextMessages;\n    });\n    const sendUserMessage = usePreservedCallback((params, onPending) => {\n        var _a;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve, reject) => {\n            channelRef.current\n                .sendUserMessage(params)\n                .onPending((pendingMessage) => {\n                var _a;\n                if (pendingMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n            })\n                .onSucceeded((sentMessage) => {\n                var _a;\n                if (sentMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                resolve(sentMessage);\n            })\n                .onFailed((err, failedMessage) => {\n                var _a;\n                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                reject(err);\n            });\n        });\n    });\n    const sendFileMessage = usePreservedCallback((params, onPending) => {\n        var _a;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve, reject) => {\n            channelRef.current\n                .sendFileMessage(params)\n                .onPending((pendingMessage) => {\n                var _a;\n                if (pendingMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n            })\n                .onSucceeded((sentMessage) => {\n                var _a;\n                if (sentMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                resolve(sentMessage);\n            })\n                .onFailed((err, failedMessage) => {\n                var _a;\n                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                reject(err);\n            });\n        });\n    });\n    const sendFileMessages = usePreservedCallback((paramsList, onPending) => __awaiter(void 0, void 0, void 0, function* () {\n        var _u;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_u = logger === null || logger === void 0 ? void 0 : logger.error) === null || _u === void 0 ? void 0 : _u.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve) => {\n            const messages = [];\n            channelRef.current\n                .sendFileMessages(paramsList)\n                .onPending((pendingMessage) => {\n                var _a;\n                if (pendingMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n            })\n                .onSucceeded((sentMessage) => {\n                var _a;\n                if (sentMessage.isFileMessage() && sentMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                    messages.push(sentMessage);\n                }\n                if (messages.length === paramsList.length)\n                    resolve(messages);\n            })\n                .onFailed((_, failedMessage) => {\n                var _a;\n                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                    messages.push(failedMessage);\n                }\n                else {\n                    // NOTE: Since failedMessage is nullable by type, to resolve the promise, handle pushing null even when there is no failedMessage.\n                    messages.push(null);\n                }\n                if (messages.length === paramsList.length)\n                    resolve(messages);\n            });\n        });\n    }));\n    const sendMultipleFilesMessage = usePreservedCallback((params, onPending) => {\n        var _a;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve, reject) => {\n            channelRef.current\n                .sendMultipleFilesMessage(params)\n                .onPending((pendingMessage) => {\n                var _a;\n                if (pendingMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n            })\n                .onFileUploaded(() => {\n                // Just re-render to use updated message.messageParams\n                forceUpdate();\n            })\n                .onSucceeded((sentMessage) => {\n                var _a;\n                if (sentMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                resolve(sentMessage);\n            })\n                .onFailed((err, failedMessage) => {\n                var _a;\n                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                reject(err);\n            });\n        });\n    });\n    const updateUserMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {\n        var _v, _w;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_v = logger === null || logger === void 0 ? void 0 : logger.error) === null || _v === void 0 ? void 0 : _v.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        const updatedMessage = yield channelRef.current.updateUserMessage(messageId, params);\n        if (updatedMessage.channelUrl === channelRef.current.url &&\n            isThreadedMessage(updatedMessage, parentMessageRef.current)) {\n            updateMessages([updatedMessage], false, (_w = sdk.currentUser) === null || _w === void 0 ? void 0 : _w.userId);\n        }\n        return updatedMessage;\n    }));\n    const updateFileMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {\n        var _x, _y;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_x = logger === null || logger === void 0 ? void 0 : logger.error) === null || _x === void 0 ? void 0 : _x.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        const updatedMessage = yield channelRef.current.updateFileMessage(messageId, params);\n        if (updatedMessage.channelUrl === channelRef.current.url &&\n            isThreadedMessage(updatedMessage, parentMessageRef.current)) {\n            updateMessages([updatedMessage], false, (_y = sdk.currentUser) === null || _y === void 0 ? void 0 : _y.userId);\n        }\n        return updatedMessage;\n    }));\n    const resendMessage = usePreservedCallback((failedMessage) => __awaiter(void 0, void 0, void 0, function* () {\n        var _z;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_z = logger === null || logger === void 0 ? void 0 : logger.error) === null || _z === void 0 ? void 0 : _z.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve, reject) => {\n            let handler = undefined;\n            if (failedMessage.isUserMessage())\n                handler = channelRef.current.resendMessage(failedMessage);\n            if (failedMessage.isFileMessage())\n                handler = channelRef.current.resendMessage(failedMessage);\n            if (failedMessage.isMultipleFilesMessage())\n                handler = channelRef.current.resendMessage(failedMessage);\n            if (handler) {\n                if ('onPending' in handler) {\n                    handler.onPending((message) => {\n                        var _a;\n                        if (message.channelUrl === channelRef.current.url) {\n                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                        }\n                    });\n                }\n                if ('onFileUploaded' in handler) {\n                    handler.onFileUploaded(() => {\n                        // Just re-render to use updated message.messageParams\n                        forceUpdate();\n                    });\n                }\n                if ('onSucceeded' in handler) {\n                    handler.onSucceeded((message) => {\n                        var _a;\n                        if (message.channelUrl === channelRef.current.url) {\n                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                        }\n                        resolve(message);\n                    });\n                }\n                if ('onFailed' in handler) {\n                    handler.onFailed((err, message) => {\n                        var _a;\n                        if (message && message.channelUrl === channelRef.current.url) {\n                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                        }\n                        reject(err);\n                    });\n                }\n            }\n        });\n    }));\n    const deleteMessage = usePreservedCallback((message) => __awaiter(void 0, void 0, void 0, function* () {\n        var _0, _1;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_0 = logger === null || logger === void 0 ? void 0 : logger.error) === null || _0 === void 0 ? void 0 : _0.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        if (message.sendingStatus === 'succeeded') {\n            if (message.isUserMessage())\n                yield channelRef.current.deleteMessage(message);\n            if (message.isFileMessage())\n                yield channelRef.current.deleteMessage(message);\n            if (message.isMultipleFilesMessage())\n                yield channelRef.current.deleteMessage(message);\n        }\n        else {\n            try {\n                yield ((_1 = collectionRef.current.instance) === null || _1 === void 0 ? void 0 : _1.removeFailedMessage(message.reqId));\n            }\n            finally {\n                deleteMessages([message.messageId], [message.reqId]);\n            }\n        }\n    }));\n    const resetNewMessages = usePreservedCallback(() => {\n        var _a;\n        updateNewMessages([], true, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n    });\n    const resetWithStartingPoint = usePreservedCallback((startingPoint) => __awaiter(void 0, void 0, void 0, function* () {\n        var _2;\n        if (sdk.currentUser && channelRef.current) {\n            updateLoading(true);\n            updateMessages([], true, (_2 = sdk.currentUser) === null || _2 === void 0 ? void 0 : _2.userId);\n            yield init(startingPoint);\n            updateLoading(false);\n        }\n    }));\n    return {\n        /**\n         * Initialized state, only available on first render\n         * */\n        initialized,\n        /**\n         * Loading state, status is changes on first mount or when the resetWithStartingPoint is called.\n         * */\n        loading,\n        /**\n         * Refreshing state, status is changes when the refresh is called.\n         * */\n        refreshing,\n        /**\n         * Get messages, this state is for render\n         * For example, if a user receives a new messages while searching for an old message\n         * for this case, new messages will be included here.\n         * */\n        messages,\n        /**\n         * If the `shouldCountNewMessages()` is true, only then push in the newMessages state.\n         * (Return false for the `shouldCountNewMessages()` if the message scroll is the most recent; otherwise, return true.)\n         *\n         * A new message means a message that meets the below conditions\n         * - Not admin message\n         * - Not updated message\n         * - Not current user's message\n         * */\n        newMessages,\n        /**\n         * Reset new message list\n         * @return {void}\n         * */\n        resetNewMessages,\n        /**\n         * Reset message list and create a new collection for latest messages\n         * @return {Promise<void>}\n         * */\n        refresh,\n        /**\n         * Load previous messages to state\n         * @return {Promise<void>}\n         * */\n        loadPrevious,\n        /**\n         * Check if there are more previous messages to fetch\n         * @return {boolean}\n         * */\n        hasPrevious,\n        /**\n         * Load next messages to state\n         * @return {Promise<void>}\n         * */\n        loadNext,\n        /**\n         * Check if there are more next messages to fetch\n         * @return {boolean}\n         * */\n        hasNext,\n        /**\n         * Send user message\n         * @param {UserMessageCreateParams} params user message create params\n         * @param {function} [onPending] pending message callback\n         * @return {Promise<UserMessage>} succeeded message\n         * */\n        sendUserMessage,\n        /**\n         * Send file message\n         * @param {FileMessageCreateParams} params file message create params\n         * @param {function} [onPending] pending message callback\n         * @return {Promise<FileMessage>} succeeded message\n         * */\n        sendFileMessage,\n        /**\n         * Send file messages\n         * @param {FileMessageCreateParams[]} paramList file message create params\n         * @param {function} [onPending] pending message callback for each message request\n         * @return {Promise<FileMessage[]>} succeeded or failed message\n         * */\n        sendFileMessages,\n        /**\n         * Send multiple files message\n         * @param {MultipleFilesMessageCreateParams} params multiple files message create params\n         * @param {function} [onPending] pending message callback\n         * @return {Promise<MultipleFilesMessage>} succeeded message\n         * */\n        sendMultipleFilesMessage,\n        /**\n         * Update user message\n         * @param {number} messageId\n         * @param {UserMessageUpdateParams} params user message update params\n         * @return {Promise<UserMessage>}\n         * */\n        updateUserMessage,\n        /**\n         * Update file message\n         * @param {number} messageId\n         * @param {FileMessageUpdateParams} params file message update params\n         * @return {Promise<FileMessage>}\n         * */\n        updateFileMessage,\n        /**\n         * Resend failed message\n         * @template {UserMessage | FileMessage | MultipleFilesMessage} T\n         * @param {T} failedMessage message to resend\n         * @return {Promise<T>}\n         * */\n        resendMessage,\n        /**\n         * Delete a message\n         * @template {UserMessage | FileMessage | MultipleFilesMessage} T\n         * @param {T} message succeeded or failed message\n         * @return {Promise<void>}\n         * */\n        deleteMessage,\n        /**\n         * Reset message list and create a new collection with starting point\n         * @param {number} startingPoint\n         * @param {function} callback\n         * @return {void}\n         * */\n        resetWithStartingPoint,\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}