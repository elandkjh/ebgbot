{"ast":null,"code":"import { useState, useEffect, useCallback, useRef } from 'react';\nimport { u as useVoiceRecorderContext } from '../chunks/bundle-CXdo2kR_.js';\nimport { useSendbirdStateContext } from '../useSendbirdStateContext.js';\nimport { n as noop } from '../chunks/bundle-BgwzpLeQ.js';\nimport '../chunks/bundle-BQi9-O76.js';\nimport '../chunks/bundle-DxTN4_0p.js';\nimport '@sendbird/chat/groupChannel';\nimport '../utils/message/getOutgoingMessageState.js';\nimport '../chunks/bundle-CNWAfTVw.js';\nimport '../chunks/bundle-CA85nVxp.js';\nimport 'react-dom';\nimport '../chunks/bundle-cQZ3UZoG.js';\nimport '../chunks/bundle-Bwk5KPwK.js';\nimport '../chunks/bundle-bdDHjHH6.js';\nimport '../chunks/bundle-f-SpnOx2.js';\nimport '../ui/IconButton.js';\nimport '../ui/Button.js';\nimport '../chunks/bundle-DhKQeIfP.js';\nimport '../ui/Icon.js';\nimport '@sendbird/uikit-tools';\nimport '../withSendbird.js';\nimport 'css-vars-ponyfill';\nimport '@sendbird/chat';\nimport '../chunks/bundle-etuaqevl.js';\nimport '@sendbird/chat/openChannel';\nimport '../chunks/bundle-DDeWOERD.js';\nimport '../chunks/bundle-DCMGp6rH.js';\nimport '../chunks/bundle-CwKZj-B6.js';\nimport '../ui/SortByRow.js';\n\n// export interface UseVoiceRecorderProps extends VoiceRecorderEventHandler {\n//   /**\n//    * onRecordingStarted\n//    * onRecordingEnded\n//    */\n// }\n/* eslint-disable no-redeclare */\nvar VoiceRecorderStatus = {\n  PREPARING: 'PREPARING',\n  READY_TO_RECORD: 'READY_TO_RECORD',\n  RECORDING: 'RECORDING',\n  COMPLETED: 'COMPLETED'\n};\nvar useVoiceRecorder = function (_a) {\n  var _b = _a.onRecordingStarted,\n    onRecordingStarted = _b === void 0 ? noop : _b,\n    _c = _a.onRecordingEnded,\n    onRecordingEnded = _c === void 0 ? noop : _c;\n  var config = useSendbirdStateContext().config;\n  var voiceRecord = config.voiceRecord;\n  var maxRecordingTime = voiceRecord.maxRecordingTime;\n  var voiceRecorder = useVoiceRecorderContext();\n  var isRecordable = voiceRecorder.isRecordable;\n  var _d = useState(null),\n    recordedFile = _d[0],\n    setRecordedFile = _d[1];\n  var _e = useState(VoiceRecorderStatus.PREPARING),\n    recordingStatus = _e[0],\n    setRecordingStatus = _e[1];\n  useEffect(function () {\n    if (isRecordable && recordingStatus === VoiceRecorderStatus.PREPARING) {\n      setRecordingStatus(VoiceRecorderStatus.READY_TO_RECORD);\n    }\n  }, [isRecordable]);\n  var start = useCallback(function () {\n    voiceRecorder === null || voiceRecorder === void 0 ? void 0 : voiceRecorder.start({\n      onRecordingStarted: function () {\n        setRecordingStatus(VoiceRecorderStatus.RECORDING);\n        onRecordingStarted();\n        startTimer();\n      },\n      onRecordingEnded: function (audioFile) {\n        setRecordingStatus(VoiceRecorderStatus.COMPLETED);\n        onRecordingEnded(audioFile);\n        setRecordedFile(audioFile);\n        stopTimer();\n      }\n    });\n  }, [onRecordingStarted, onRecordingEnded]);\n  var stop = useCallback(function () {\n    voiceRecorder === null || voiceRecorder === void 0 ? void 0 : voiceRecorder.stop();\n    stopTimer();\n  }, [voiceRecorder]);\n  var cancel = useCallback(function () {\n    stop();\n    setRecordedFile(null);\n  }, [voiceRecorder]);\n  // Timer\n  var _f = useState(0),\n    recordingTime = _f[0],\n    setRecordingTime = _f[1];\n  var timer = useRef(null);\n  function startTimer() {\n    stopTimer();\n    setRecordingTime(0);\n    timer.current = setInterval(function () {\n      setRecordingTime(function (prevTime) {\n        var newTime = prevTime + 100;\n        if (newTime > maxRecordingTime) {\n          stopTimer();\n        }\n        return newTime;\n      });\n    }, 100);\n  }\n  function stopTimer() {\n    if (timer.current) {\n      clearInterval(timer.current);\n      timer.current = null;\n    }\n  }\n  useEffect(function () {\n    if (recordingTime > maxRecordingTime) {\n      stop();\n    }\n  }, [recordingTime, maxRecordingTime, stop]);\n  return {\n    start: start,\n    stop: stop,\n    cancel: cancel,\n    recordingStatus: recordingStatus,\n    recordingTime: recordingTime,\n    recordedFile: recordedFile,\n    recordingLimit: maxRecordingTime\n  };\n};\nexport { VoiceRecorderStatus, useVoiceRecorder };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import { useState, useEffect, useCallback, useRef } from 'react';\nimport { u as useVoiceRecorderContext } from '../chunks/bundle-CXdo2kR_.js';\nimport { useSendbirdStateContext } from '../useSendbirdStateContext.js';\nimport { n as noop } from '../chunks/bundle-BgwzpLeQ.js';\nimport '../chunks/bundle-BQi9-O76.js';\nimport '../chunks/bundle-DxTN4_0p.js';\nimport '@sendbird/chat/groupChannel';\nimport '../utils/message/getOutgoingMessageState.js';\nimport '../chunks/bundle-CNWAfTVw.js';\nimport '../chunks/bundle-CA85nVxp.js';\nimport 'react-dom';\nimport '../chunks/bundle-cQZ3UZoG.js';\nimport '../chunks/bundle-Bwk5KPwK.js';\nimport '../chunks/bundle-bdDHjHH6.js';\nimport '../chunks/bundle-f-SpnOx2.js';\nimport '../ui/IconButton.js';\nimport '../ui/Button.js';\nimport '../chunks/bundle-DhKQeIfP.js';\nimport '../ui/Icon.js';\nimport '@sendbird/uikit-tools';\nimport '../withSendbird.js';\nimport 'css-vars-ponyfill';\nimport '@sendbird/chat';\nimport '../chunks/bundle-etuaqevl.js';\nimport '@sendbird/chat/openChannel';\nimport '../chunks/bundle-DDeWOERD.js';\nimport '../chunks/bundle-DCMGp6rH.js';\nimport '../chunks/bundle-CwKZj-B6.js';\nimport '../ui/SortByRow.js';\n\n// export interface UseVoiceRecorderProps extends VoiceRecorderEventHandler {\n//   /**\n//    * onRecordingStarted\n//    * onRecordingEnded\n//    */\n// }\n/* eslint-disable no-redeclare */\nvar VoiceRecorderStatus = {\n    PREPARING: 'PREPARING',\n    READY_TO_RECORD: 'READY_TO_RECORD',\n    RECORDING: 'RECORDING',\n    COMPLETED: 'COMPLETED',\n};\nvar useVoiceRecorder = function (_a) {\n    var _b = _a.onRecordingStarted, onRecordingStarted = _b === void 0 ? noop : _b, _c = _a.onRecordingEnded, onRecordingEnded = _c === void 0 ? noop : _c;\n    var config = useSendbirdStateContext().config;\n    var voiceRecord = config.voiceRecord;\n    var maxRecordingTime = voiceRecord.maxRecordingTime;\n    var voiceRecorder = useVoiceRecorderContext();\n    var isRecordable = voiceRecorder.isRecordable;\n    var _d = useState(null), recordedFile = _d[0], setRecordedFile = _d[1];\n    var _e = useState(VoiceRecorderStatus.PREPARING), recordingStatus = _e[0], setRecordingStatus = _e[1];\n    useEffect(function () {\n        if (isRecordable && recordingStatus === VoiceRecorderStatus.PREPARING) {\n            setRecordingStatus(VoiceRecorderStatus.READY_TO_RECORD);\n        }\n    }, [isRecordable]);\n    var start = useCallback(function () {\n        voiceRecorder === null || voiceRecorder === void 0 ? void 0 : voiceRecorder.start({\n            onRecordingStarted: function () {\n                setRecordingStatus(VoiceRecorderStatus.RECORDING);\n                onRecordingStarted();\n                startTimer();\n            },\n            onRecordingEnded: function (audioFile) {\n                setRecordingStatus(VoiceRecorderStatus.COMPLETED);\n                onRecordingEnded(audioFile);\n                setRecordedFile(audioFile);\n                stopTimer();\n            },\n        });\n    }, [onRecordingStarted, onRecordingEnded]);\n    var stop = useCallback(function () {\n        voiceRecorder === null || voiceRecorder === void 0 ? void 0 : voiceRecorder.stop();\n        stopTimer();\n    }, [voiceRecorder]);\n    var cancel = useCallback(function () {\n        stop();\n        setRecordedFile(null);\n    }, [voiceRecorder]);\n    // Timer\n    var _f = useState(0), recordingTime = _f[0], setRecordingTime = _f[1];\n    var timer = useRef(null);\n    function startTimer() {\n        stopTimer();\n        setRecordingTime(0);\n        timer.current = setInterval(function () {\n            setRecordingTime(function (prevTime) {\n                var newTime = prevTime + 100;\n                if (newTime > maxRecordingTime) {\n                    stopTimer();\n                }\n                return newTime;\n            });\n        }, 100);\n    }\n    function stopTimer() {\n        if (timer.current) {\n            clearInterval(timer.current);\n            timer.current = null;\n        }\n    }\n    useEffect(function () {\n        if (recordingTime > maxRecordingTime) {\n            stop();\n        }\n    }, [recordingTime, maxRecordingTime, stop]);\n    return ({\n        start: start,\n        stop: stop,\n        cancel: cancel,\n        recordingStatus: recordingStatus,\n        recordingTime: recordingTime,\n        recordedFile: recordedFile,\n        recordingLimit: maxRecordingTime,\n    });\n};\n\nexport { VoiceRecorderStatus, useVoiceRecorder };\n//# sourceMappingURL=useVoiceRecorder.js.map\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module"}