{"ast":null,"code":"import { _ as __assign, c as __spreadArray, a as __awaiter, b as __generator } from './bundle-BQi9-O76.js';\nimport React__default, { useEffect, useCallback, useReducer, useState, useMemo, useContext } from 'react';\nimport { GroupChannelHandler, GroupChannelListOrder } from '@sendbird/chat/groupChannel';\nimport { p as pubSubTopics } from './bundle-b6TpX_JP.js';\nimport { u as uuidv4 } from './bundle-etuaqevl.js';\nimport { n as noop } from './bundle-BgwzpLeQ.js';\nimport { D as DELIVERY_RECEIPT$1 } from './bundle-DCMGp6rH.js';\nimport { U as UserProfileProvider } from './bundle-BrTJ5Zbd.js';\nimport { useSendbirdStateContext } from '../useSendbirdStateContext.js';\nimport { K, $ as filterChannelListParams, a0 as getChannelsWithUpsertedChannel, a1 as S, a2 as isChannelJustCreated } from './bundle-DxTN4_0p.js';\nimport { u as useReconnectOnIdle } from './bundle-H8J7tAed.js';\nvar RESET_CHANNEL_LIST = 'RESET_CHANNEL_LIST';\nvar CREATE_CHANNEL = 'CREATE_CHANNEL';\nvar LEAVE_CHANNEL_SUCCESS = 'LEAVE_CHANNEL_SUCCESS';\nvar SET_CURRENT_CHANNEL = 'SET_CURRENT_CHANNEL';\nvar FETCH_CHANNELS_START = 'FETCH_CHANNELS_START';\nvar FETCH_CHANNELS_SUCCESS = 'FETCH_CHANNELS_SUCCESS';\nvar FETCH_CHANNELS_FAILURE = 'FETCH_CHANNELS_FAILURE';\nvar INIT_CHANNELS_START = 'INIT_CHANNELS_START';\nvar INIT_CHANNELS_SUCCESS = 'INIT_CHANNELS_SUCCESS';\nvar REFRESH_CHANNELS_SUCCESS = 'REFRESH_CHANNELS_SUCCESS';\nvar INIT_CHANNELS_FAILURE = 'INIT_CHANNELS_FAILURE';\nvar ON_USER_JOINED = 'ON_USER_JOINED';\nvar ON_CHANNEL_DELETED = 'ON_CHANNEL_DELETED';\nvar ON_LAST_MESSAGE_UPDATED = 'ON_LAST_MESSAGE_UPDATED';\nvar ON_USER_LEFT = 'ON_USER_LEFT';\nvar ON_CHANNEL_CHANGED = 'ON_CHANNEL_CHANGED';\nvar ON_CHANNEL_ARCHIVED = 'ON_CHANNEL_ARCHIVED';\nvar ON_CHANNEL_FROZEN = 'ON_CHANNEL_FROZEN';\nvar ON_CHANNEL_UNFROZEN = 'ON_CHANNEL_UNFROZEN';\nvar ON_READ_RECEIPT_UPDATED = 'ON_READ_RECEIPT_UPDATED';\nvar ON_DELIVERY_RECEIPT_UPDATED = 'ON_DELIVERY_RECEIPT_UPDATED';\nvar CHANNEL_LIST_PARAMS_UPDATED = 'CHANNEL_LIST_PARAMS_UPDATED';\nvar DELIVERY_RECEIPT = 'delivery_receipt';\nvar createEventHandler = function (_a) {\n  var sdk = _a.sdk,\n    sdkChannelHandlerId = _a.sdkChannelHandlerId,\n    channelListDispatcher = _a.channelListDispatcher,\n    logger = _a.logger;\n  var ChannelHandler = new GroupChannelHandler({\n    onChannelChanged: function (channel) {\n      if (channel.isGroupChannel()) {\n        logger.info('ChannelList: onChannelChanged', channel);\n        channelListDispatcher({\n          type: ON_CHANNEL_CHANGED,\n          payload: channel\n        });\n      }\n    },\n    onChannelDeleted: function (channelUrl) {\n      logger.info('ChannelList: onChannelDeleted', channelUrl);\n      channelListDispatcher({\n        type: ON_CHANNEL_DELETED,\n        payload: channelUrl\n      });\n    },\n    onUserJoined: function (channel) {\n      logger.info('ChannelList: onUserJoined', channel);\n      channelListDispatcher({\n        type: ON_USER_JOINED,\n        payload: channel\n      });\n    },\n    onUserBanned: function (channel, user) {\n      var _a;\n      if (channel.isGroupChannel()) {\n        logger.info('Channel: onUserBanned', channel);\n        var isMe = user.userId === ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        channelListDispatcher({\n          type: ON_USER_LEFT,\n          payload: {\n            channel: channel,\n            isMe: isMe\n          }\n        });\n      }\n    },\n    onUserLeft: function (channel, user) {\n      var _a;\n      logger.info('ChannelList: onUserLeft', channel);\n      var isMe = user.userId === ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n      channelListDispatcher({\n        type: ON_USER_LEFT,\n        payload: {\n          channel: channel,\n          isMe: isMe\n        }\n      });\n    },\n    onUnreadMemberStatusUpdated: function (channel) {\n      logger.info('ChannelList: onUnreadMemberStatusUpdated', channel);\n      channelListDispatcher({\n        type: ON_READ_RECEIPT_UPDATED,\n        payload: channel\n      });\n    },\n    onUndeliveredMemberStatusUpdated: function (channel) {\n      logger.info('ChannelList: onUndeliveredMemberStatusUpdated', channel);\n      if (channel.lastMessage) {\n        channelListDispatcher({\n          type: ON_DELIVERY_RECEIPT_UPDATED,\n          payload: channel\n        });\n      }\n    },\n    onMessageUpdated: function (channel, message) {\n      var _a;\n      if (channel.isGroupChannel() && ((_a = channel.lastMessage) === null || _a === void 0 ? void 0 : _a.isEqual(message))) {\n        logger.info('ChannelList: onMessageUpdated', channel);\n        channelListDispatcher({\n          type: ON_LAST_MESSAGE_UPDATED,\n          payload: channel\n        });\n      }\n    },\n    onChannelHidden: function (channel) {\n      logger.info('ChannelList: onChannelHidden', channel);\n      channelListDispatcher({\n        type: ON_CHANNEL_ARCHIVED,\n        payload: channel\n      });\n    },\n    onChannelFrozen: function (channel) {\n      if (channel.isGroupChannel()) {\n        logger.info('ChannelList: onChannelFrozen', channel);\n        channelListDispatcher({\n          type: ON_CHANNEL_FROZEN,\n          payload: channel\n        });\n      }\n    },\n    onChannelUnfrozen: function (channel) {\n      if (channel.isGroupChannel()) {\n        logger.info('ChannelList: onChannelUnfrozen', channel);\n        channelListDispatcher({\n          type: ON_CHANNEL_UNFROZEN,\n          payload: channel\n        });\n      }\n    }\n  });\n  logger.info('ChannelList: Added channelHandler');\n  sdk.groupChannel.addGroupChannelHandler(sdkChannelHandlerId, ChannelHandler);\n};\nvar createChannelListQuery = function (_a) {\n  var sdk = _a.sdk,\n    _b = _a.userFilledChannelListQuery,\n    userFilledChannelListQuery = _b === void 0 ? {} : _b;\n  var params = {\n    includeEmpty: false,\n    limit: 20,\n    // The value of pagination limit could be set up to 100.\n    order: GroupChannelListOrder.LATEST_LAST_MESSAGE\n  };\n  if (userFilledChannelListQuery) {\n    Object.keys(userFilledChannelListQuery).forEach(function (key) {\n      // @ts-ignore\n      params[key] = userFilledChannelListQuery[key];\n    });\n  }\n  return sdk.groupChannel.createMyGroupChannelListQuery(params);\n};\nfunction setupChannelList(_a) {\n  var _b, _c, _d, _e;\n  var sdk = _a.sdk,\n    sdkChannelHandlerId = _a.sdkChannelHandlerId,\n    channelListDispatcher = _a.channelListDispatcher,\n    setChannelSource = _a.setChannelSource,\n    onChannelSelect = _a.onChannelSelect,\n    userFilledChannelListQuery = _a.userFilledChannelListQuery,\n    logger = _a.logger,\n    sortChannelList = _a.sortChannelList,\n    disableAutoSelect = _a.disableAutoSelect,\n    markAsDeliveredScheduler = _a.markAsDeliveredScheduler,\n    disableMarkAsDelivered = _a.disableMarkAsDelivered;\n  if (sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) {\n    createEventHandler({\n      sdk: sdk,\n      channelListDispatcher: channelListDispatcher,\n      sdkChannelHandlerId: sdkChannelHandlerId,\n      logger: logger\n    });\n  } else {\n    logger.warning('ChannelList - createEventHandler: sdk or sdk.ChannelHandler does not exist', sdk);\n  }\n  logger.info('ChannelList - creating query', {\n    userFilledChannelListQuery: userFilledChannelListQuery\n  });\n  var channelListQuery = createChannelListQuery({\n    sdk: sdk,\n    userFilledChannelListQuery: userFilledChannelListQuery\n  });\n  logger.info('ChannelList - created query', channelListQuery);\n  setChannelSource(channelListQuery);\n  channelListDispatcher({\n    type: INIT_CHANNELS_START,\n    payload: {\n      currentUserId: (_c = (_b = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId) !== null && _c !== void 0 ? _c : ''\n    }\n  });\n  if (userFilledChannelListQuery) {\n    logger.info('ChannelList - setting up channelListQuery', channelListQuery);\n    channelListDispatcher({\n      type: CHANNEL_LIST_PARAMS_UPDATED,\n      payload: {\n        channelListQuery: channelListQuery,\n        currentUserId: (_e = (_d = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _d === void 0 ? void 0 : _d.userId) !== null && _e !== void 0 ? _e : ''\n      }\n    });\n  }\n  logger.info('ChannelList - fetching channels');\n  if (channelListQuery.hasNext) {\n    channelListQuery.next().then(function (channelList) {\n      var _a, _b;\n      logger.info('ChannelList - fetched channels', channelList);\n      // select first channel\n      logger.info('ChannelList - highlight channel', channelList[0]);\n      var sortedChannelList = channelList;\n      if (sortChannelList && typeof sortChannelList === 'function') {\n        sortedChannelList = sortChannelList(channelList);\n        logger.info('ChannelList - channel list sorted', sortedChannelList);\n      }\n      if (!disableAutoSelect) {\n        onChannelSelect === null || onChannelSelect === void 0 ? void 0 : onChannelSelect(sortedChannelList[0]);\n      }\n      channelListDispatcher({\n        type: INIT_CHANNELS_SUCCESS,\n        payload: {\n          channelList: sortedChannelList,\n          disableAutoSelect: disableAutoSelect\n        }\n      });\n      var canSetMarkAsDelivered = (_b = (_a = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) === null || _a === void 0 ? void 0 : _a.premiumFeatureList) === null || _b === void 0 ? void 0 : _b.find(function (feature) {\n        return feature === DELIVERY_RECEIPT;\n      });\n      if (canSetMarkAsDelivered && !disableMarkAsDelivered) {\n        sortedChannelList.forEach(function (channel) {\n          markAsDeliveredScheduler.push(channel);\n        });\n      }\n    }).catch(function (err) {\n      if (err) {\n        logger.error('ChannelList - couldnt fetch channels', err);\n        channelListDispatcher({\n          type: INIT_CHANNELS_FAILURE\n        });\n      }\n    });\n  } else {\n    logger.info('ChannelList - there are no more channels');\n  }\n}\nvar pubSubHandleRemover = function (subscriber) {\n  subscriber.forEach(function (s) {\n    try {\n      s.remove();\n    } catch (_a) {\n      //\n    }\n  });\n};\nvar pubSubHandler = function (pubSub, channelListDispatcher) {\n  var subscriber = new Map();\n  if (!pubSub) return subscriber;\n  subscriber.set(pubSubTopics.CREATE_CHANNEL, pubSub.subscribe(pubSubTopics.CREATE_CHANNEL, function (_a) {\n    var channel = _a.channel;\n    channelListDispatcher({\n      type: CREATE_CHANNEL,\n      payload: channel\n    });\n  }));\n  subscriber.set(pubSubTopics.UPDATE_USER_MESSAGE, pubSub.subscribe(pubSubTopics.UPDATE_USER_MESSAGE, function (_a) {\n    var _b;\n    var channel = _a.channel,\n      message = _a.message;\n    if (channel.isGroupChannel() && ((_b = channel === null || channel === void 0 ? void 0 : channel.lastMessage) === null || _b === void 0 ? void 0 : _b.messageId) === message.messageId) {\n      channel.lastMessage = message;\n      channelListDispatcher({\n        type: ON_LAST_MESSAGE_UPDATED,\n        payload: channel\n      });\n    }\n  }));\n  subscriber.set(pubSubTopics.LEAVE_CHANNEL, pubSub.subscribe(pubSubTopics.LEAVE_CHANNEL, function (msg) {\n    var channel = msg.channel;\n    channelListDispatcher({\n      type: LEAVE_CHANNEL_SUCCESS,\n      payload: channel === null || channel === void 0 ? void 0 : channel.url\n    });\n  }));\n  return subscriber;\n};\n\n/**\n * NOTICE: Use this function IF the current channel is removed from allChannels.\n * This function will give you the next currentChannel value.\n */\nvar getNextChannel = function (_a) {\n  var channel = _a.channel,\n    currentChannel = _a.currentChannel,\n    allChannels = _a.allChannels,\n    disableAutoSelect = _a.disableAutoSelect;\n  var nextChannel = null;\n  if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === channel.url) {\n    if (!disableAutoSelect && allChannels.length > 0) {\n      var firstChannel = allChannels[0],\n        _b = allChannels[1],\n        secondChannel = _b === void 0 ? null : _b;\n      nextChannel = firstChannel.url === channel.url ? secondChannel : firstChannel;\n    }\n  } else {\n    nextChannel = currentChannel;\n  }\n  return nextChannel;\n};\nvar initialState = {\n  // we might not need this initialized state -> should remove\n  initialized: false,\n  loading: true,\n  allChannels: [],\n  currentChannel: null,\n  channelListQuery: null,\n  currentUserId: '',\n  disableAutoSelect: false\n};\nfunction channelListReducer(state, action) {\n  return K(action).with({\n    type: INIT_CHANNELS_START\n  }, function (_a) {\n    var payload = _a.payload;\n    return __assign(__assign({}, state), {\n      loading: true,\n      currentUserId: payload.currentUserId\n    });\n  }).with({\n    type: RESET_CHANNEL_LIST\n  }, function () {\n    return initialState;\n  }).with({\n    type: INIT_CHANNELS_SUCCESS\n  }, function (action) {\n    var _a = action.payload,\n      channelList = _a.channelList,\n      disableAutoSelect = _a.disableAutoSelect;\n    return __assign(__assign({}, state), {\n      initialized: true,\n      loading: false,\n      allChannels: channelList,\n      disableAutoSelect: disableAutoSelect,\n      currentChannel: !disableAutoSelect && channelList && channelList.length && channelList.length > 0 ? channelList[0] : state.currentChannel\n    });\n  }).with({\n    type: REFRESH_CHANNELS_SUCCESS\n  }, function (action) {\n    var _a = action.payload,\n      channelList = _a.channelList,\n      currentChannel = _a.currentChannel;\n    return __assign(__assign({}, state), {\n      loading: false,\n      allChannels: channelList,\n      currentChannel: currentChannel\n    });\n  }).with({\n    type: FETCH_CHANNELS_SUCCESS\n  }, function (action) {\n    var currentChannels = state.allChannels.map(function (c) {\n      return c.url;\n    });\n    var filteredChannels = action.payload.filter(function (_a) {\n      var url = _a.url;\n      return !currentChannels.find(function (c) {\n        return c === url;\n      });\n    });\n    return __assign(__assign({}, state), {\n      allChannels: __spreadArray(__spreadArray([], state.allChannels, true), filteredChannels, true)\n    });\n  }).with({\n    type: CREATE_CHANNEL\n  }, function (action) {\n    var _a;\n    var channel = action.payload;\n    var allChannels = state.allChannels,\n      currentUserId = state.currentUserId,\n      channelListQuery = state.channelListQuery;\n    if (channelListQuery) {\n      if (filterChannelListParams(channelListQuery, channel, currentUserId)) {\n        // Good to add to the ChannelList\n        return __assign(__assign({}, state), {\n          currentChannel: channel,\n          allChannels: getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order)\n        });\n      }\n      // Do not add to the ChannelList\n      return __assign(__assign({}, state), {\n        currentChannel: channel\n      });\n    }\n    // No channelListQuery\n    // Add to the top of the ChannelList\n    return __assign(__assign({}, state), {\n      currentChannel: channel,\n      allChannels: __spreadArray([channel], allChannels.filter(function (ch) {\n        return ch.url !== (channel === null || channel === void 0 ? void 0 : channel.url);\n      }), true)\n    });\n  })\n  // A hidden channel will be unhidden when getting new message\n  .with({\n    type: ON_CHANNEL_ARCHIVED\n  }, function (action) {\n    var _a;\n    var channel = action.payload;\n    var allChannels = state.allChannels,\n      currentUserId = state.currentUserId,\n      currentChannel = state.currentChannel,\n      channelListQuery = state.channelListQuery,\n      disableAutoSelect = state.disableAutoSelect;\n    if (channelListQuery) {\n      if (filterChannelListParams(channelListQuery, channel, currentUserId)) {\n        // Good to [add to/keep in] the ChannelList\n        return __assign(__assign({}, state), {\n          allChannels: getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order)\n        });\n      }\n      // * Remove the channel from the ChannelList: because the channel is filtered\n    }\n    // No channelListQuery\n    // * Remove the channel from the ChannelList: because the channel is hidden\n    // Replace the currentChannel if it's filtered or hidden\n    var nextChannel = getNextChannel({\n      channel: channel,\n      currentChannel: currentChannel,\n      allChannels: allChannels,\n      disableAutoSelect: disableAutoSelect\n    });\n    return __assign(__assign({}, state), {\n      currentChannel: nextChannel,\n      allChannels: allChannels.filter(function (_a) {\n        var url = _a.url;\n        return url !== (channel === null || channel === void 0 ? void 0 : channel.url);\n      })\n    });\n  }).with({\n    type: S.union(LEAVE_CHANNEL_SUCCESS, ON_CHANNEL_DELETED)\n  }, function (action) {\n    var _a;\n    var channelUrl = action.payload;\n    var allChannels = state.allChannels.filter(function (_a) {\n      var url = _a.url;\n      return url !== channelUrl;\n    });\n    return __assign(__assign({}, state), {\n      currentChannel: channelUrl === ((_a = state.currentChannel) === null || _a === void 0 ? void 0 : _a.url) ? allChannels[0] : state.currentChannel,\n      allChannels: allChannels\n    });\n  }).with({\n    type: ON_USER_LEFT\n  }, function (action) {\n    var _a;\n    var _b = action.payload,\n      channel = _b.channel,\n      isMe = _b.isMe;\n    var allChannels = state.allChannels,\n      currentUserId = state.currentUserId,\n      currentChannel = state.currentChannel,\n      channelListQuery = state.channelListQuery,\n      disableAutoSelect = state.disableAutoSelect;\n    var nextChannels = __spreadArray([], allChannels, true);\n    var nextChannel = channel;\n    /**\n     * 1. If I left channel:\n     *   - Remove the channel from channel list\n     *   - Replace currentChannel with the next ordered channel\n     * 2. If other member left channel:\n     *   2-1. If query is given:\n     *     2-1-1. If channel no longer matches the query\n     *       - Same as step 1\n     *     2-1-2. If channel matches the query:\n     *       - Upsert channel list with the channel\n     *       - Replace currentChannel IFF url is same\n     *   2-2. If query is not given,\n     *     - Same as step 2-1-2\n     */\n    /* `1` and `2-1-1` */\n    if (isMe || channelListQuery && !filterChannelListParams(channelListQuery, channel, currentUserId)) {\n      var channelAt = allChannels.findIndex(function (ch) {\n        return ch.url === channel.url;\n      });\n      if (channelAt > -1) {\n        nextChannels.splice(channelAt, 1);\n        nextChannel = getNextChannel({\n          channel: channel,\n          currentChannel: currentChannel,\n          allChannels: allChannels,\n          disableAutoSelect: disableAutoSelect\n        });\n      }\n    } else {\n      /* `2-1-2` and `2-2` */\n      nextChannels = getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order);\n      if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === channel.url) {\n        nextChannel = channel;\n      }\n    }\n    return __assign(__assign({}, state), {\n      currentChannel: nextChannel,\n      allChannels: nextChannels\n    });\n  }).with({\n    type: S.union(ON_USER_JOINED, ON_CHANNEL_CHANGED, ON_READ_RECEIPT_UPDATED, ON_DELIVERY_RECEIPT_UPDATED)\n  }, function (action) {\n    var _a, _b, _c;\n    var channel = action.payload;\n    var _d = state.allChannels,\n      allChannels = _d === void 0 ? [] : _d,\n      currentUserId = state.currentUserId,\n      currentChannel = state.currentChannel,\n      channelListQuery = state.channelListQuery,\n      disableAutoSelect = state.disableAutoSelect;\n    var unreadMessageCount = channel.unreadMessageCount;\n    if (channelListQuery) {\n      if (filterChannelListParams(channelListQuery, channel, currentUserId)) {\n        // Good to [add to/keep in] the ChannelList\n        return __assign(__assign({}, state), {\n          allChannels: getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order)\n        });\n      }\n      // If the channel is just created and the current user is the only member,\n      // don't add to the ChannelList but keep the currentChannel\n      if (isChannelJustCreated(channel)) {\n        return state;\n      }\n      // Filter the channel from the ChannelList\n      // Replace the currentChannel if it's filtered channel\n      var nextChannel = getNextChannel({\n        channel: channel,\n        currentChannel: currentChannel,\n        allChannels: allChannels,\n        disableAutoSelect: disableAutoSelect\n      });\n      return __assign(__assign({}, state), {\n        currentChannel: nextChannel,\n        allChannels: allChannels.filter(function (_a) {\n          var url = _a.url;\n          return url !== (channel === null || channel === void 0 ? void 0 : channel.url);\n        })\n      });\n    }\n    if (\n    // When marking as read the channel\n    unreadMessageCount === 0\n    // @ts-ignore - When sending a message by the current peer\n    && ((_c = (_b = channel === null || channel === void 0 ? void 0 : channel.lastMessage) === null || _b === void 0 ? void 0 : _b.sender) === null || _c === void 0 ? void 0 : _c.userId) !== currentUserId) {\n      // Don't move to the top\n      return __assign(__assign({}, state), {\n        allChannels: allChannels.map(function (ch) {\n          return ch.url === (channel === null || channel === void 0 ? void 0 : channel.url) ? channel : ch;\n        })\n      });\n    }\n    // Move to the top\n    return __assign(__assign({}, state), {\n      allChannels: __spreadArray([channel], allChannels.filter(function (_a) {\n        var url = _a.url;\n        return url !== channel.url;\n      }), true)\n    });\n  }).with({\n    type: SET_CURRENT_CHANNEL\n  }, function (action) {\n    return __assign(__assign({}, state), {\n      currentChannel: action.payload\n    });\n  }).with({\n    type: ON_LAST_MESSAGE_UPDATED\n  }, function (action) {\n    return __assign(__assign({}, state), {\n      allChannels: state.allChannels.map(function (channel) {\n        return (channel === null || channel === void 0 ? void 0 : channel.url) === action.payload.url ? action.payload : channel;\n      })\n    });\n  }).with({\n    type: ON_CHANNEL_FROZEN\n  }, function (action) {\n    var _a;\n    var channel = action.payload;\n    var allChannels = state.allChannels,\n      currentUserId = state.currentUserId,\n      currentChannel = state.currentChannel,\n      channelListQuery = state.channelListQuery,\n      disableAutoSelect = state.disableAutoSelect;\n    if (channelListQuery) {\n      if (filterChannelListParams(channelListQuery, channel, currentUserId)) {\n        // Good to [add to/keep in] the ChannelList\n        return __assign(__assign({}, state), {\n          allChannels: getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order)\n        });\n      }\n      // Filter the channel from the ChannelList\n      // Replace the currentChannel if it's filtered channel\n      var nextChannel = getNextChannel({\n        channel: channel,\n        currentChannel: currentChannel,\n        allChannels: allChannels,\n        disableAutoSelect: disableAutoSelect\n      });\n      return __assign(__assign({}, state), {\n        currentChannel: nextChannel,\n        allChannels: allChannels.filter(function (_a) {\n          var url = _a.url;\n          return url !== (channel === null || channel === void 0 ? void 0 : channel.url);\n        })\n      });\n    }\n    return __assign(__assign({}, state), {\n      allChannels: allChannels.map(function (ch) {\n        if (ch.url === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n          // eslint-disable-next-line no-param-reassign\n          ch.isFrozen = true;\n          return ch;\n        }\n        return ch;\n      })\n    });\n  }).with({\n    type: ON_CHANNEL_UNFROZEN\n  }, function (action) {\n    var _a;\n    var channel = action.payload;\n    var allChannels = state.allChannels,\n      currentUserId = state.currentUserId,\n      currentChannel = state.currentChannel,\n      channelListQuery = state.channelListQuery,\n      disableAutoSelect = state.disableAutoSelect;\n    if (channelListQuery) {\n      if (filterChannelListParams(channelListQuery, channel, currentUserId)) {\n        // Good to [add to/keep in] the ChannelList\n        return __assign(__assign({}, state), {\n          allChannels: getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order)\n        });\n      }\n      // Filter the channel from the ChannelList\n      // Replace the currentChannel if it's filtered channel\n      var nextChannel = getNextChannel({\n        channel: channel,\n        currentChannel: currentChannel,\n        allChannels: allChannels,\n        disableAutoSelect: disableAutoSelect\n      });\n      return __assign(__assign({}, state), {\n        currentChannel: nextChannel,\n        allChannels: allChannels.filter(function (_a) {\n          var url = _a.url;\n          return url !== (channel === null || channel === void 0 ? void 0 : channel.url);\n        })\n      });\n    }\n    // No channelListQuery\n    return __assign(__assign({}, state), {\n      allChannels: allChannels.map(function (ch) {\n        if (ch.url === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n          // eslint-disable-next-line no-param-reassign\n          ch.isFrozen = false;\n          return ch;\n        }\n        return ch;\n      })\n    });\n  }).with({\n    type: CHANNEL_LIST_PARAMS_UPDATED\n  }, function (action) {\n    return __assign(__assign({}, state), {\n      channelListQuery: action.payload.channelListQuery,\n      currentUserId: action.payload.currentUserId\n    });\n  }).otherwise(function () {\n    return state;\n  });\n}\nfunction useActiveChannelUrl(_a, _b) {\n  var activeChannelUrl = _a.activeChannelUrl,\n    channels = _a.channels,\n    sdk = _a.sdk;\n  var logger = _b.logger,\n    channelListDispatcher = _b.channelListDispatcher;\n  return useEffect(function () {\n    var _a;\n    if (activeChannelUrl) {\n      logger.info('ChannelListProvider: looking for active channel', {\n        activeChannelUrl: activeChannelUrl\n      });\n      var activeChannel = channels === null || channels === void 0 ? void 0 : channels.find(function (channel) {\n        return channel.url === activeChannelUrl;\n      });\n      if (activeChannel) {\n        channelListDispatcher({\n          type: SET_CURRENT_CHANNEL,\n          payload: activeChannel\n        });\n      } else {\n        logger.info('ChannelListProvider: searching backend for active channel', {\n          activeChannelUrl: activeChannelUrl\n        });\n        (_a = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.getChannel(activeChannelUrl).then(function (channel) {\n          channelListDispatcher({\n            type: FETCH_CHANNELS_SUCCESS,\n            payload: [channel]\n          });\n          channelListDispatcher({\n            type: SET_CURRENT_CHANNEL,\n            payload: channel\n          });\n        }).catch(function () {\n          logger.warning('ChannelListProvider: Active channel not found');\n        });\n      }\n    }\n  }, [activeChannelUrl]);\n}\nvar useFetchChannelList = function (_a, _b) {\n  var channelSource = _a.channelSource,\n    disableMarkAsDelivered = _a.disableMarkAsDelivered;\n  var channelListDispatcher = _b.channelListDispatcher,\n    logger = _b.logger,\n    markAsDeliveredScheduler = _b.markAsDeliveredScheduler;\n  return useCallback(function () {\n    return __awaiter(void 0, void 0, void 0, function () {\n      var channelList, error_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(channelSource === null || channelSource === void 0 ? void 0 : channelSource.hasNext)) {\n              logger.info('ChannelList: not able to fetch');\n              return [2 /*return*/];\n            }\n            logger.info('ChannelList: starting fetch');\n            channelListDispatcher({\n              type: FETCH_CHANNELS_START,\n              payload: null\n            });\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, channelSource.next()];\n          case 2:\n            channelList = _a.sent();\n            logger.info('ChannelList: succeeded fetch', {\n              channelList: channelList\n            });\n            channelListDispatcher({\n              type: FETCH_CHANNELS_SUCCESS,\n              payload: channelList\n            });\n            if (!disableMarkAsDelivered) {\n              logger.info('ChannelList: mark as delivered to fetched channels');\n              // eslint-disable-next-line no-unused-expressions\n              channelList === null || channelList === void 0 ? void 0 : channelList.forEach(function (channel) {\n                if ((channel === null || channel === void 0 ? void 0 : channel.unreadMessageCount) > 0) {\n                  markAsDeliveredScheduler.push(channel);\n                }\n              });\n            }\n            return [3 /*break*/, 4];\n          case 3:\n            error_1 = _a.sent();\n            logger.error('ChannelList: failed fetch', {\n              error: error_1\n            });\n            channelListDispatcher({\n              type: FETCH_CHANNELS_FAILURE,\n              payload: error_1\n            });\n            return [3 /*break*/, 4];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  }, [channelSource, disableMarkAsDelivered]);\n};\nfunction useHandleReconnectForChannelList(_a) {\n  var isOnline = _a.isOnline,\n    reconnectOnIdle = _a.reconnectOnIdle,\n    logger = _a.logger,\n    sdk = _a.sdk,\n    currentGroupChannel = _a.currentGroupChannel,\n    channelListDispatcher = _a.channelListDispatcher,\n    setChannelSource = _a.setChannelSource,\n    userFilledChannelListQuery = _a.userFilledChannelListQuery,\n    sortChannelList = _a.sortChannelList,\n    disableAutoSelect = _a.disableAutoSelect,\n    markAsDeliveredScheduler = _a.markAsDeliveredScheduler,\n    disableMarkAsDelivered = _a.disableMarkAsDelivered;\n  var shouldReconnect = useReconnectOnIdle(isOnline, currentGroupChannel, reconnectOnIdle).shouldReconnect;\n  useEffect(function () {\n    return function () {\n      var _a, _b, _c, _d;\n      // state changed from offline to online AND tab is visible\n      if (shouldReconnect) {\n        logger.info('ChannelList refresh - creating query', {\n          userFilledChannelListQuery: userFilledChannelListQuery\n        });\n        var channelListQuery = createChannelListQuery({\n          sdk: sdk,\n          userFilledChannelListQuery: userFilledChannelListQuery\n        });\n        logger.info('ChannelList refresh - created query', channelListQuery);\n        setChannelSource(channelListQuery);\n        channelListDispatcher({\n          type: INIT_CHANNELS_START,\n          payload: {\n            currentUserId: (_b = (_a = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId) !== null && _b !== void 0 ? _b : ''\n          }\n        });\n        if (userFilledChannelListQuery) {\n          logger.info('ChannelList refresh - setting up channelListQuery', channelListQuery);\n          channelListDispatcher({\n            type: CHANNEL_LIST_PARAMS_UPDATED,\n            payload: {\n              channelListQuery: channelListQuery,\n              currentUserId: (_d = (_c = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId) !== null && _d !== void 0 ? _d : ''\n            }\n          });\n        }\n        logger.info('ChannelList refresh - fetching channels');\n        if (channelListQuery.hasNext) {\n          channelListQuery.next().then(function (channelList) {\n            var _a, _b;\n            logger.info('ChannelList refresh - fetched channels', channelList);\n            var sortedChannelList = channelList;\n            if (sortChannelList && typeof sortChannelList === 'function') {\n              sortedChannelList = sortChannelList(channelList);\n              logger.info('ChannelList refresh - channel list sorted', sortedChannelList);\n            }\n            // select first channel\n            var newCurrentChannel = !disableAutoSelect ? sortedChannelList[0] : null;\n            if (currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) {\n              var foundChannel = sortedChannelList.find(function (channel) {\n                return channel.url === currentGroupChannel.url;\n              });\n              if (foundChannel) {\n                newCurrentChannel = foundChannel;\n              }\n            }\n            logger.info('ChannelList refresh - highlight channel', newCurrentChannel);\n            channelListDispatcher({\n              type: REFRESH_CHANNELS_SUCCESS,\n              payload: {\n                channelList: sortedChannelList,\n                currentChannel: newCurrentChannel\n              }\n            });\n            var canSetMarkAsDelivered = (_b = (_a = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) === null || _a === void 0 ? void 0 : _a.premiumFeatureList) === null || _b === void 0 ? void 0 : _b.find(function (feature) {\n              return feature === DELIVERY_RECEIPT$1;\n            });\n            if (canSetMarkAsDelivered && !disableMarkAsDelivered) {\n              sortedChannelList.forEach(function (channel) {\n                markAsDeliveredScheduler.push(channel);\n              });\n            }\n          }).catch(function (err) {\n            if (err) {\n              logger.error('ChannelList refresh - could not fetch channels', err);\n              channelListDispatcher({\n                type: INIT_CHANNELS_FAILURE\n              });\n            }\n          });\n        } else {\n          logger.info('ChannelList refresh - there are no more channels');\n        }\n      }\n    };\n  }, [shouldReconnect]);\n}\nvar ChannelListContext = React__default.createContext(null);\n/**\n * @deprecated This provider is deprecated and will be removed in the next major update.\n * Please use the `GroupChannelListProvider` from '@sendbird/uikit-react/GroupChannelList' instead.\n * For more information, please refer to the migration guide:\n * https://docs.sendbird.com/docs/chat/uikit/v3/react/introduction/group-channel-migration-guide\n */\nvar ChannelListProvider = function (props) {\n  var _a, _b;\n  // destruct props\n  var children = props.children,\n    className = props.className,\n    disableUserProfile = props.disableUserProfile,\n    allowProfileEdit = props.allowProfileEdit,\n    queries = props.queries,\n    onProfileEditSuccess = props.onProfileEditSuccess,\n    onThemeChange = props.onThemeChange,\n    onBeforeCreateChannel = props.onBeforeCreateChannel,\n    sortChannelList = props.sortChannelList,\n    overrideInviteUser = props.overrideInviteUser,\n    activeChannelUrl = props.activeChannelUrl,\n    _c = props.isTypingIndicatorEnabled,\n    isTypingIndicatorEnabled = _c === void 0 ? null : _c,\n    _d = props.isMessageReceiptStatusEnabled,\n    isMessageReceiptStatusEnabled = _d === void 0 ? null : _d,\n    reconnectOnIdle = props.reconnectOnIdle;\n  // disable autoselect, if activeChannelUrl is provided\n  // useActiveChannelUrl should be executed when activeChannelUrl is present\n  var disableAutoSelect = (props === null || props === void 0 ? void 0 : props.disableAutoSelect) || !!activeChannelUrl;\n  var onChannelSelect = (props === null || props === void 0 ? void 0 : props.onChannelSelect) || noop;\n  // fetch store from <SendbirdProvider />\n  var globalStore = useSendbirdStateContext();\n  var config = globalStore.config,\n    stores = globalStore.stores;\n  var sdkStore = stores.sdkStore;\n  var pubSub = config.pubSub,\n    logger = config.logger,\n    onUserProfileMessage = config.onUserProfileMessage;\n  var markAsDeliveredScheduler = config.markAsDeliveredScheduler,\n    _e = config.disableMarkAsDelivered,\n    disableMarkAsDelivered = _e === void 0 ? false : _e,\n    isOnline = config.isOnline;\n  var sdk = sdkStore === null || sdkStore === void 0 ? void 0 : sdkStore.sdk;\n  var _f = ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) !== null && _a !== void 0 ? _a : {}).premiumFeatureList,\n    premiumFeatureList = _f === void 0 ? [] : _f;\n  // derive some variables\n  // enable if it is true at least once(both are false by default)\n  var userDefinedDisableUserProfile = disableUserProfile !== null && disableUserProfile !== void 0 ? disableUserProfile : !config.common.enableUsingDefaultUserProfile;\n  var userDefinedRenderProfile = config === null || config === void 0 ? void 0 : config.renderUserProfile;\n  var enableEditProfile = allowProfileEdit || config.allowProfileEdit;\n  var userFilledChannelListQuery = queries === null || queries === void 0 ? void 0 : queries.channelListQuery;\n  var userFilledApplicationUserListQuery = queries === null || queries === void 0 ? void 0 : queries.applicationUserListQuery;\n  var sdkIntialized = sdkStore === null || sdkStore === void 0 ? void 0 : sdkStore.initialized;\n  var _g = useReducer(channelListReducer, initialState),\n    channelListStore = _g[0],\n    channelListDispatcher = _g[1];\n  var currentChannel = channelListStore.currentChannel;\n  var _h = useState(null),\n    channelSource = _h[0],\n    setChannelSource = _h[1];\n  var _j = useState([]),\n    typingChannels = _j[0],\n    setTypingChannels = _j[1];\n  useEffect(function () {\n    var subscriber = pubSubHandler(pubSub, channelListDispatcher);\n    return function () {\n      pubSubHandleRemover(subscriber);\n    };\n  }, [sdkIntialized]);\n  useEffect(function () {\n    var _a;\n    var sdkChannelHandlerId = uuidv4();\n    if (sdkIntialized) {\n      logger.info('ChannelList: Setup channelHandlers');\n      setupChannelList({\n        sdk: sdk,\n        sdkChannelHandlerId: sdkChannelHandlerId,\n        channelListDispatcher: channelListDispatcher,\n        setChannelSource: setChannelSource,\n        onChannelSelect: onChannelSelect,\n        userFilledChannelListQuery: __assign({}, userFilledChannelListQuery),\n        logger: logger,\n        sortChannelList: sortChannelList,\n        disableAutoSelect: disableAutoSelect,\n        markAsDeliveredScheduler: markAsDeliveredScheduler,\n        disableMarkAsDelivered: disableMarkAsDelivered\n      });\n    } else {\n      logger.info('ChannelList: Removing channelHandlers');\n      // remove previous channelHandlers\n      if ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.removeGroupChannelHandler) {\n        sdk.groupChannel.removeGroupChannelHandler(sdkChannelHandlerId);\n      }\n      // remove channelSource\n      setChannelSource(null);\n      // cleanup\n      channelListDispatcher({\n        type: RESET_CHANNEL_LIST,\n        payload: null\n      });\n    }\n    return function () {\n      var _a, _b;\n      logger.info('ChannelList: Removing channelHandlers');\n      if ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.removeGroupChannelHandler) {\n        (_b = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _b === void 0 ? void 0 : _b.removeGroupChannelHandler(sdkChannelHandlerId);\n      }\n    };\n  }, [sdkIntialized, sortChannelList, Object.entries(userFilledChannelListQuery !== null && userFilledChannelListQuery !== void 0 ? userFilledChannelListQuery : {}).map(function (_a) {\n    var key = _a[0],\n      value = _a[1];\n    return key + value;\n  }).join()]);\n  useEffect(function () {\n    var _a, _b;\n    var typingHandlerId = '';\n    if ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.addGroupChannelHandler) {\n      typingHandlerId = uuidv4();\n      var handler = new GroupChannelHandler({\n        onTypingStatusUpdated: function (channel) {\n          var _a;\n          var typingMemberCount = (_a = channel === null || channel === void 0 ? void 0 : channel.getTypingUsers()) === null || _a === void 0 ? void 0 : _a.length;\n          var channelList = typingChannels.filter(function (ch) {\n            return ch.url !== channel.url;\n          });\n          if (typingMemberCount > 0) {\n            setTypingChannels(__spreadArray(__spreadArray([], channelList, true), [channel], false));\n          } else {\n            setTypingChannels(channelList);\n          }\n        },\n        onUnreadMemberStatusUpdated: function (channel) {\n          channelListDispatcher({\n            type: ON_LAST_MESSAGE_UPDATED,\n            payload: channel\n          });\n        },\n        onUndeliveredMemberStatusUpdated: function (channel) {\n          channelListDispatcher({\n            type: ON_LAST_MESSAGE_UPDATED,\n            payload: channel\n          });\n        },\n        onMessageUpdated: function (channel) {\n          if (channel.isGroupChannel()) {\n            channelListDispatcher({\n              type: ON_LAST_MESSAGE_UPDATED,\n              payload: channel\n            });\n            sdk.groupChannel.getChannelWithoutCache(channel.url).then(function (ch) {\n              channelListDispatcher({\n                type: ON_LAST_MESSAGE_UPDATED,\n                payload: ch\n              });\n            });\n          }\n        },\n        onMentionReceived: function (channel) {\n          if (channel.isGroupChannel()) {\n            channelListDispatcher({\n              type: ON_LAST_MESSAGE_UPDATED,\n              payload: channel\n            });\n            sdk.groupChannel.getChannelWithoutCache(channel.url).then(function (ch) {\n              channelListDispatcher({\n                type: ON_LAST_MESSAGE_UPDATED,\n                payload: ch\n              });\n            });\n          }\n        }\n      });\n      (_b = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _b === void 0 ? void 0 : _b.addGroupChannelHandler(typingHandlerId, handler);\n    }\n    return function () {\n      var _a;\n      if (((_a = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.removeGroupChannelHandler) && typingHandlerId !== '') {\n        sdk.groupChannel.removeGroupChannelHandler(typingHandlerId);\n      }\n    };\n  }, [(_b = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId]);\n  var queries_ = useMemo(function () {\n    return {\n      applicationUserListQuery: userFilledApplicationUserListQuery,\n      channelListQuery: userFilledChannelListQuery\n    };\n  }, [userFilledApplicationUserListQuery, userFilledChannelListQuery]);\n  var allChannels = channelListStore.allChannels;\n  var sortedChannels = sortChannelList && typeof sortChannelList === 'function' ? sortChannelList(allChannels) : allChannels;\n  if (sortedChannels.length !== allChannels.length) {\n    var warning = \"ChannelList: You have removed/added extra channels on sortChannelList\\n      this could cause unexpected problems\";\n    // eslint-disable-next-line no-console\n    console.warn(warning, {\n      before: allChannels,\n      after: sortedChannels\n    });\n    logger.warning(warning, {\n      before: allChannels,\n      after: sortedChannels\n    });\n  }\n  // Set current channel (by on_channel_selected event)\n  useEffect(function () {\n    if (!sdk || !sdk.groupChannel) {\n      return;\n    }\n    // When leaving a channel, tell consumers that the prior channel is no longer selected\n    if (!(currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url)) {\n      onChannelSelect(null);\n      return;\n    }\n    sdk.groupChannel.getChannel(currentChannel.url).then(function (groupChannel) {\n      if (groupChannel) {\n        onChannelSelect(groupChannel);\n      } else {\n        onChannelSelect(null);\n      }\n    });\n  }, [currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url]);\n  // Set active channel (by url)\n  useActiveChannelUrl({\n    activeChannelUrl: activeChannelUrl,\n    channels: sortedChannels,\n    sdk: sdk\n  }, {\n    logger: logger,\n    channelListDispatcher: channelListDispatcher\n  });\n  useHandleReconnectForChannelList({\n    isOnline: isOnline,\n    reconnectOnIdle: reconnectOnIdle,\n    logger: logger,\n    sdk: sdk,\n    currentGroupChannel: currentChannel,\n    channelListDispatcher: channelListDispatcher,\n    setChannelSource: setChannelSource,\n    userFilledChannelListQuery: userFilledChannelListQuery,\n    sortChannelList: sortChannelList,\n    disableAutoSelect: disableAutoSelect,\n    markAsDeliveredScheduler: markAsDeliveredScheduler,\n    disableMarkAsDelivered: disableMarkAsDelivered\n  });\n  var fetchChannelList = useFetchChannelList({\n    channelSource: channelSource,\n    disableMarkAsDelivered: disableMarkAsDelivered || !premiumFeatureList.some(function (feature) {\n      return feature === DELIVERY_RECEIPT$1;\n    })\n  }, {\n    channelListDispatcher: channelListDispatcher,\n    logger: logger,\n    markAsDeliveredScheduler: markAsDeliveredScheduler\n  });\n  return React__default.createElement(ChannelListContext.Provider, {\n    value: __assign(__assign({\n      className: className,\n      disableUserProfile: disableUserProfile,\n      queries: queries_,\n      onProfileEditSuccess: onProfileEditSuccess,\n      onThemeChange: onThemeChange,\n      onBeforeCreateChannel: onBeforeCreateChannel,\n      overrideInviteUser: overrideInviteUser,\n      onChannelSelect: onChannelSelect,\n      sortChannelList: sortChannelList,\n      allowProfileEdit: enableEditProfile,\n      channelListDispatcher: channelListDispatcher,\n      channelSource: channelSource\n    }, channelListStore), {\n      allChannels: sortedChannels,\n      typingChannels: typingChannels,\n      isTypingIndicatorEnabled: isTypingIndicatorEnabled !== null && isTypingIndicatorEnabled !== void 0 ? isTypingIndicatorEnabled : config.groupChannelList.enableTypingIndicator,\n      isMessageReceiptStatusEnabled: isMessageReceiptStatusEnabled !== null && isMessageReceiptStatusEnabled !== void 0 ? isMessageReceiptStatusEnabled : config.groupChannelList.enableMessageReceiptStatus,\n      fetchChannelList: fetchChannelList\n    })\n  }, React__default.createElement(UserProfileProvider, {\n    disableUserProfile: userDefinedDisableUserProfile !== null && userDefinedDisableUserProfile !== void 0 ? userDefinedDisableUserProfile : !config.common.enableUsingDefaultUserProfile,\n    renderUserProfile: userDefinedRenderProfile,\n    onUserProfileMessage: onUserProfileMessage\n  }, React__default.createElement(\"div\", {\n    className: \"sendbird-channel-list \".concat(className)\n  }, children)));\n};\nfunction useChannelListContext() {\n  var context = useContext(ChannelListContext);\n  if (!context) throw new Error('ChannelListContext not found. Use within the ChannelList module.');\n  return context;\n}\nexport { ChannelListProvider as C, LEAVE_CHANNEL_SUCCESS as L, SET_CURRENT_CHANNEL as S, useChannelListContext as u };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import { _ as __assign, c as __spreadArray, a as __awaiter, b as __generator } from './bundle-BQi9-O76.js';\nimport React__default, { useEffect, useCallback, useReducer, useState, useMemo, useContext } from 'react';\nimport { GroupChannelHandler, GroupChannelListOrder } from '@sendbird/chat/groupChannel';\nimport { p as pubSubTopics } from './bundle-b6TpX_JP.js';\nimport { u as uuidv4 } from './bundle-etuaqevl.js';\nimport { n as noop } from './bundle-BgwzpLeQ.js';\nimport { D as DELIVERY_RECEIPT$1 } from './bundle-DCMGp6rH.js';\nimport { U as UserProfileProvider } from './bundle-BrTJ5Zbd.js';\nimport { useSendbirdStateContext } from '../useSendbirdStateContext.js';\nimport { K, $ as filterChannelListParams, a0 as getChannelsWithUpsertedChannel, a1 as S, a2 as isChannelJustCreated } from './bundle-DxTN4_0p.js';\nimport { u as useReconnectOnIdle } from './bundle-H8J7tAed.js';\n\nvar RESET_CHANNEL_LIST = 'RESET_CHANNEL_LIST';\nvar CREATE_CHANNEL = 'CREATE_CHANNEL';\nvar LEAVE_CHANNEL_SUCCESS = 'LEAVE_CHANNEL_SUCCESS';\nvar SET_CURRENT_CHANNEL = 'SET_CURRENT_CHANNEL';\nvar FETCH_CHANNELS_START = 'FETCH_CHANNELS_START';\nvar FETCH_CHANNELS_SUCCESS = 'FETCH_CHANNELS_SUCCESS';\nvar FETCH_CHANNELS_FAILURE = 'FETCH_CHANNELS_FAILURE';\nvar INIT_CHANNELS_START = 'INIT_CHANNELS_START';\nvar INIT_CHANNELS_SUCCESS = 'INIT_CHANNELS_SUCCESS';\nvar REFRESH_CHANNELS_SUCCESS = 'REFRESH_CHANNELS_SUCCESS';\nvar INIT_CHANNELS_FAILURE = 'INIT_CHANNELS_FAILURE';\nvar ON_USER_JOINED = 'ON_USER_JOINED';\nvar ON_CHANNEL_DELETED = 'ON_CHANNEL_DELETED';\nvar ON_LAST_MESSAGE_UPDATED = 'ON_LAST_MESSAGE_UPDATED';\nvar ON_USER_LEFT = 'ON_USER_LEFT';\nvar ON_CHANNEL_CHANGED = 'ON_CHANNEL_CHANGED';\nvar ON_CHANNEL_ARCHIVED = 'ON_CHANNEL_ARCHIVED';\nvar ON_CHANNEL_FROZEN = 'ON_CHANNEL_FROZEN';\nvar ON_CHANNEL_UNFROZEN = 'ON_CHANNEL_UNFROZEN';\nvar ON_READ_RECEIPT_UPDATED = 'ON_READ_RECEIPT_UPDATED';\nvar ON_DELIVERY_RECEIPT_UPDATED = 'ON_DELIVERY_RECEIPT_UPDATED';\nvar CHANNEL_LIST_PARAMS_UPDATED = 'CHANNEL_LIST_PARAMS_UPDATED';\n\nvar DELIVERY_RECEIPT = 'delivery_receipt';\nvar createEventHandler = function (_a) {\n    var sdk = _a.sdk, sdkChannelHandlerId = _a.sdkChannelHandlerId, channelListDispatcher = _a.channelListDispatcher, logger = _a.logger;\n    var ChannelHandler = new GroupChannelHandler({\n        onChannelChanged: function (channel) {\n            if (channel.isGroupChannel()) {\n                logger.info('ChannelList: onChannelChanged', channel);\n                channelListDispatcher({\n                    type: ON_CHANNEL_CHANGED,\n                    payload: channel,\n                });\n            }\n        },\n        onChannelDeleted: function (channelUrl) {\n            logger.info('ChannelList: onChannelDeleted', channelUrl);\n            channelListDispatcher({\n                type: ON_CHANNEL_DELETED,\n                payload: channelUrl,\n            });\n        },\n        onUserJoined: function (channel) {\n            logger.info('ChannelList: onUserJoined', channel);\n            channelListDispatcher({\n                type: ON_USER_JOINED,\n                payload: channel,\n            });\n        },\n        onUserBanned: function (channel, user) {\n            var _a;\n            if (channel.isGroupChannel()) {\n                logger.info('Channel: onUserBanned', channel);\n                var isMe = user.userId === ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                channelListDispatcher({\n                    type: ON_USER_LEFT,\n                    payload: { channel: channel, isMe: isMe },\n                });\n            }\n        },\n        onUserLeft: function (channel, user) {\n            var _a;\n            logger.info('ChannelList: onUserLeft', channel);\n            var isMe = user.userId === ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n            channelListDispatcher({\n                type: ON_USER_LEFT,\n                payload: { channel: channel, isMe: isMe },\n            });\n        },\n        onUnreadMemberStatusUpdated: function (channel) {\n            logger.info('ChannelList: onUnreadMemberStatusUpdated', channel);\n            channelListDispatcher({\n                type: ON_READ_RECEIPT_UPDATED,\n                payload: channel,\n            });\n        },\n        onUndeliveredMemberStatusUpdated: function (channel) {\n            logger.info('ChannelList: onUndeliveredMemberStatusUpdated', channel);\n            if (channel.lastMessage) {\n                channelListDispatcher({\n                    type: ON_DELIVERY_RECEIPT_UPDATED,\n                    payload: channel,\n                });\n            }\n        },\n        onMessageUpdated: function (channel, message) {\n            var _a;\n            if (channel.isGroupChannel() && ((_a = channel.lastMessage) === null || _a === void 0 ? void 0 : _a.isEqual(message))) {\n                logger.info('ChannelList: onMessageUpdated', channel);\n                channelListDispatcher({\n                    type: ON_LAST_MESSAGE_UPDATED,\n                    payload: channel,\n                });\n            }\n        },\n        onChannelHidden: function (channel) {\n            logger.info('ChannelList: onChannelHidden', channel);\n            channelListDispatcher({\n                type: ON_CHANNEL_ARCHIVED,\n                payload: channel,\n            });\n        },\n        onChannelFrozen: function (channel) {\n            if (channel.isGroupChannel()) {\n                logger.info('ChannelList: onChannelFrozen', channel);\n                channelListDispatcher({\n                    type: ON_CHANNEL_FROZEN,\n                    payload: channel,\n                });\n            }\n        },\n        onChannelUnfrozen: function (channel) {\n            if (channel.isGroupChannel()) {\n                logger.info('ChannelList: onChannelUnfrozen', channel);\n                channelListDispatcher({\n                    type: ON_CHANNEL_UNFROZEN,\n                    payload: channel,\n                });\n            }\n        },\n    });\n    logger.info('ChannelList: Added channelHandler');\n    sdk.groupChannel.addGroupChannelHandler(sdkChannelHandlerId, ChannelHandler);\n};\nvar createChannelListQuery = function (_a) {\n    var sdk = _a.sdk, _b = _a.userFilledChannelListQuery, userFilledChannelListQuery = _b === void 0 ? {} : _b;\n    var params = {\n        includeEmpty: false,\n        limit: 20, // The value of pagination limit could be set up to 100.\n        order: GroupChannelListOrder.LATEST_LAST_MESSAGE,\n    };\n    if (userFilledChannelListQuery) {\n        Object.keys(userFilledChannelListQuery).forEach(function (key) {\n            // @ts-ignore\n            params[key] = userFilledChannelListQuery[key];\n        });\n    }\n    return sdk.groupChannel.createMyGroupChannelListQuery(params);\n};\nfunction setupChannelList(_a) {\n    var _b, _c, _d, _e;\n    var sdk = _a.sdk, sdkChannelHandlerId = _a.sdkChannelHandlerId, channelListDispatcher = _a.channelListDispatcher, setChannelSource = _a.setChannelSource, onChannelSelect = _a.onChannelSelect, userFilledChannelListQuery = _a.userFilledChannelListQuery, logger = _a.logger, sortChannelList = _a.sortChannelList, disableAutoSelect = _a.disableAutoSelect, markAsDeliveredScheduler = _a.markAsDeliveredScheduler, disableMarkAsDelivered = _a.disableMarkAsDelivered;\n    if (sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) {\n        createEventHandler({\n            sdk: sdk,\n            channelListDispatcher: channelListDispatcher,\n            sdkChannelHandlerId: sdkChannelHandlerId,\n            logger: logger,\n        });\n    }\n    else {\n        logger.warning('ChannelList - createEventHandler: sdk or sdk.ChannelHandler does not exist', sdk);\n    }\n    logger.info('ChannelList - creating query', { userFilledChannelListQuery: userFilledChannelListQuery });\n    var channelListQuery = createChannelListQuery({ sdk: sdk, userFilledChannelListQuery: userFilledChannelListQuery });\n    logger.info('ChannelList - created query', channelListQuery);\n    setChannelSource(channelListQuery);\n    channelListDispatcher({\n        type: INIT_CHANNELS_START,\n        payload: {\n            currentUserId: (_c = (_b = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId) !== null && _c !== void 0 ? _c : '',\n        },\n    });\n    if (userFilledChannelListQuery) {\n        logger.info('ChannelList - setting up channelListQuery', channelListQuery);\n        channelListDispatcher({\n            type: CHANNEL_LIST_PARAMS_UPDATED,\n            payload: {\n                channelListQuery: channelListQuery,\n                currentUserId: (_e = (_d = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _d === void 0 ? void 0 : _d.userId) !== null && _e !== void 0 ? _e : '',\n            },\n        });\n    }\n    logger.info('ChannelList - fetching channels');\n    if (channelListQuery.hasNext) {\n        channelListQuery\n            .next()\n            .then(function (channelList) {\n            var _a, _b;\n            logger.info('ChannelList - fetched channels', channelList);\n            // select first channel\n            logger.info('ChannelList - highlight channel', channelList[0]);\n            var sortedChannelList = channelList;\n            if (sortChannelList && typeof sortChannelList === 'function') {\n                sortedChannelList = sortChannelList(channelList);\n                logger.info('ChannelList - channel list sorted', sortedChannelList);\n            }\n            if (!disableAutoSelect) {\n                onChannelSelect === null || onChannelSelect === void 0 ? void 0 : onChannelSelect(sortedChannelList[0]);\n            }\n            channelListDispatcher({\n                type: INIT_CHANNELS_SUCCESS,\n                payload: {\n                    channelList: sortedChannelList,\n                    disableAutoSelect: disableAutoSelect,\n                },\n            });\n            var canSetMarkAsDelivered = (_b = (_a = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) === null || _a === void 0 ? void 0 : _a.premiumFeatureList) === null || _b === void 0 ? void 0 : _b.find(function (feature) { return feature === DELIVERY_RECEIPT; });\n            if (canSetMarkAsDelivered && !disableMarkAsDelivered) {\n                sortedChannelList.forEach(function (channel) {\n                    markAsDeliveredScheduler.push(channel);\n                });\n            }\n        })\n            .catch(function (err) {\n            if (err) {\n                logger.error('ChannelList - couldnt fetch channels', err);\n                channelListDispatcher({\n                    type: INIT_CHANNELS_FAILURE,\n                });\n            }\n        });\n    }\n    else {\n        logger.info('ChannelList - there are no more channels');\n    }\n}\nvar pubSubHandleRemover = function (subscriber) {\n    subscriber.forEach(function (s) {\n        try {\n            s.remove();\n        }\n        catch (_a) {\n            //\n        }\n    });\n};\nvar pubSubHandler = function (pubSub, channelListDispatcher) {\n    var subscriber = new Map();\n    if (!pubSub)\n        return subscriber;\n    subscriber.set(pubSubTopics.CREATE_CHANNEL, pubSub.subscribe(pubSubTopics.CREATE_CHANNEL, function (_a) {\n        var channel = _a.channel;\n        channelListDispatcher({\n            type: CREATE_CHANNEL,\n            payload: channel,\n        });\n    }));\n    subscriber.set(pubSubTopics.UPDATE_USER_MESSAGE, pubSub.subscribe(pubSubTopics.UPDATE_USER_MESSAGE, function (_a) {\n        var _b;\n        var channel = _a.channel, message = _a.message;\n        if (channel.isGroupChannel() && ((_b = channel === null || channel === void 0 ? void 0 : channel.lastMessage) === null || _b === void 0 ? void 0 : _b.messageId) === message.messageId) {\n            channel.lastMessage = message;\n            channelListDispatcher({\n                type: ON_LAST_MESSAGE_UPDATED,\n                payload: channel,\n            });\n        }\n    }));\n    subscriber.set(pubSubTopics.LEAVE_CHANNEL, pubSub.subscribe(pubSubTopics.LEAVE_CHANNEL, function (msg) {\n        var channel = msg.channel;\n        channelListDispatcher({\n            type: LEAVE_CHANNEL_SUCCESS,\n            payload: channel === null || channel === void 0 ? void 0 : channel.url,\n        });\n    }));\n    return subscriber;\n};\n\n/**\n * NOTICE: Use this function IF the current channel is removed from allChannels.\n * This function will give you the next currentChannel value.\n */\nvar getNextChannel = function (_a) {\n    var channel = _a.channel, currentChannel = _a.currentChannel, allChannels = _a.allChannels, disableAutoSelect = _a.disableAutoSelect;\n    var nextChannel = null;\n    if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === channel.url) {\n        if (!disableAutoSelect && allChannels.length > 0) {\n            var firstChannel = allChannels[0], _b = allChannels[1], secondChannel = _b === void 0 ? null : _b;\n            nextChannel = firstChannel.url === channel.url ? secondChannel : firstChannel;\n        }\n    }\n    else {\n        nextChannel = currentChannel;\n    }\n    return nextChannel;\n};\n\nvar initialState = {\n    // we might not need this initialized state -> should remove\n    initialized: false,\n    loading: true,\n    allChannels: [],\n    currentChannel: null,\n    channelListQuery: null,\n    currentUserId: '',\n    disableAutoSelect: false,\n};\n\nfunction channelListReducer(state, action) {\n    return (K(action)\n        .with({ type: INIT_CHANNELS_START }, function (_a) {\n        var payload = _a.payload;\n        return (__assign(__assign({}, state), { loading: true, currentUserId: payload.currentUserId }));\n    })\n        .with({ type: RESET_CHANNEL_LIST }, function () {\n        return initialState;\n    })\n        .with({ type: INIT_CHANNELS_SUCCESS }, function (action) {\n        var _a = action.payload, channelList = _a.channelList, disableAutoSelect = _a.disableAutoSelect;\n        return __assign(__assign({}, state), { initialized: true, loading: false, allChannels: channelList, disableAutoSelect: disableAutoSelect, currentChannel: !disableAutoSelect && channelList && channelList.length && channelList.length > 0 ? channelList[0] : state.currentChannel });\n    })\n        .with({ type: REFRESH_CHANNELS_SUCCESS }, function (action) {\n        var _a = action.payload, channelList = _a.channelList, currentChannel = _a.currentChannel;\n        return __assign(__assign({}, state), { loading: false, allChannels: channelList, currentChannel: currentChannel });\n    })\n        .with({ type: FETCH_CHANNELS_SUCCESS }, function (action) {\n        var currentChannels = state.allChannels.map(function (c) { return c.url; });\n        var filteredChannels = action.payload.filter(function (_a) {\n            var url = _a.url;\n            return !currentChannels.find(function (c) { return c === url; });\n        });\n        return __assign(__assign({}, state), { allChannels: __spreadArray(__spreadArray([], state.allChannels, true), filteredChannels, true) });\n    })\n        .with({ type: CREATE_CHANNEL }, function (action) {\n        var _a;\n        var channel = action.payload;\n        var allChannels = state.allChannels, currentUserId = state.currentUserId, channelListQuery = state.channelListQuery;\n        if (channelListQuery) {\n            if (filterChannelListParams(channelListQuery, channel, currentUserId)) {\n                // Good to add to the ChannelList\n                return __assign(__assign({}, state), { currentChannel: channel, allChannels: getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order) });\n            }\n            // Do not add to the ChannelList\n            return __assign(__assign({}, state), { currentChannel: channel });\n        }\n        // No channelListQuery\n        // Add to the top of the ChannelList\n        return __assign(__assign({}, state), { currentChannel: channel, allChannels: __spreadArray([channel], allChannels.filter(function (ch) { return ch.url !== (channel === null || channel === void 0 ? void 0 : channel.url); }), true) });\n    })\n        // A hidden channel will be unhidden when getting new message\n        .with({ type: ON_CHANNEL_ARCHIVED }, function (action) {\n        var _a;\n        var channel = action.payload;\n        var allChannels = state.allChannels, currentUserId = state.currentUserId, currentChannel = state.currentChannel, channelListQuery = state.channelListQuery, disableAutoSelect = state.disableAutoSelect;\n        if (channelListQuery) {\n            if (filterChannelListParams(channelListQuery, channel, currentUserId)) {\n                // Good to [add to/keep in] the ChannelList\n                return __assign(__assign({}, state), { allChannels: getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order) });\n            }\n            // * Remove the channel from the ChannelList: because the channel is filtered\n        }\n        // No channelListQuery\n        // * Remove the channel from the ChannelList: because the channel is hidden\n        // Replace the currentChannel if it's filtered or hidden\n        var nextChannel = getNextChannel({\n            channel: channel,\n            currentChannel: currentChannel,\n            allChannels: allChannels,\n            disableAutoSelect: disableAutoSelect,\n        });\n        return __assign(__assign({}, state), { currentChannel: nextChannel, allChannels: allChannels.filter(function (_a) {\n                var url = _a.url;\n                return url !== (channel === null || channel === void 0 ? void 0 : channel.url);\n            }) });\n    })\n        .with({ type: S.union(LEAVE_CHANNEL_SUCCESS, ON_CHANNEL_DELETED) }, function (action) {\n        var _a;\n        var channelUrl = action.payload;\n        var allChannels = state.allChannels.filter(function (_a) {\n            var url = _a.url;\n            return url !== channelUrl;\n        });\n        return __assign(__assign({}, state), { currentChannel: channelUrl === ((_a = state.currentChannel) === null || _a === void 0 ? void 0 : _a.url) ? allChannels[0] : state.currentChannel, allChannels: allChannels });\n    })\n        .with({ type: ON_USER_LEFT }, function (action) {\n        var _a;\n        var _b = action.payload, channel = _b.channel, isMe = _b.isMe;\n        var allChannels = state.allChannels, currentUserId = state.currentUserId, currentChannel = state.currentChannel, channelListQuery = state.channelListQuery, disableAutoSelect = state.disableAutoSelect;\n        var nextChannels = __spreadArray([], allChannels, true);\n        var nextChannel = channel;\n        /**\n         * 1. If I left channel:\n         *   - Remove the channel from channel list\n         *   - Replace currentChannel with the next ordered channel\n         * 2. If other member left channel:\n         *   2-1. If query is given:\n         *     2-1-1. If channel no longer matches the query\n         *       - Same as step 1\n         *     2-1-2. If channel matches the query:\n         *       - Upsert channel list with the channel\n         *       - Replace currentChannel IFF url is same\n         *   2-2. If query is not given,\n         *     - Same as step 2-1-2\n         */\n        /* `1` and `2-1-1` */\n        if (isMe || (channelListQuery && !filterChannelListParams(channelListQuery, channel, currentUserId))) {\n            var channelAt = allChannels.findIndex(function (ch) { return ch.url === channel.url; });\n            if (channelAt > -1) {\n                nextChannels.splice(channelAt, 1);\n                nextChannel = getNextChannel({\n                    channel: channel,\n                    currentChannel: currentChannel,\n                    allChannels: allChannels,\n                    disableAutoSelect: disableAutoSelect,\n                });\n            }\n        }\n        else {\n            /* `2-1-2` and `2-2` */\n            nextChannels = getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order);\n            if ((currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url) === channel.url) {\n                nextChannel = channel;\n            }\n        }\n        return __assign(__assign({}, state), { currentChannel: nextChannel, allChannels: nextChannels });\n    })\n        .with({\n        type: S.union(ON_USER_JOINED, ON_CHANNEL_CHANGED, ON_READ_RECEIPT_UPDATED, ON_DELIVERY_RECEIPT_UPDATED),\n    }, function (action) {\n        var _a, _b, _c;\n        var channel = action.payload;\n        var _d = state.allChannels, allChannels = _d === void 0 ? [] : _d, currentUserId = state.currentUserId, currentChannel = state.currentChannel, channelListQuery = state.channelListQuery, disableAutoSelect = state.disableAutoSelect;\n        var unreadMessageCount = channel.unreadMessageCount;\n        if (channelListQuery) {\n            if (filterChannelListParams(channelListQuery, channel, currentUserId)) {\n                // Good to [add to/keep in] the ChannelList\n                return __assign(__assign({}, state), { allChannels: getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order) });\n            }\n            // If the channel is just created and the current user is the only member,\n            // don't add to the ChannelList but keep the currentChannel\n            if (isChannelJustCreated(channel)) {\n                return state;\n            }\n            // Filter the channel from the ChannelList\n            // Replace the currentChannel if it's filtered channel\n            var nextChannel = getNextChannel({\n                channel: channel,\n                currentChannel: currentChannel,\n                allChannels: allChannels,\n                disableAutoSelect: disableAutoSelect,\n            });\n            return __assign(__assign({}, state), { currentChannel: nextChannel, allChannels: allChannels.filter(function (_a) {\n                    var url = _a.url;\n                    return url !== (channel === null || channel === void 0 ? void 0 : channel.url);\n                }) });\n        }\n        if (\n        // When marking as read the channel\n        unreadMessageCount === 0\n            // @ts-ignore - When sending a message by the current peer\n            && ((_c = (_b = channel === null || channel === void 0 ? void 0 : channel.lastMessage) === null || _b === void 0 ? void 0 : _b.sender) === null || _c === void 0 ? void 0 : _c.userId) !== currentUserId) {\n            // Don't move to the top\n            return __assign(__assign({}, state), { allChannels: allChannels.map(function (ch) { return (ch.url === (channel === null || channel === void 0 ? void 0 : channel.url) ? channel : ch); }) });\n        }\n        // Move to the top\n        return __assign(__assign({}, state), { allChannels: __spreadArray([channel], allChannels.filter(function (_a) {\n                var url = _a.url;\n                return url !== channel.url;\n            }), true) });\n    })\n        .with({ type: SET_CURRENT_CHANNEL }, function (action) {\n        return __assign(__assign({}, state), { currentChannel: action.payload });\n    })\n        .with({ type: ON_LAST_MESSAGE_UPDATED }, function (action) {\n        return __assign(__assign({}, state), { allChannels: state.allChannels.map(function (channel) { return (channel === null || channel === void 0 ? void 0 : channel.url) === action.payload.url ? action.payload : channel; }) });\n    })\n        .with({ type: ON_CHANNEL_FROZEN }, function (action) {\n        var _a;\n        var channel = action.payload;\n        var allChannels = state.allChannels, currentUserId = state.currentUserId, currentChannel = state.currentChannel, channelListQuery = state.channelListQuery, disableAutoSelect = state.disableAutoSelect;\n        if (channelListQuery) {\n            if (filterChannelListParams(channelListQuery, channel, currentUserId)) {\n                // Good to [add to/keep in] the ChannelList\n                return __assign(__assign({}, state), { allChannels: getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order) });\n            }\n            // Filter the channel from the ChannelList\n            // Replace the currentChannel if it's filtered channel\n            var nextChannel = getNextChannel({\n                channel: channel,\n                currentChannel: currentChannel,\n                allChannels: allChannels,\n                disableAutoSelect: disableAutoSelect,\n            });\n            return __assign(__assign({}, state), { currentChannel: nextChannel, allChannels: allChannels.filter(function (_a) {\n                    var url = _a.url;\n                    return url !== (channel === null || channel === void 0 ? void 0 : channel.url);\n                }) });\n        }\n        return __assign(__assign({}, state), { allChannels: allChannels.map(function (ch) {\n                if (ch.url === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n                    // eslint-disable-next-line no-param-reassign\n                    ch.isFrozen = true;\n                    return ch;\n                }\n                return ch;\n            }) });\n    })\n        .with({ type: ON_CHANNEL_UNFROZEN }, function (action) {\n        var _a;\n        var channel = action.payload;\n        var allChannels = state.allChannels, currentUserId = state.currentUserId, currentChannel = state.currentChannel, channelListQuery = state.channelListQuery, disableAutoSelect = state.disableAutoSelect;\n        if (channelListQuery) {\n            if (filterChannelListParams(channelListQuery, channel, currentUserId)) {\n                // Good to [add to/keep in] the ChannelList\n                return __assign(__assign({}, state), { allChannels: getChannelsWithUpsertedChannel(allChannels, channel, (_a = state.channelListQuery) === null || _a === void 0 ? void 0 : _a.order) });\n            }\n            // Filter the channel from the ChannelList\n            // Replace the currentChannel if it's filtered channel\n            var nextChannel = getNextChannel({\n                channel: channel,\n                currentChannel: currentChannel,\n                allChannels: allChannels,\n                disableAutoSelect: disableAutoSelect,\n            });\n            return __assign(__assign({}, state), { currentChannel: nextChannel, allChannels: allChannels.filter(function (_a) {\n                    var url = _a.url;\n                    return url !== (channel === null || channel === void 0 ? void 0 : channel.url);\n                }) });\n        }\n        // No channelListQuery\n        return __assign(__assign({}, state), { allChannels: allChannels.map(function (ch) {\n                if (ch.url === (channel === null || channel === void 0 ? void 0 : channel.url)) {\n                    // eslint-disable-next-line no-param-reassign\n                    ch.isFrozen = false;\n                    return ch;\n                }\n                return ch;\n            }) });\n    })\n        .with({ type: CHANNEL_LIST_PARAMS_UPDATED }, function (action) { return (__assign(__assign({}, state), { channelListQuery: action.payload.channelListQuery, currentUserId: action.payload.currentUserId })); })\n        .otherwise(function () { return state; }));\n}\n\nfunction useActiveChannelUrl(_a, _b) {\n    var activeChannelUrl = _a.activeChannelUrl, channels = _a.channels, sdk = _a.sdk;\n    var logger = _b.logger, channelListDispatcher = _b.channelListDispatcher;\n    return useEffect(function () {\n        var _a;\n        if (activeChannelUrl) {\n            logger.info('ChannelListProvider: looking for active channel', { activeChannelUrl: activeChannelUrl });\n            var activeChannel = channels === null || channels === void 0 ? void 0 : channels.find(function (channel) { return channel.url === activeChannelUrl; });\n            if (activeChannel) {\n                channelListDispatcher({\n                    type: SET_CURRENT_CHANNEL,\n                    payload: activeChannel,\n                });\n            }\n            else {\n                logger.info('ChannelListProvider: searching backend for active channel', { activeChannelUrl: activeChannelUrl });\n                (_a = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.getChannel(activeChannelUrl).then(function (channel) {\n                    channelListDispatcher({\n                        type: FETCH_CHANNELS_SUCCESS,\n                        payload: [channel],\n                    });\n                    channelListDispatcher({\n                        type: SET_CURRENT_CHANNEL,\n                        payload: channel,\n                    });\n                }).catch(function () {\n                    logger.warning('ChannelListProvider: Active channel not found');\n                });\n            }\n        }\n    }, [activeChannelUrl]);\n}\n\nvar useFetchChannelList = function (_a, _b) {\n    var channelSource = _a.channelSource, disableMarkAsDelivered = _a.disableMarkAsDelivered;\n    var channelListDispatcher = _b.channelListDispatcher, logger = _b.logger, markAsDeliveredScheduler = _b.markAsDeliveredScheduler;\n    return useCallback(function () { return __awaiter(void 0, void 0, void 0, function () {\n        var channelList, error_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    if (!(channelSource === null || channelSource === void 0 ? void 0 : channelSource.hasNext)) {\n                        logger.info('ChannelList: not able to fetch');\n                        return [2 /*return*/];\n                    }\n                    logger.info('ChannelList: starting fetch');\n                    channelListDispatcher({\n                        type: FETCH_CHANNELS_START,\n                        payload: null,\n                    });\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 3, , 4]);\n                    return [4 /*yield*/, channelSource.next()];\n                case 2:\n                    channelList = _a.sent();\n                    logger.info('ChannelList: succeeded fetch', { channelList: channelList });\n                    channelListDispatcher({\n                        type: FETCH_CHANNELS_SUCCESS,\n                        payload: channelList,\n                    });\n                    if (!disableMarkAsDelivered) {\n                        logger.info('ChannelList: mark as delivered to fetched channels');\n                        // eslint-disable-next-line no-unused-expressions\n                        channelList === null || channelList === void 0 ? void 0 : channelList.forEach(function (channel) {\n                            if ((channel === null || channel === void 0 ? void 0 : channel.unreadMessageCount) > 0) {\n                                markAsDeliveredScheduler.push(channel);\n                            }\n                        });\n                    }\n                    return [3 /*break*/, 4];\n                case 3:\n                    error_1 = _a.sent();\n                    logger.error('ChannelList: failed fetch', { error: error_1 });\n                    channelListDispatcher({\n                        type: FETCH_CHANNELS_FAILURE,\n                        payload: error_1,\n                    });\n                    return [3 /*break*/, 4];\n                case 4: return [2 /*return*/];\n            }\n        });\n    }); }, [\n        channelSource,\n        disableMarkAsDelivered,\n    ]);\n};\n\nfunction useHandleReconnectForChannelList(_a) {\n    var isOnline = _a.isOnline, reconnectOnIdle = _a.reconnectOnIdle, logger = _a.logger, sdk = _a.sdk, currentGroupChannel = _a.currentGroupChannel, channelListDispatcher = _a.channelListDispatcher, setChannelSource = _a.setChannelSource, userFilledChannelListQuery = _a.userFilledChannelListQuery, sortChannelList = _a.sortChannelList, disableAutoSelect = _a.disableAutoSelect, markAsDeliveredScheduler = _a.markAsDeliveredScheduler, disableMarkAsDelivered = _a.disableMarkAsDelivered;\n    var shouldReconnect = useReconnectOnIdle(isOnline, currentGroupChannel, reconnectOnIdle).shouldReconnect;\n    useEffect(function () {\n        return function () {\n            var _a, _b, _c, _d;\n            // state changed from offline to online AND tab is visible\n            if (shouldReconnect) {\n                logger.info('ChannelList refresh - creating query', { userFilledChannelListQuery: userFilledChannelListQuery });\n                var channelListQuery = createChannelListQuery({ sdk: sdk, userFilledChannelListQuery: userFilledChannelListQuery });\n                logger.info('ChannelList refresh - created query', channelListQuery);\n                setChannelSource(channelListQuery);\n                channelListDispatcher({\n                    type: INIT_CHANNELS_START,\n                    payload: {\n                        currentUserId: (_b = (_a = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId) !== null && _b !== void 0 ? _b : '',\n                    },\n                });\n                if (userFilledChannelListQuery) {\n                    logger.info('ChannelList refresh - setting up channelListQuery', channelListQuery);\n                    channelListDispatcher({\n                        type: CHANNEL_LIST_PARAMS_UPDATED,\n                        payload: {\n                            channelListQuery: channelListQuery,\n                            currentUserId: (_d = (_c = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId) !== null && _d !== void 0 ? _d : '',\n                        },\n                    });\n                }\n                logger.info('ChannelList refresh - fetching channels');\n                if (channelListQuery.hasNext) {\n                    channelListQuery\n                        .next()\n                        .then(function (channelList) {\n                        var _a, _b;\n                        logger.info('ChannelList refresh - fetched channels', channelList);\n                        var sortedChannelList = channelList;\n                        if (sortChannelList && typeof sortChannelList === 'function') {\n                            sortedChannelList = sortChannelList(channelList);\n                            logger.info('ChannelList refresh - channel list sorted', sortedChannelList);\n                        }\n                        // select first channel\n                        var newCurrentChannel = !disableAutoSelect ? sortedChannelList[0] : null;\n                        if (currentGroupChannel === null || currentGroupChannel === void 0 ? void 0 : currentGroupChannel.url) {\n                            var foundChannel = sortedChannelList.find(function (channel) { return (channel.url === currentGroupChannel.url); });\n                            if (foundChannel) {\n                                newCurrentChannel = foundChannel;\n                            }\n                        }\n                        logger.info('ChannelList refresh - highlight channel', newCurrentChannel);\n                        channelListDispatcher({\n                            type: REFRESH_CHANNELS_SUCCESS,\n                            payload: {\n                                channelList: sortedChannelList,\n                                currentChannel: newCurrentChannel,\n                            },\n                        });\n                        var canSetMarkAsDelivered = (_b = (_a = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) === null || _a === void 0 ? void 0 : _a.premiumFeatureList) === null || _b === void 0 ? void 0 : _b.find(function (feature) { return feature === DELIVERY_RECEIPT$1; });\n                        if (canSetMarkAsDelivered && !disableMarkAsDelivered) {\n                            sortedChannelList.forEach(function (channel) {\n                                markAsDeliveredScheduler.push(channel);\n                            });\n                        }\n                    })\n                        .catch(function (err) {\n                        if (err) {\n                            logger.error('ChannelList refresh - could not fetch channels', err);\n                            channelListDispatcher({\n                                type: INIT_CHANNELS_FAILURE,\n                            });\n                        }\n                    });\n                }\n                else {\n                    logger.info('ChannelList refresh - there are no more channels');\n                }\n            }\n        };\n    }, [shouldReconnect]);\n}\n\nvar ChannelListContext = React__default.createContext(null);\n/**\n * @deprecated This provider is deprecated and will be removed in the next major update.\n * Please use the `GroupChannelListProvider` from '@sendbird/uikit-react/GroupChannelList' instead.\n * For more information, please refer to the migration guide:\n * https://docs.sendbird.com/docs/chat/uikit/v3/react/introduction/group-channel-migration-guide\n */\nvar ChannelListProvider = function (props) {\n    var _a, _b;\n    // destruct props\n    var children = props.children, className = props.className, disableUserProfile = props.disableUserProfile, allowProfileEdit = props.allowProfileEdit, queries = props.queries, onProfileEditSuccess = props.onProfileEditSuccess, onThemeChange = props.onThemeChange, onBeforeCreateChannel = props.onBeforeCreateChannel, sortChannelList = props.sortChannelList, overrideInviteUser = props.overrideInviteUser, activeChannelUrl = props.activeChannelUrl, _c = props.isTypingIndicatorEnabled, isTypingIndicatorEnabled = _c === void 0 ? null : _c, _d = props.isMessageReceiptStatusEnabled, isMessageReceiptStatusEnabled = _d === void 0 ? null : _d, reconnectOnIdle = props.reconnectOnIdle;\n    // disable autoselect, if activeChannelUrl is provided\n    // useActiveChannelUrl should be executed when activeChannelUrl is present\n    var disableAutoSelect = (props === null || props === void 0 ? void 0 : props.disableAutoSelect) || !!activeChannelUrl;\n    var onChannelSelect = (props === null || props === void 0 ? void 0 : props.onChannelSelect) || noop;\n    // fetch store from <SendbirdProvider />\n    var globalStore = useSendbirdStateContext();\n    var config = globalStore.config, stores = globalStore.stores;\n    var sdkStore = stores.sdkStore;\n    var pubSub = config.pubSub, logger = config.logger, onUserProfileMessage = config.onUserProfileMessage;\n    var markAsDeliveredScheduler = config.markAsDeliveredScheduler, _e = config.disableMarkAsDelivered, disableMarkAsDelivered = _e === void 0 ? false : _e, isOnline = config.isOnline;\n    var sdk = sdkStore === null || sdkStore === void 0 ? void 0 : sdkStore.sdk;\n    var _f = ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.appInfo) !== null && _a !== void 0 ? _a : {}).premiumFeatureList, premiumFeatureList = _f === void 0 ? [] : _f;\n    // derive some variables\n    // enable if it is true at least once(both are false by default)\n    var userDefinedDisableUserProfile = disableUserProfile !== null && disableUserProfile !== void 0 ? disableUserProfile : !config.common.enableUsingDefaultUserProfile;\n    var userDefinedRenderProfile = config === null || config === void 0 ? void 0 : config.renderUserProfile;\n    var enableEditProfile = allowProfileEdit || config.allowProfileEdit;\n    var userFilledChannelListQuery = queries === null || queries === void 0 ? void 0 : queries.channelListQuery;\n    var userFilledApplicationUserListQuery = queries === null || queries === void 0 ? void 0 : queries.applicationUserListQuery;\n    var sdkIntialized = sdkStore === null || sdkStore === void 0 ? void 0 : sdkStore.initialized;\n    var _g = useReducer(channelListReducer, initialState), channelListStore = _g[0], channelListDispatcher = _g[1];\n    var currentChannel = channelListStore.currentChannel;\n    var _h = useState(null), channelSource = _h[0], setChannelSource = _h[1];\n    var _j = useState([]), typingChannels = _j[0], setTypingChannels = _j[1];\n    useEffect(function () {\n        var subscriber = pubSubHandler(pubSub, channelListDispatcher);\n        return function () {\n            pubSubHandleRemover(subscriber);\n        };\n    }, [sdkIntialized]);\n    useEffect(function () {\n        var _a;\n        var sdkChannelHandlerId = uuidv4();\n        if (sdkIntialized) {\n            logger.info('ChannelList: Setup channelHandlers');\n            setupChannelList({\n                sdk: sdk,\n                sdkChannelHandlerId: sdkChannelHandlerId,\n                channelListDispatcher: channelListDispatcher,\n                setChannelSource: setChannelSource,\n                onChannelSelect: onChannelSelect,\n                userFilledChannelListQuery: __assign({}, userFilledChannelListQuery),\n                logger: logger,\n                sortChannelList: sortChannelList,\n                disableAutoSelect: disableAutoSelect,\n                markAsDeliveredScheduler: markAsDeliveredScheduler,\n                disableMarkAsDelivered: disableMarkAsDelivered,\n            });\n        }\n        else {\n            logger.info('ChannelList: Removing channelHandlers');\n            // remove previous channelHandlers\n            if ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.removeGroupChannelHandler) {\n                sdk.groupChannel.removeGroupChannelHandler(sdkChannelHandlerId);\n            }\n            // remove channelSource\n            setChannelSource(null);\n            // cleanup\n            channelListDispatcher({\n                type: RESET_CHANNEL_LIST,\n                payload: null,\n            });\n        }\n        return function () {\n            var _a, _b;\n            logger.info('ChannelList: Removing channelHandlers');\n            if ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.removeGroupChannelHandler) {\n                (_b = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _b === void 0 ? void 0 : _b.removeGroupChannelHandler(sdkChannelHandlerId);\n            }\n        };\n    }, [\n        sdkIntialized,\n        sortChannelList,\n        Object.entries(userFilledChannelListQuery !== null && userFilledChannelListQuery !== void 0 ? userFilledChannelListQuery : {}).map(function (_a) {\n            var key = _a[0], value = _a[1];\n            return key + value;\n        }).join(),\n    ]);\n    useEffect(function () {\n        var _a, _b;\n        var typingHandlerId = '';\n        if ((_a = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.addGroupChannelHandler) {\n            typingHandlerId = uuidv4();\n            var handler = new GroupChannelHandler({\n                onTypingStatusUpdated: function (channel) {\n                    var _a;\n                    var typingMemberCount = (_a = channel === null || channel === void 0 ? void 0 : channel.getTypingUsers()) === null || _a === void 0 ? void 0 : _a.length;\n                    var channelList = typingChannels.filter(function (ch) { return ch.url !== channel.url; });\n                    if (typingMemberCount > 0) {\n                        setTypingChannels(__spreadArray(__spreadArray([], channelList, true), [channel], false));\n                    }\n                    else {\n                        setTypingChannels(channelList);\n                    }\n                },\n                onUnreadMemberStatusUpdated: function (channel) {\n                    channelListDispatcher({\n                        type: ON_LAST_MESSAGE_UPDATED,\n                        payload: channel,\n                    });\n                },\n                onUndeliveredMemberStatusUpdated: function (channel) {\n                    channelListDispatcher({\n                        type: ON_LAST_MESSAGE_UPDATED,\n                        payload: channel,\n                    });\n                },\n                onMessageUpdated: function (channel) {\n                    if (channel.isGroupChannel()) {\n                        channelListDispatcher({\n                            type: ON_LAST_MESSAGE_UPDATED,\n                            payload: channel,\n                        });\n                        sdk.groupChannel.getChannelWithoutCache(channel.url).then(function (ch) {\n                            channelListDispatcher({\n                                type: ON_LAST_MESSAGE_UPDATED,\n                                payload: ch,\n                            });\n                        });\n                    }\n                },\n                onMentionReceived: function (channel) {\n                    if (channel.isGroupChannel()) {\n                        channelListDispatcher({\n                            type: ON_LAST_MESSAGE_UPDATED,\n                            payload: channel,\n                        });\n                        sdk.groupChannel.getChannelWithoutCache(channel.url).then(function (ch) {\n                            channelListDispatcher({\n                                type: ON_LAST_MESSAGE_UPDATED,\n                                payload: ch,\n                            });\n                        });\n                    }\n                },\n            });\n            (_b = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _b === void 0 ? void 0 : _b.addGroupChannelHandler(typingHandlerId, handler);\n        }\n        return function () {\n            var _a;\n            if (((_a = sdk === null || sdk === void 0 ? void 0 : sdk.groupChannel) === null || _a === void 0 ? void 0 : _a.removeGroupChannelHandler) && typingHandlerId !== '') {\n                sdk.groupChannel.removeGroupChannelHandler(typingHandlerId);\n            }\n        };\n    }, [(_b = sdk === null || sdk === void 0 ? void 0 : sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId]);\n    var queries_ = useMemo(function () {\n        return {\n            applicationUserListQuery: userFilledApplicationUserListQuery,\n            channelListQuery: userFilledChannelListQuery,\n        };\n    }, [userFilledApplicationUserListQuery, userFilledChannelListQuery]);\n    var allChannels = channelListStore.allChannels;\n    var sortedChannels = sortChannelList && typeof sortChannelList === 'function' ? sortChannelList(allChannels) : allChannels;\n    if (sortedChannels.length !== allChannels.length) {\n        var warning = \"ChannelList: You have removed/added extra channels on sortChannelList\\n      this could cause unexpected problems\";\n        // eslint-disable-next-line no-console\n        console.warn(warning, { before: allChannels, after: sortedChannels });\n        logger.warning(warning, { before: allChannels, after: sortedChannels });\n    }\n    // Set current channel (by on_channel_selected event)\n    useEffect(function () {\n        if (!sdk || !sdk.groupChannel) {\n            return;\n        }\n        // When leaving a channel, tell consumers that the prior channel is no longer selected\n        if (!(currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url)) {\n            onChannelSelect(null);\n            return;\n        }\n        sdk.groupChannel.getChannel(currentChannel.url).then(function (groupChannel) {\n            if (groupChannel) {\n                onChannelSelect(groupChannel);\n            }\n            else {\n                onChannelSelect(null);\n            }\n        });\n    }, [currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.url]);\n    // Set active channel (by url)\n    useActiveChannelUrl({\n        activeChannelUrl: activeChannelUrl,\n        channels: sortedChannels,\n        sdk: sdk,\n    }, {\n        logger: logger,\n        channelListDispatcher: channelListDispatcher,\n    });\n    useHandleReconnectForChannelList({\n        isOnline: isOnline,\n        reconnectOnIdle: reconnectOnIdle,\n        logger: logger,\n        sdk: sdk,\n        currentGroupChannel: currentChannel,\n        channelListDispatcher: channelListDispatcher,\n        setChannelSource: setChannelSource,\n        userFilledChannelListQuery: userFilledChannelListQuery,\n        sortChannelList: sortChannelList,\n        disableAutoSelect: disableAutoSelect,\n        markAsDeliveredScheduler: markAsDeliveredScheduler,\n        disableMarkAsDelivered: disableMarkAsDelivered,\n    });\n    var fetchChannelList = useFetchChannelList({\n        channelSource: channelSource,\n        disableMarkAsDelivered: disableMarkAsDelivered || !premiumFeatureList.some(function (feature) { return feature === DELIVERY_RECEIPT$1; }),\n    }, {\n        channelListDispatcher: channelListDispatcher,\n        logger: logger,\n        markAsDeliveredScheduler: markAsDeliveredScheduler,\n    });\n    return (React__default.createElement(ChannelListContext.Provider, { value: __assign(__assign({ className: className, disableUserProfile: disableUserProfile, queries: queries_, onProfileEditSuccess: onProfileEditSuccess, onThemeChange: onThemeChange, onBeforeCreateChannel: onBeforeCreateChannel, overrideInviteUser: overrideInviteUser, onChannelSelect: onChannelSelect, sortChannelList: sortChannelList, allowProfileEdit: enableEditProfile, channelListDispatcher: channelListDispatcher, channelSource: channelSource }, channelListStore), { allChannels: sortedChannels, typingChannels: typingChannels, isTypingIndicatorEnabled: isTypingIndicatorEnabled !== null && isTypingIndicatorEnabled !== void 0 ? isTypingIndicatorEnabled : config.groupChannelList.enableTypingIndicator, isMessageReceiptStatusEnabled: isMessageReceiptStatusEnabled !== null && isMessageReceiptStatusEnabled !== void 0 ? isMessageReceiptStatusEnabled : config.groupChannelList.enableMessageReceiptStatus, fetchChannelList: fetchChannelList }) },\n        React__default.createElement(UserProfileProvider, { disableUserProfile: userDefinedDisableUserProfile !== null && userDefinedDisableUserProfile !== void 0 ? userDefinedDisableUserProfile : !config.common.enableUsingDefaultUserProfile, renderUserProfile: userDefinedRenderProfile, onUserProfileMessage: onUserProfileMessage },\n            React__default.createElement(\"div\", { className: \"sendbird-channel-list \".concat(className) }, children))));\n};\nfunction useChannelListContext() {\n    var context = useContext(ChannelListContext);\n    if (!context)\n        throw new Error('ChannelListContext not found. Use within the ChannelList module.');\n    return context;\n}\n\nexport { ChannelListProvider as C, LEAVE_CHANNEL_SUCCESS as L, SET_CURRENT_CHANNEL as S, useChannelListContext as u };\n//# sourceMappingURL=bundle-BeheAFz4.js.map\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module"}