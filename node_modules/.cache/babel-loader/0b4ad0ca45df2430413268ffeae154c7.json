{"ast":null,"code":"import { useCallback } from 'react';\nimport { p as pubSubTopics, s as shouldPubSubPublishToChannel, a as shouldPubSubPublishToThread } from './bundle-b6TpX_JP.js';\nimport { s as scrollIntoLast$1 } from './bundle-CMLImr6T.js';\nimport '../utils/message/getOutgoingMessageState.js';\nimport { d as SCROLL_BOTTOM_DELAY_FOR_SEND } from './bundle-DCMGp6rH.js';\nvar getNicknamesMapFromMembers = function (members) {\n  if (members === void 0) {\n    members = [];\n  }\n  var nicknamesMap = new Map();\n  for (var memberIndex = 0; memberIndex < members.length; memberIndex += 1) {\n    var _a = members[memberIndex],\n      userId = _a.userId,\n      nickname = _a.nickname;\n    nicknamesMap.set(userId, nickname);\n  }\n  return nicknamesMap;\n};\nvar getParentMessageFrom = function (message) {\n  if (!message) {\n    return null;\n  }\n  if (isParentMessage(message)) {\n    return message;\n  }\n  if (isThreadMessage(message)) {\n    return (message === null || message === void 0 ? void 0 : message.parentMessage) || null;\n  }\n  return null;\n};\nvar isParentMessage = function (message) {\n  return (message === null || message === void 0 ? void 0 : message.parentMessage) === null && typeof (message === null || message === void 0 ? void 0 : message.parentMessageId) === 'number' && !(message === null || message === void 0 ? void 0 : message.parentMessageId);\n};\nvar isThreadMessage = function (message) {\n  return (message === null || message === void 0 ? void 0 : message.parentMessage) !== null && typeof (message === null || message === void 0 ? void 0 : message.parentMessageId) === 'number' && (message === null || message === void 0 ? void 0 : message.parentMessageId) > 0 && (message === null || message === void 0 ? void 0 : message.threadInfo) === null;\n};\nvar isAboutSame = function (a, b, px) {\n  return Math.abs(a - b) <= px;\n};\nvar isEmpty = function (val) {\n  return val === null || val === undefined;\n};\n// Some Ids return string and number inconsistently\n// only use to comapre IDs\nfunction compareIds(a, b) {\n  if (isEmpty(a) || isEmpty(b)) {\n    return false;\n  }\n  var aString = a.toString();\n  var bString = b.toString();\n  return aString === bString;\n}\nvar scrollIntoLast = function (intialTry) {\n  if (intialTry === void 0) {\n    intialTry = 0;\n  }\n  var MAX_TRIES = 10;\n  var currentTry = intialTry;\n  if (currentTry > MAX_TRIES) {\n    return;\n  }\n  try {\n    var scrollDOM = document.querySelector('.sendbird-thread-ui--scroll');\n    // eslint-disable-next-line no-multi-assign\n    if (scrollDOM) {\n      scrollDOM.scrollTop = scrollDOM.scrollHeight;\n    }\n  } catch (error) {\n    setTimeout(function () {\n      scrollIntoLast(currentTry + 1);\n    }, 500 * currentTry);\n  }\n};\n\n/**\n * pubSub is used instead of messagesDispatcher to avoid redundantly calling\n * because this useSendMultipleFilesMessage is used in the Channel and Thread both\n */\nvar useSendMultipleFilesMessage = function (_a, _b) {\n  var currentChannel = _a.currentChannel,\n    onBeforeSendMultipleFilesMessage = _a.onBeforeSendMultipleFilesMessage,\n    publishingModules = _a.publishingModules;\n  var logger = _b.logger,\n    pubSub = _b.pubSub,\n    scrollRef = _b.scrollRef;\n  var sendMessage = useCallback(function (files, quoteMessage) {\n    return new Promise(function (resolve, reject) {\n      if (!currentChannel) {\n        logger.warning('Channel: Sending MFm failed, because currentChannel is null.', {\n          currentChannel: currentChannel\n        });\n        reject();\n      }\n      if (files.length <= 1) {\n        logger.warning('Channel: Sending MFM failed, because there are no multiple files.', {\n          files: files\n        });\n        reject();\n      }\n      var messageParams = {\n        fileInfoList: files.map(function (file) {\n          return {\n            file: file,\n            fileName: file.name,\n            fileSize: file.size,\n            mimeType: file.type\n          };\n        })\n      };\n      if (quoteMessage) {\n        messageParams.isReplyToChannel = true;\n        messageParams.parentMessageId = quoteMessage.messageId;\n      }\n      if (typeof onBeforeSendMultipleFilesMessage === 'function') {\n        messageParams = onBeforeSendMultipleFilesMessage(files, quoteMessage);\n      }\n      logger.info('Channel: Start sending MFM', {\n        messageParams: messageParams\n      });\n      try {\n        currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.sendMultipleFilesMessage(messageParams).onFileUploaded(function (requestId, index, uploadableFileInfo, error) {\n          logger.info('Channel: onFileUploaded during sending MFM', {\n            requestId: requestId,\n            index: index,\n            error: error,\n            uploadableFileInfo: uploadableFileInfo\n          });\n          pubSub.publish(pubSubTopics.ON_FILE_INFO_UPLOADED, {\n            response: {\n              channelUrl: currentChannel.url,\n              requestId: requestId,\n              index: index,\n              uploadableFileInfo: uploadableFileInfo,\n              error: error\n            },\n            publishingModules: publishingModules\n          });\n        }).onPending(function (pendingMessage) {\n          logger.info('Channel: in progress of sending MFM', {\n            pendingMessage: pendingMessage,\n            fileInfoList: messageParams.fileInfoList\n          });\n          pubSub.publish(pubSubTopics.SEND_MESSAGE_START, {\n            message: pendingMessage,\n            channel: currentChannel,\n            publishingModules: publishingModules\n          });\n          setTimeout(function () {\n            if (scrollRef && shouldPubSubPublishToChannel(publishingModules)) {\n              scrollIntoLast$1(0, scrollRef);\n            }\n            if (shouldPubSubPublishToThread(publishingModules)) {\n              scrollIntoLast(0);\n            }\n          }, SCROLL_BOTTOM_DELAY_FOR_SEND);\n        }).onFailed(function (error, failedMessage) {\n          logger.error('Channel: Sending MFM failed.', {\n            error: error,\n            failedMessage: failedMessage\n          });\n          pubSub.publish(pubSubTopics.SEND_MESSAGE_FAILED, {\n            channel: currentChannel,\n            message: failedMessage,\n            publishingModules: publishingModules\n          });\n          reject(error);\n        }).onSucceeded(function (succeededMessage) {\n          logger.info('Channel: Sending voice message success!', {\n            succeededMessage: succeededMessage\n          });\n          pubSub.publish(pubSubTopics.SEND_FILE_MESSAGE, {\n            channel: currentChannel,\n            message: succeededMessage,\n            publishingModules: publishingModules\n          });\n          resolve(succeededMessage);\n        });\n      } catch (error) {\n        logger.error('Channel: Sending MFM failed.', {\n          error: error\n        });\n        reject(error);\n      }\n    });\n  }, [currentChannel, onBeforeSendMultipleFilesMessage, publishingModules]);\n  return [sendMessage];\n};\nexport { getNicknamesMapFromMembers as a, compareIds as c, getParentMessageFrom as g, isAboutSame as i, scrollIntoLast as s, useSendMultipleFilesMessage as u };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import { useCallback } from 'react';\nimport { p as pubSubTopics, s as shouldPubSubPublishToChannel, a as shouldPubSubPublishToThread } from './bundle-b6TpX_JP.js';\nimport { s as scrollIntoLast$1 } from './bundle-CMLImr6T.js';\nimport '../utils/message/getOutgoingMessageState.js';\nimport { d as SCROLL_BOTTOM_DELAY_FOR_SEND } from './bundle-DCMGp6rH.js';\n\nvar getNicknamesMapFromMembers = function (members) {\n    if (members === void 0) { members = []; }\n    var nicknamesMap = new Map();\n    for (var memberIndex = 0; memberIndex < members.length; memberIndex += 1) {\n        var _a = members[memberIndex], userId = _a.userId, nickname = _a.nickname;\n        nicknamesMap.set(userId, nickname);\n    }\n    return nicknamesMap;\n};\nvar getParentMessageFrom = function (message) {\n    if (!message) {\n        return null;\n    }\n    if (isParentMessage(message)) {\n        return message;\n    }\n    if (isThreadMessage(message)) {\n        return (message === null || message === void 0 ? void 0 : message.parentMessage) || null;\n    }\n    return null;\n};\nvar isParentMessage = function (message) {\n    return ((message === null || message === void 0 ? void 0 : message.parentMessage) === null\n        && typeof (message === null || message === void 0 ? void 0 : message.parentMessageId) === 'number'\n        && !(message === null || message === void 0 ? void 0 : message.parentMessageId));\n};\nvar isThreadMessage = function (message) {\n    return ((message === null || message === void 0 ? void 0 : message.parentMessage) !== null\n        && typeof (message === null || message === void 0 ? void 0 : message.parentMessageId) === 'number'\n        && (message === null || message === void 0 ? void 0 : message.parentMessageId) > 0\n        && (message === null || message === void 0 ? void 0 : message.threadInfo) === null);\n};\nvar isAboutSame = function (a, b, px) { return (Math.abs(a - b) <= px); };\nvar isEmpty = function (val) { return (val === null || val === undefined); };\n// Some Ids return string and number inconsistently\n// only use to comapre IDs\nfunction compareIds(a, b) {\n    if (isEmpty(a) || isEmpty(b)) {\n        return false;\n    }\n    var aString = a.toString();\n    var bString = b.toString();\n    return aString === bString;\n}\nvar scrollIntoLast = function (intialTry) {\n    if (intialTry === void 0) { intialTry = 0; }\n    var MAX_TRIES = 10;\n    var currentTry = intialTry;\n    if (currentTry > MAX_TRIES) {\n        return;\n    }\n    try {\n        var scrollDOM = document.querySelector('.sendbird-thread-ui--scroll');\n        // eslint-disable-next-line no-multi-assign\n        if (scrollDOM) {\n            scrollDOM.scrollTop = scrollDOM.scrollHeight;\n        }\n    }\n    catch (error) {\n        setTimeout(function () {\n            scrollIntoLast(currentTry + 1);\n        }, 500 * currentTry);\n    }\n};\n\n/**\n * pubSub is used instead of messagesDispatcher to avoid redundantly calling\n * because this useSendMultipleFilesMessage is used in the Channel and Thread both\n */\nvar useSendMultipleFilesMessage = function (_a, _b) {\n    var currentChannel = _a.currentChannel, onBeforeSendMultipleFilesMessage = _a.onBeforeSendMultipleFilesMessage, publishingModules = _a.publishingModules;\n    var logger = _b.logger, pubSub = _b.pubSub, scrollRef = _b.scrollRef;\n    var sendMessage = useCallback(function (files, quoteMessage) {\n        return new Promise(function (resolve, reject) {\n            if (!currentChannel) {\n                logger.warning('Channel: Sending MFm failed, because currentChannel is null.', { currentChannel: currentChannel });\n                reject();\n            }\n            if (files.length <= 1) {\n                logger.warning('Channel: Sending MFM failed, because there are no multiple files.', { files: files });\n                reject();\n            }\n            var messageParams = {\n                fileInfoList: files.map(function (file) { return ({\n                    file: file,\n                    fileName: file.name,\n                    fileSize: file.size,\n                    mimeType: file.type,\n                }); }),\n            };\n            if (quoteMessage) {\n                messageParams.isReplyToChannel = true;\n                messageParams.parentMessageId = quoteMessage.messageId;\n            }\n            if (typeof onBeforeSendMultipleFilesMessage === 'function') {\n                messageParams = onBeforeSendMultipleFilesMessage(files, quoteMessage);\n            }\n            logger.info('Channel: Start sending MFM', { messageParams: messageParams });\n            try {\n                currentChannel === null || currentChannel === void 0 ? void 0 : currentChannel.sendMultipleFilesMessage(messageParams).onFileUploaded(function (requestId, index, uploadableFileInfo, error) {\n                    logger.info('Channel: onFileUploaded during sending MFM', {\n                        requestId: requestId,\n                        index: index,\n                        error: error,\n                        uploadableFileInfo: uploadableFileInfo,\n                    });\n                    pubSub.publish(pubSubTopics.ON_FILE_INFO_UPLOADED, {\n                        response: {\n                            channelUrl: currentChannel.url,\n                            requestId: requestId,\n                            index: index,\n                            uploadableFileInfo: uploadableFileInfo,\n                            error: error,\n                        },\n                        publishingModules: publishingModules,\n                    });\n                }).onPending(function (pendingMessage) {\n                    logger.info('Channel: in progress of sending MFM', { pendingMessage: pendingMessage, fileInfoList: messageParams.fileInfoList });\n                    pubSub.publish(pubSubTopics.SEND_MESSAGE_START, {\n                        message: pendingMessage,\n                        channel: currentChannel,\n                        publishingModules: publishingModules,\n                    });\n                    setTimeout(function () {\n                        if (scrollRef && shouldPubSubPublishToChannel(publishingModules)) {\n                            scrollIntoLast$1(0, scrollRef);\n                        }\n                        if (shouldPubSubPublishToThread(publishingModules)) {\n                            scrollIntoLast(0);\n                        }\n                    }, SCROLL_BOTTOM_DELAY_FOR_SEND);\n                }).onFailed(function (error, failedMessage) {\n                    logger.error('Channel: Sending MFM failed.', { error: error, failedMessage: failedMessage });\n                    pubSub.publish(pubSubTopics.SEND_MESSAGE_FAILED, {\n                        channel: currentChannel,\n                        message: failedMessage,\n                        publishingModules: publishingModules,\n                    });\n                    reject(error);\n                }).onSucceeded(function (succeededMessage) {\n                    logger.info('Channel: Sending voice message success!', { succeededMessage: succeededMessage });\n                    pubSub.publish(pubSubTopics.SEND_FILE_MESSAGE, {\n                        channel: currentChannel,\n                        message: succeededMessage,\n                        publishingModules: publishingModules,\n                    });\n                    resolve(succeededMessage);\n                });\n            }\n            catch (error) {\n                logger.error('Channel: Sending MFM failed.', { error: error });\n                reject(error);\n            }\n        });\n    }, [\n        currentChannel,\n        onBeforeSendMultipleFilesMessage,\n        publishingModules,\n    ]);\n    return [sendMessage];\n};\n\nexport { getNicknamesMapFromMembers as a, compareIds as c, getParentMessageFrom as g, isAboutSame as i, scrollIntoLast as s, useSendMultipleFilesMessage as u };\n//# sourceMappingURL=bundle-T6fVCCb7.js.map\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module"}