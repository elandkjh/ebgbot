{"ast":null,"code":"import { useCallback } from 'react';\nimport DOMPurify from 'dompurify';\nimport { a as NodeNames, N as NodeTypes } from './bundle-0qSTzMXb.js';\nimport { U as USER_MENTION_TEMP_CHAR } from './bundle-CveCFQYP.js';\nimport { c as __spreadArray } from './bundle-BQi9-O76.js';\nimport { M as MENTION_USER_LABEL_CLASSNAME } from './bundle-0nQK2G2O.js';\nimport { T as TEXT_MESSAGE_BODY_CLASSNAME } from './bundle-B6edg1g0.js';\nimport { O as OG_MESSAGE_BODY_CLASSNAME } from './bundle-DhGZA5UP.js';\nfunction renderToString(_a) {\n  var userId = _a.userId,\n    nickname = _a.nickname;\n  // donot change this template, it wont work\n  var el = \"<span data-userid=\\\"\".concat(userId, \"\\\" data-sb-mention=\\\"true\\\" class=\\\"\").concat(MENTION_USER_LABEL_CLASSNAME, \"\\\">\").concat(nickname, \"</span>\");\n  var purifier = DOMPurify(window);\n  var sanitized_ = purifier.sanitize(el);\n  var token = sanitized_.split(' ');\n  var spanTag = token[0],\n    rest = token.slice(1);\n  // we do this because DOMPurify removes the contenteditable attribute\n  var sanitized = __spreadArray([spanTag, 'contenteditable=\"false\"'], rest, true).join(' ');\n  return sanitized;\n}\nvar sanitizeString = function (str) {\n  return str === null || str === void 0 ? void 0 : str.replace(/[\\u00A0-\\u9999<>]/gim, function (i) {\n    return ''.concat('&#', String(i.charCodeAt(0)), ';');\n  });\n};\n/**\n * NodeList cannot be used with Array methods\n * @param {NodeListOf<ChildNode>} childNodes\n * @returns Array of child nodes\n */\nvar nodeListToArray = function (childNodes) {\n  return childNodes ? Array.from(childNodes) : [];\n};\nfunction isChannelTypeSupportsMultipleFilesMessage(channel) {\n  var _a;\n  return channel && ((_a = channel.isGroupChannel) === null || _a === void 0 ? void 0 : _a.call(channel)) && !channel.isBroadcast && !channel.isSuper;\n}\n// Type guard: This function ensures that the node contains `innerText` and `dataset` properties\nfunction isHTMLElement(node) {\n  return node.nodeType === NodeTypes.ElementNode;\n}\n// eslint-disable-next-line no-undef\nfunction extractTextAndMentions(childNodes) {\n  var messageText = '';\n  var mentionTemplate = '';\n  childNodes.forEach(function (node) {\n    if (isHTMLElement(node) && node.nodeName === NodeNames.Span) {\n      var innerText = node.innerText,\n        _a = node.dataset,\n        dataset = _a === void 0 ? {} : _a;\n      var _b = dataset.userid,\n        userid = _b === void 0 ? '' : _b;\n      messageText += innerText;\n      mentionTemplate += \"\".concat(USER_MENTION_TEMP_CHAR, \"{\").concat(userid, \"}\");\n    } else if (isHTMLElement(node) && node.nodeName === NodeNames.Br) {\n      messageText += '\\n';\n      mentionTemplate += '\\n';\n    } else if (isHTMLElement(node) && node.nodeName === NodeNames.Div) {\n      var _c = node.textContent,\n        textContent = _c === void 0 ? '' : _c;\n      messageText += \"\\n\".concat(textContent);\n      mentionTemplate += \"\\n\".concat(textContent);\n    } else {\n      var _d = node.textContent,\n        textContent = _d === void 0 ? '' : _d;\n      messageText += textContent;\n      mentionTemplate += textContent;\n    }\n  });\n  return {\n    messageText: messageText,\n    mentionTemplate: mentionTemplate\n  };\n}\nfunction inserTemplateToDOM(templateList) {\n  var nodes = templateList.map(function (template) {\n    var text = template.text,\n      userId = template.userId;\n    if (userId) {\n      return renderToString({\n        userId: userId,\n        nickname: text\n      });\n    }\n    return sanitizeString(text);\n  }).join(' ')\n  // add a space at the end of the mention, else cursor/caret wont work\n  .concat(' ');\n  document.execCommand('insertHTML', false, nodes);\n}\nvar PASTE_NODE = 'sendbird-uikit__paste-node';\nvar TEXT_MESSAGE_CLASS = 'sendbird-word';\nvar MENTION_CLASS = 'sendbird-word__mention';\nvar MENTION_CLASS_IN_INPUT = 'sendbird-mention-user-label';\nvar MENTION_CLASS_COMBINED_QUERY = \".\".concat(MENTION_CLASS, \", .\").concat(MENTION_CLASS_IN_INPUT);\nfunction querySelectorIncludingSelf(master, selector) {\n  var result = __spreadArray([master], Array.from(master.querySelectorAll(selector)), true).find(function (el) {\n    return el.matches(selector);\n  });\n  return result;\n}\n// Pasted dom node can be OG_MESSAGE or partial message or full message\n// full messsage would have TEXT_MESSAGE_BODY_CLASSNAME and have childNodes\n// partial message would not have TEXT_MESSAGE_BODY_CLASSNAME\nfunction getLeafNodes(master) {\n  // og message\n  var ogMessage = querySelectorIncludingSelf(master, \".\".concat(OG_MESSAGE_BODY_CLASSNAME));\n  if (ogMessage) {\n    return nodeListToArray(ogMessage.childNodes);\n  }\n  var textMessageBody = querySelectorIncludingSelf(master, \".\".concat(TEXT_MESSAGE_BODY_CLASSNAME));\n  if (textMessageBody) {\n    return nodeListToArray(textMessageBody.childNodes);\n  }\n  return nodeListToArray(master.childNodes);\n}\nfunction createPasteNode() {\n  var pasteNode = document.body.querySelector(\"#\".concat(PASTE_NODE));\n  // remove existing paste node\n  if (pasteNode) {\n    pasteNode === null || pasteNode === void 0 ? void 0 : pasteNode.remove();\n  }\n  // create new paste node and return\n  var node = document.createElement('div');\n  node.id = PASTE_NODE;\n  node.style.display = 'none';\n  return node;\n}\nfunction hasMention(parent) {\n  return (parent === null || parent === void 0 ? void 0 : parent.querySelector(MENTION_CLASS_COMBINED_QUERY)) ? true : false;\n}\nvar extractTextFromNodes = function (nodes) {\n  var text = '';\n  nodes.forEach(function (node) {\n    // to preserve space between words\n    var textNodes = node.querySelectorAll(\".\".concat(TEXT_MESSAGE_CLASS));\n    if (textNodes.length > 0) {\n      text += extractTextFromNodes(Array.from(textNodes)) + ' ';\n    }\n    text += node.innerText + ' ';\n  });\n  return text;\n};\nfunction domToMessageTemplate(nodeArray) {\n  var templates = nodeArray === null || nodeArray === void 0 ? void 0 : nodeArray.reduce(function (accumulator, currentValue) {\n    var _a, _b;\n    // currentValue can be node(from messageBody or messageInput) or text\n    var mentionNode;\n    // this looks awkward, but it is a fallback to set default text\n    var text = currentValue === null || currentValue === void 0 ? void 0 : currentValue.innerText;\n    // if text node, set text\n    if (currentValue instanceof Text) {\n      mentionNode = false;\n      text = (_a = currentValue.textContent) !== null && _a !== void 0 ? _a : '';\n    }\n    if (currentValue instanceof HTMLElement) {\n      mentionNode = currentValue.classList.contains(MENTION_CLASS) || currentValue.classList.contains(MENTION_CLASS_IN_INPUT) ? currentValue : currentValue.querySelector(MENTION_CLASS_COMBINED_QUERY);\n    }\n    // if mentionNode is not null, it is a mention\n    if (mentionNode) {\n      var text_1 = currentValue === null || currentValue === void 0 ? void 0 : currentValue.innerText;\n      var userId = (_b = mentionNode.dataset) === null || _b === void 0 ? void 0 : _b.userid;\n      return __spreadArray(__spreadArray([], accumulator, true), [{\n        text: text_1,\n        userId: userId\n      }], false);\n    }\n    return __spreadArray(__spreadArray([], accumulator, true), [{\n      text: text\n    }], false);\n  }, []);\n  return templates;\n}\nfunction getUsersFromWords(templates, channel) {\n  var userMap = {};\n  var users = channel.members;\n  templates.forEach(function (template) {\n    if (template.userId) {\n      var mentionedMember = users.find(function (user) {\n        return user.userId === template.userId;\n      });\n      // Object.values would return array-> [undefined] if the user is not in the channel\n      if (mentionedMember) {\n        userMap[template.userId] = mentionedMember;\n      }\n    }\n  });\n  return Object.values(userMap);\n}\n\n// exported, should be backward compatible\n// conditions to test:\n// 1. paste simple text\n// 2. paste text with mention\n// 3. paste text with mention and text\n// 4. paste text with mention and text and paste again before and after\n// 5. copy message with mention(only one mention, no other text) and paste\n// 6. copy message with mention from input and paste(before and after)\nfunction usePaste(_a) {\n  var ref = _a.ref,\n    setIsInput = _a.setIsInput,\n    setHeight = _a.setHeight,\n    channel = _a.channel,\n    setMentionedUsers = _a.setMentionedUsers;\n  return useCallback(function (e) {\n    e.preventDefault();\n    var html = e.clipboardData.getData('text/html');\n    // simple text, continue as normal\n    if (!html) {\n      var text = e.clipboardData.getData('text') || getURIListText(e);\n      document.execCommand('insertHTML', false, sanitizeString(text));\n      setIsInput(true);\n      setHeight();\n      return;\n    }\n    // has html, check if there are mentions, sanitize and insert\n    var purifier = DOMPurify(window);\n    var clean = purifier.sanitize(html);\n    var pasteNode = createPasteNode();\n    if (pasteNode) {\n      pasteNode.innerHTML = clean;\n      // does not have mention, continue as normal\n      if (!hasMention(pasteNode)) {\n        // to preserve space between words\n        var text = extractTextFromNodes(Array.from(pasteNode.children));\n        document.execCommand('insertHTML', false, sanitizeString(text));\n        pasteNode.remove();\n        setIsInput(true);\n        setHeight();\n        return;\n      }\n      // has mention, collect leaf nodes and parse words\n      var leafNodes = getLeafNodes(pasteNode);\n      var words = domToMessageTemplate(leafNodes);\n      var mentionedUsers = channel.isGroupChannel() ? getUsersFromWords(words, channel) : [];\n      // side effects\n      setMentionedUsers(mentionedUsers);\n      inserTemplateToDOM(words);\n      pasteNode.remove();\n    }\n    setIsInput(true);\n    setHeight();\n  }, [ref, setIsInput, setHeight, channel, setMentionedUsers]);\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Recommended_drag_types#dragging_links\nfunction getURIListText(e) {\n  var pasteData = e.clipboardData.getData('text/uri-list');\n  if (pasteData.length === 0) return '';\n  return pasteData.split('\\n').reduce(function (accumulator, line) {\n    var txt = line.trim();\n    if (txt !== '' && !txt.startsWith('#')) {\n      accumulator += txt + '\\n';\n    }\n    return accumulator;\n  }, '');\n}\nexport { extractTextAndMentions as e, isChannelTypeSupportsMultipleFilesMessage as i, nodeListToArray as n, renderToString as r, sanitizeString as s, usePaste as u };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import { useCallback } from 'react';\nimport DOMPurify from 'dompurify';\nimport { a as NodeNames, N as NodeTypes } from './bundle-0qSTzMXb.js';\nimport { U as USER_MENTION_TEMP_CHAR } from './bundle-CveCFQYP.js';\nimport { c as __spreadArray } from './bundle-BQi9-O76.js';\nimport { M as MENTION_USER_LABEL_CLASSNAME } from './bundle-0nQK2G2O.js';\nimport { T as TEXT_MESSAGE_BODY_CLASSNAME } from './bundle-B6edg1g0.js';\nimport { O as OG_MESSAGE_BODY_CLASSNAME } from './bundle-DhGZA5UP.js';\n\nfunction renderToString(_a) {\n    var userId = _a.userId, nickname = _a.nickname;\n    // donot change this template, it wont work\n    var el = \"<span data-userid=\\\"\".concat(userId, \"\\\" data-sb-mention=\\\"true\\\" class=\\\"\").concat(MENTION_USER_LABEL_CLASSNAME, \"\\\">\").concat(nickname, \"</span>\");\n    var purifier = DOMPurify(window);\n    var sanitized_ = purifier.sanitize(el);\n    var token = sanitized_.split(' ');\n    var spanTag = token[0], rest = token.slice(1);\n    // we do this because DOMPurify removes the contenteditable attribute\n    var sanitized = __spreadArray([spanTag, 'contenteditable=\"false\"'], rest, true).join(' ');\n    return sanitized;\n}\n\nvar sanitizeString = function (str) {\n    return str === null || str === void 0 ? void 0 : str.replace(/[\\u00A0-\\u9999<>]/gim, function (i) { return ''.concat('&#', String(i.charCodeAt(0)), ';'); });\n};\n/**\n * NodeList cannot be used with Array methods\n * @param {NodeListOf<ChildNode>} childNodes\n * @returns Array of child nodes\n */\nvar nodeListToArray = function (childNodes) {\n    return childNodes ? Array.from(childNodes) : [];\n};\nfunction isChannelTypeSupportsMultipleFilesMessage(channel) {\n    var _a;\n    return channel && ((_a = channel.isGroupChannel) === null || _a === void 0 ? void 0 : _a.call(channel)) && !channel.isBroadcast && !channel.isSuper;\n}\n// Type guard: This function ensures that the node contains `innerText` and `dataset` properties\nfunction isHTMLElement(node) {\n    return node.nodeType === NodeTypes.ElementNode;\n}\n// eslint-disable-next-line no-undef\nfunction extractTextAndMentions(childNodes) {\n    var messageText = '';\n    var mentionTemplate = '';\n    childNodes.forEach(function (node) {\n        if (isHTMLElement(node) && node.nodeName === NodeNames.Span) {\n            var innerText = node.innerText, _a = node.dataset, dataset = _a === void 0 ? {} : _a;\n            var _b = dataset.userid, userid = _b === void 0 ? '' : _b;\n            messageText += innerText;\n            mentionTemplate += \"\".concat(USER_MENTION_TEMP_CHAR, \"{\").concat(userid, \"}\");\n        }\n        else if (isHTMLElement(node) && node.nodeName === NodeNames.Br) {\n            messageText += '\\n';\n            mentionTemplate += '\\n';\n        }\n        else if (isHTMLElement(node) && node.nodeName === NodeNames.Div) {\n            var _c = node.textContent, textContent = _c === void 0 ? '' : _c;\n            messageText += \"\\n\".concat(textContent);\n            mentionTemplate += \"\\n\".concat(textContent);\n        }\n        else {\n            var _d = node.textContent, textContent = _d === void 0 ? '' : _d;\n            messageText += textContent;\n            mentionTemplate += textContent;\n        }\n    });\n    return { messageText: messageText, mentionTemplate: mentionTemplate };\n}\n\nfunction inserTemplateToDOM(templateList) {\n    var nodes = templateList.map(function (template) {\n        var text = template.text, userId = template.userId;\n        if (userId) {\n            return renderToString({ userId: userId, nickname: text });\n        }\n        return sanitizeString(text);\n    })\n        .join(' ')\n        // add a space at the end of the mention, else cursor/caret wont work\n        .concat(' ');\n    document.execCommand('insertHTML', false, nodes);\n}\n\nvar PASTE_NODE = 'sendbird-uikit__paste-node';\nvar TEXT_MESSAGE_CLASS = 'sendbird-word';\nvar MENTION_CLASS = 'sendbird-word__mention';\nvar MENTION_CLASS_IN_INPUT = 'sendbird-mention-user-label';\nvar MENTION_CLASS_COMBINED_QUERY = \".\".concat(MENTION_CLASS, \", .\").concat(MENTION_CLASS_IN_INPUT);\n\nfunction querySelectorIncludingSelf(master, selector) {\n    var result = __spreadArray([\n        master\n    ], Array.from(master.querySelectorAll(selector)), true).find(function (el) { return el.matches(selector); });\n    return result;\n}\n// Pasted dom node can be OG_MESSAGE or partial message or full message\n// full messsage would have TEXT_MESSAGE_BODY_CLASSNAME and have childNodes\n// partial message would not have TEXT_MESSAGE_BODY_CLASSNAME\nfunction getLeafNodes(master) {\n    // og message\n    var ogMessage = querySelectorIncludingSelf(master, \".\".concat(OG_MESSAGE_BODY_CLASSNAME));\n    if (ogMessage) {\n        return nodeListToArray(ogMessage.childNodes);\n    }\n    var textMessageBody = querySelectorIncludingSelf(master, \".\".concat(TEXT_MESSAGE_BODY_CLASSNAME));\n    if (textMessageBody) {\n        return nodeListToArray(textMessageBody.childNodes);\n    }\n    return nodeListToArray(master.childNodes);\n}\nfunction createPasteNode() {\n    var pasteNode = document.body.querySelector(\"#\".concat(PASTE_NODE));\n    // remove existing paste node\n    if (pasteNode) {\n        pasteNode === null || pasteNode === void 0 ? void 0 : pasteNode.remove();\n    }\n    // create new paste node and return\n    var node = document.createElement('div');\n    node.id = PASTE_NODE;\n    node.style.display = 'none';\n    return node;\n}\nfunction hasMention(parent) {\n    return (parent === null || parent === void 0 ? void 0 : parent.querySelector(MENTION_CLASS_COMBINED_QUERY)) ? true : false;\n}\nvar extractTextFromNodes = function (nodes) {\n    var text = '';\n    nodes.forEach(function (node) {\n        // to preserve space between words\n        var textNodes = node.querySelectorAll(\".\".concat(TEXT_MESSAGE_CLASS));\n        if (textNodes.length > 0) {\n            text += ((extractTextFromNodes(Array.from(textNodes))) + ' ');\n        }\n        text += (node.innerText + ' ');\n    });\n    return text;\n};\nfunction domToMessageTemplate(nodeArray) {\n    var templates = nodeArray === null || nodeArray === void 0 ? void 0 : nodeArray.reduce(function (accumulator, currentValue) {\n        var _a, _b;\n        // currentValue can be node(from messageBody or messageInput) or text\n        var mentionNode;\n        // this looks awkward, but it is a fallback to set default text\n        var text = currentValue === null || currentValue === void 0 ? void 0 : currentValue.innerText;\n        // if text node, set text\n        if (currentValue instanceof Text) {\n            mentionNode = false;\n            text = (_a = currentValue.textContent) !== null && _a !== void 0 ? _a : '';\n        }\n        if (currentValue instanceof HTMLElement) {\n            mentionNode = (currentValue.classList.contains(MENTION_CLASS) || currentValue.classList.contains(MENTION_CLASS_IN_INPUT))\n                ? currentValue\n                : currentValue.querySelector(MENTION_CLASS_COMBINED_QUERY);\n        }\n        // if mentionNode is not null, it is a mention\n        if (mentionNode) {\n            var text_1 = currentValue === null || currentValue === void 0 ? void 0 : currentValue.innerText;\n            var userId = (_b = mentionNode.dataset) === null || _b === void 0 ? void 0 : _b.userid;\n            return __spreadArray(__spreadArray([], accumulator, true), [\n                {\n                    text: text_1,\n                    userId: userId,\n                },\n            ], false);\n        }\n        return __spreadArray(__spreadArray([], accumulator, true), [\n            {\n                text: text,\n            },\n        ], false);\n    }, []);\n    return templates;\n}\nfunction getUsersFromWords(templates, channel) {\n    var userMap = {};\n    var users = channel.members;\n    templates.forEach(function (template) {\n        if (template.userId) {\n            var mentionedMember = users.find(function (user) { return user.userId === template.userId; });\n            // Object.values would return array-> [undefined] if the user is not in the channel\n            if (mentionedMember) {\n                userMap[template.userId] = mentionedMember;\n            }\n        }\n    });\n    return Object.values(userMap);\n}\n\n// exported, should be backward compatible\n// conditions to test:\n// 1. paste simple text\n// 2. paste text with mention\n// 3. paste text with mention and text\n// 4. paste text with mention and text and paste again before and after\n// 5. copy message with mention(only one mention, no other text) and paste\n// 6. copy message with mention from input and paste(before and after)\nfunction usePaste(_a) {\n    var ref = _a.ref, setIsInput = _a.setIsInput, setHeight = _a.setHeight, channel = _a.channel, setMentionedUsers = _a.setMentionedUsers;\n    return useCallback(function (e) {\n        e.preventDefault();\n        var html = e.clipboardData.getData('text/html');\n        // simple text, continue as normal\n        if (!html) {\n            var text = e.clipboardData.getData('text') || getURIListText(e);\n            document.execCommand('insertHTML', false, sanitizeString(text));\n            setIsInput(true);\n            setHeight();\n            return;\n        }\n        // has html, check if there are mentions, sanitize and insert\n        var purifier = DOMPurify(window);\n        var clean = purifier.sanitize(html);\n        var pasteNode = createPasteNode();\n        if (pasteNode) {\n            pasteNode.innerHTML = clean;\n            // does not have mention, continue as normal\n            if (!hasMention(pasteNode)) {\n                // to preserve space between words\n                var text = extractTextFromNodes(Array.from(pasteNode.children));\n                document.execCommand('insertHTML', false, sanitizeString(text));\n                pasteNode.remove();\n                setIsInput(true);\n                setHeight();\n                return;\n            }\n            // has mention, collect leaf nodes and parse words\n            var leafNodes = getLeafNodes(pasteNode);\n            var words = domToMessageTemplate(leafNodes);\n            var mentionedUsers = channel.isGroupChannel() ? getUsersFromWords(words, channel) : [];\n            // side effects\n            setMentionedUsers(mentionedUsers);\n            inserTemplateToDOM(words);\n            pasteNode.remove();\n        }\n        setIsInput(true);\n        setHeight();\n    }, [ref, setIsInput, setHeight, channel, setMentionedUsers]);\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API/Recommended_drag_types#dragging_links\nfunction getURIListText(e) {\n    var pasteData = e.clipboardData.getData('text/uri-list');\n    if (pasteData.length === 0)\n        return '';\n    return pasteData\n        .split('\\n')\n        .reduce(function (accumulator, line) {\n        var txt = line.trim();\n        if (txt !== '' && !txt.startsWith('#')) {\n            accumulator += txt + '\\n';\n        }\n        return accumulator;\n    }, '');\n}\n\nexport { extractTextAndMentions as e, isChannelTypeSupportsMultipleFilesMessage as i, nodeListToArray as n, renderToString as r, sanitizeString as s, usePaste as u };\n//# sourceMappingURL=bundle-TZQ6dJCG.js.map\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module"}