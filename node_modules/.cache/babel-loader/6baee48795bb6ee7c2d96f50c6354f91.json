{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { useEffect, useLayoutEffect, useRef } from 'react';\nimport { CollectionEventSource } from '@sendbird/chat';\nimport { MessageCollectionInitPolicy, MessageFilter } from '@sendbird/chat/groupChannel';\nimport { ReplyType } from '@sendbird/chat/message';\nimport { sbuConstants } from '../../constants/sbuConstants.js';\nimport { isDifferentChannel } from '../../utils/channel.js';\nimport { isMyMessage, isSendableMessage } from '../../utils/message.js';\nimport { isNotEmptyArray } from '../../utils/validators.js';\nimport { useAsyncEffect } from '../useAsyncEffect.js';\nimport { useForceUpdate } from '../useForceUpdate.js';\nimport { useGroupChannelHandler } from '../useGroupChannelHandler.js';\nimport { usePreservedCallback } from '../usePreservedCallback.js';\nimport { useChannelThreadMessagesReducer } from './reducer.js';\nfunction isThreadedMessage(message, parentMessage) {\n  return message.parentMessageId === parentMessage.messageId;\n}\nexport const useGroupChannelThreadMessages = function (sdk, channel, parentMessage) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _a, _b, _c, _d, _e;\n  const internalOptions = useRef(options); // to keep reference of options in event handler\n  internalOptions.current = options;\n  const channelRef = useRef(channel); // to keep reference of channel in event handler\n  channelRef.current = channel;\n  const parentMessageRef = useRef(parentMessage); // to keep reference of parent message in event handler\n  parentMessageRef.current = parentMessage;\n  const startingPoint = useRef(((_a = internalOptions.current) === null || _a === void 0 ? void 0 : _a.startingPoint) || Number.MAX_SAFE_INTEGER);\n  startingPoint.current = ((_b = internalOptions.current) === null || _b === void 0 ? void 0 : _b.startingPoint) || Number.MAX_SAFE_INTEGER;\n  const prevFetchSize = sbuConstants.collection.message.defaultLimit.prev;\n  const nextFetchSize = sbuConstants.collection.message.defaultLimit.next;\n  const logger = internalOptions.current.logger;\n  const isFetching = useRef({\n    prev: false,\n    next: false\n  });\n  const forceUpdate = useForceUpdate();\n  const collectionRef = useRef({\n    initialized: false,\n    apiInitialized: false,\n    instance: null\n  });\n  const {\n    initialized,\n    loading,\n    refreshing,\n    hasPreviousMessages,\n    hasNextMessages,\n    oldestMessageTimeStamp,\n    latestMessageTimeStamp,\n    messages,\n    newMessages,\n    updateMessages,\n    updateNewMessages,\n    deleteNewMessages,\n    deleteMessages,\n    updateInitialized,\n    updateLoading,\n    updateRefreshing,\n    updateHasPreviousMessages,\n    updateHasNextMessages\n  } = useChannelThreadMessagesReducer(options === null || options === void 0 ? void 0 : options.sortComparator);\n  const markAsReadBySource = usePreservedCallback(source => {\n    var _a, _b, _c, _d;\n    if (!channelRef.current || !channelRef.current.url) {\n      return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n    }\n    try {\n      switch (source) {\n        case CollectionEventSource.EVENT_MESSAGE_RECEIVED:\n        case CollectionEventSource.EVENT_MESSAGE_SENT_SUCCESS:\n        case CollectionEventSource.SYNC_MESSAGE_FILL:\n        case undefined:\n          (_c = (_b = internalOptions.current).markAsRead) === null || _c === void 0 ? void 0 : _c.call(_b, [channelRef.current]);\n          break;\n      }\n    } catch (e) {\n      (_d = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _d === void 0 ? void 0 : _d.call(logger, '[useGroupChannelThreadMessages/markAsReadBySource]', e);\n    }\n  });\n  const updateNewMessagesReceived = usePreservedCallback((source, messages) => {\n    var _a, _b, _c, _d, _e;\n    const incomingMessages = messages.filter(it => {\n      var _a;\n      return isThreadedMessage(it, parentMessageRef.current) && !isMyMessage(it, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n    });\n    if (incomingMessages.length > 0) {\n      switch (source) {\n        case CollectionEventSource.EVENT_MESSAGE_RECEIVED:\n        case CollectionEventSource.SYNC_MESSAGE_FILL:\n          {\n            if ((_b = (_a = internalOptions.current).shouldCountNewMessages) === null || _b === void 0 ? void 0 : _b.call(_a)) {\n              updateNewMessages(incomingMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n            }\n            (_e = (_d = internalOptions.current).onMessagesReceived) === null || _e === void 0 ? void 0 : _e.call(_d, incomingMessages);\n            break;\n          }\n      }\n    }\n  });\n  useAsyncEffect(() => __awaiter(void 0, void 0, void 0, function* () {\n    var _f, _g, _h, _j, _k;\n    const messages = yield (_f = channelRef.current) === null || _f === void 0 ? void 0 : _f.getMessagesByMessageId((_g = parentMessageRef.current) === null || _g === void 0 ? void 0 : _g.messageId, {\n      prevResultSize: 1,\n      nextResultSize: 1,\n      isInclusive: true,\n      includeThreadInfo: true,\n      includeMetaArray: true,\n      includeReactions: (_h = internalOptions.current.isReactionEnabled) !== null && _h !== void 0 ? _h : false\n    });\n    const parentMessage = messages === null || messages === void 0 ? void 0 : messages.find(message => {\n      return message.messageId === parentMessageRef.current.messageId;\n    });\n    if (parentMessage) {\n      parentMessageRef.current = parentMessage;\n      (_k = (_j = internalOptions.current).onParentMessageUpdated) === null || _k === void 0 ? void 0 : _k.call(_j, parentMessage);\n    }\n  }), [(_c = channelRef.current) === null || _c === void 0 ? void 0 : _c.url, internalOptions.current.isReactionEnabled]);\n  const init = usePreservedCallback(startingPoint => __awaiter(void 0, void 0, void 0, function* () {\n    return new Promise(resolve => {\n      var _a, _b, _c;\n      if (!channelRef.current || !channelRef.current.url) {\n        return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      }\n      if (!parentMessageRef.current) {\n        return (_b = logger === null || logger === void 0 ? void 0 : logger.error) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelThreadMessages] parent message is required');\n      }\n      if (collectionRef.current.instance) collectionRef.current.instance.dispose();\n      markAsReadBySource();\n      updateNewMessages([], true, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n      const updateUnsentMessages = () => {\n        var _a, _b;\n        const {\n          pendingMessages,\n          failedMessages\n        } = (_a = collectionRef.current.instance) !== null && _a !== void 0 ? _a : {};\n        let filteredMessages;\n        if (isNotEmptyArray(pendingMessages)) {\n          filteredMessages = pendingMessages.filter(message => isThreadedMessage(message, parentMessageRef.current));\n        }\n        if (isNotEmptyArray(failedMessages)) {\n          filteredMessages = failedMessages.filter(message => isThreadedMessage(message, parentMessageRef.current));\n        }\n        if (isNotEmptyArray(filteredMessages)) updateMessages(filteredMessages, false, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId);\n      };\n      setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {\n        var _d, _e, _f, _g;\n        try {\n          if (parentMessageRef.current) {\n            const params = {\n              prevResultSize: prevFetchSize,\n              nextResultSize: nextFetchSize,\n              isInclusive: true,\n              includeReactions: (_d = internalOptions.current.isReactionEnabled) !== null && _d !== void 0 ? _d : false\n            };\n            const {\n              threadedMessages\n            } = yield parentMessageRef.current.getThreadedMessagesByTimestamp(startingPoint, params);\n            if (isNotEmptyArray(threadedMessages)) {\n              const prevMessagesCount = threadedMessages.filter(message => message.createdAt < startingPoint).length;\n              const nextMessagesCount = threadedMessages.filter(message => message.createdAt > startingPoint).length;\n              updateHasPreviousMessages(prevMessagesCount >= prevFetchSize);\n              updateHasNextMessages(nextMessagesCount >= nextFetchSize);\n              updateMessages(threadedMessages, true, (_e = sdk.currentUser) === null || _e === void 0 ? void 0 : _e.userId);\n            }\n          } else {\n            (_f = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _f === void 0 ? void 0 : _f.call(logger, '[useGroupChannelThreadMessages] parent message is required');\n          }\n          resolve();\n        } catch (error) {\n          (_g = logger === null || logger === void 0 ? void 0 : logger.error) === null || _g === void 0 ? void 0 : _g.call(logger, '[useGroupChannelThreadMessages] Initialize thread list failed.', error);\n        }\n      }));\n      const collectionInstance = channelRef.current.createMessageCollection({\n        prevResultLimit: prevFetchSize,\n        nextResultLimit: nextFetchSize,\n        startingPoint: startingPoint - 1,\n        filter: new MessageFilter({\n          replyType: ReplyType.ALL\n        })\n      });\n      collectionRef.current = {\n        apiInitialized: false,\n        initialized: false,\n        instance: collectionInstance\n      };\n      collectionInstance.setMessageCollectionHandler({\n        onMessagesAdded: (ctx, __, messages) => {\n          var _a;\n          const filteredMessages = messages.filter(message => isThreadedMessage(message, parentMessageRef.current));\n          if (isNotEmptyArray(filteredMessages)) {\n            markAsReadBySource(ctx.source);\n            updateNewMessagesReceived(ctx.source, filteredMessages);\n            updateMessages(filteredMessages, false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n          }\n        },\n        onMessagesUpdated: (ctx, __, messages) => {\n          var _a, _b, _c, _d, _e;\n          const filteredMessages = messages.filter(message => isThreadedMessage(message, parentMessageRef.current));\n          const parentMessage = messages.find(message => message.messageId === parentMessageRef.current.messageId);\n          if (parentMessage) {\n            parentMessageRef.current = parentMessage;\n            (_b = (_a = internalOptions.current).onParentMessageUpdated) === null || _b === void 0 ? void 0 : _b.call(_a, parentMessage);\n          }\n          if (isNotEmptyArray(filteredMessages)) {\n            markAsReadBySource(ctx.source);\n            updateNewMessagesReceived(ctx.source, filteredMessages); // NOTE: admin message is not added via onMessagesAdded handler, not checked yet is this a bug.\n            updateMessages(filteredMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n            if (ctx.source === CollectionEventSource.EVENT_MESSAGE_UPDATED) {\n              (_e = (_d = internalOptions.current).onMessagesUpdated) === null || _e === void 0 ? void 0 : _e.call(_d, filteredMessages);\n            }\n          }\n        },\n        onMessagesDeleted: (_, __, ___, messages) => {\n          var _a, _b;\n          const parentMessage = messages.find(message => message.messageId === parentMessageRef.current.messageId);\n          if (parentMessage) {\n            (_b = (_a = internalOptions.current).onParentMessageDeleted) === null || _b === void 0 ? void 0 : _b.call(_a);\n          }\n          const filteredMessages = messages.filter(message => isThreadedMessage(message, parentMessageRef.current));\n          if (isNotEmptyArray(filteredMessages)) {\n            const msgIds = filteredMessages.map(it => it.messageId);\n            const reqIds = filteredMessages.filter(isSendableMessage).map(it => it.reqId);\n            deleteMessages(msgIds, reqIds);\n            deleteNewMessages(msgIds, reqIds);\n          }\n        },\n        onChannelDeleted: (_, channelUrl) => {\n          var _a, _b;\n          (_b = (_a = internalOptions.current).onChannelDeleted) === null || _b === void 0 ? void 0 : _b.call(_a, channelUrl);\n        },\n        onChannelUpdated: (_, channel) => {\n          var _a, _b;\n          forceUpdate();\n          (_b = (_a = internalOptions.current).onChannelUpdated) === null || _b === void 0 ? void 0 : _b.call(_a, channel);\n        },\n        onHugeGapDetected: () => {\n          init(startingPoint);\n        }\n      });\n      collectionInstance.initialize(MessageCollectionInitPolicy.CACHE_AND_REPLACE_BY_API).onCacheResult((err, messages) => {\n        var _a, _b, _c;\n        if (err) {\n          sdk.isCacheEnabled && ((_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages/onCacheResult]', err));\n        } else if (messages) {\n          (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelThreadMessages/onCacheResult]', 'message length:', messages.length);\n          const filteredMessages = messages.filter(message => isThreadedMessage(message, parentMessageRef.current));\n          if (isNotEmptyArray(filteredMessages)) {\n            updateMessages(filteredMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n            updateUnsentMessages();\n          }\n        }\n      }).onApiResult((err, messages) => {\n        var _a, _b, _c;\n        if (err) {\n          (_a = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages/onApiResult]', err);\n        } else if (messages) {\n          (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelThreadMessages/onApiResult]', 'message length:', messages.length);\n          const filteredMessages = messages.filter(message => isThreadedMessage(message, parentMessageRef.current));\n          if (isNotEmptyArray(filteredMessages)) {\n            updateMessages(filteredMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n            if (sdk.isCacheEnabled) updateUnsentMessages();\n          }\n        }\n        collectionRef.current.initialized = true;\n        collectionRef.current.apiInitialized = true;\n      });\n    });\n  }));\n  useGroupChannelHandler(sdk, {\n    onUserBanned(eventChannel, bannedUser) {\n      var _a, _b, _c;\n      if (eventChannel.isGroupChannel() && !isDifferentChannel(eventChannel, channelRef.current)) {\n        if (bannedUser.userId === ((_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId)) {\n          (_c = (_b = internalOptions.current).onCurrentUserBanned) === null || _c === void 0 ? void 0 : _c.call(_b);\n        } else {\n          forceUpdate();\n        }\n      }\n    }\n  });\n  useLayoutEffect(() => {\n    const timeout = setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {\n      if (sdk.currentUser && channelRef.current) {\n        updateInitialized(false);\n        updateLoading(true);\n        yield init(startingPoint.current);\n        updateLoading(false);\n        updateInitialized(true);\n      }\n    }));\n    return () => clearTimeout(timeout);\n  }, [sdk, (_d = sdk.currentUser) === null || _d === void 0 ? void 0 : _d.userId, (_e = channelRef.current) === null || _e === void 0 ? void 0 : _e.url, startingPoint.current]);\n  useEffect(() => {\n    return () => {\n      if (collectionRef.current.instance) collectionRef.current.instance.dispose();\n    };\n  }, []);\n  const refresh = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n    if (sdk.currentUser && channelRef.current) {\n      updateRefreshing(true);\n      yield init(startingPoint.current);\n      updateRefreshing(false);\n    }\n  }));\n  const loadPrevious = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n    var _l, _m, _o, _p;\n    if (!channelRef.current || !channelRef.current.url || !parentMessageRef.current) {\n      (_l = logger === null || logger === void 0 ? void 0 : logger.error) === null || _l === void 0 ? void 0 : _l.call(logger, '[useGroupChannelThreadMessages] channel or parent message is required');\n      return;\n    }\n    if (hasPreviousMessages && !isFetching.current.prev) {\n      try {\n        isFetching.current.prev = true;\n        const params = {\n          prevResultSize: prevFetchSize,\n          nextResultSize: 0,\n          isInclusive: false,\n          includeReactions: (_m = internalOptions.current.isReactionEnabled) !== null && _m !== void 0 ? _m : false\n        };\n        const {\n          threadedMessages\n        } = yield parentMessageRef.current.getThreadedMessagesByTimestamp(oldestMessageTimeStamp, params);\n        if (isNotEmptyArray(threadedMessages)) {\n          updateHasPreviousMessages(threadedMessages.length >= prevFetchSize);\n          updateMessages(threadedMessages, false, (_o = sdk.currentUser) === null || _o === void 0 ? void 0 : _o.userId);\n        }\n      } catch (error) {\n        (_p = logger === null || logger === void 0 ? void 0 : logger.error) === null || _p === void 0 ? void 0 : _p.call(logger, '[useGroupChannelThreadMessages] loadPrevious thread list failed.', error);\n      } finally {\n        isFetching.current.prev = false;\n      }\n    }\n  }));\n  const hasPrevious = usePreservedCallback(() => {\n    return hasPreviousMessages;\n  });\n  const loadNext = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n    var _q, _r, _s, _t;\n    if (!channelRef.current || !channelRef.current.url || !parentMessageRef.current) {\n      (_q = logger === null || logger === void 0 ? void 0 : logger.error) === null || _q === void 0 ? void 0 : _q.call(logger, '[useGroupChannelThreadMessages] channel or parent message is required');\n      return;\n    }\n    if (hasNextMessages && !isFetching.current.next) {\n      try {\n        isFetching.current.prev = true;\n        const params = {\n          prevResultSize: 0,\n          nextResultSize: nextFetchSize,\n          isInclusive: false,\n          includeReactions: (_r = internalOptions.current.isReactionEnabled) !== null && _r !== void 0 ? _r : false\n        };\n        const {\n          threadedMessages\n        } = yield parentMessageRef.current.getThreadedMessagesByTimestamp(latestMessageTimeStamp, params);\n        updateHasNextMessages(threadedMessages.length >= nextFetchSize);\n        updateMessages(threadedMessages, false, (_s = sdk.currentUser) === null || _s === void 0 ? void 0 : _s.userId);\n      } catch (error) {\n        (_t = logger === null || logger === void 0 ? void 0 : logger.error) === null || _t === void 0 ? void 0 : _t.call(logger, '[useGroupChannelThreadMessages] loadNext thread list failed.', error);\n      } finally {\n        isFetching.current.next = false;\n      }\n    }\n  }));\n  const hasNext = usePreservedCallback(() => {\n    return hasNextMessages;\n  });\n  const sendUserMessage = usePreservedCallback((params, onPending) => {\n    var _a;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise((resolve, reject) => {\n      channelRef.current.sendUserMessage(params).onPending(pendingMessage => {\n        var _a;\n        if (pendingMessage.channelUrl === channelRef.current.url) {\n          updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n      }).onSucceeded(sentMessage => {\n        var _a;\n        if (sentMessage.channelUrl === channelRef.current.url) {\n          updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        resolve(sentMessage);\n      }).onFailed((err, failedMessage) => {\n        var _a;\n        if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n          updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        reject(err);\n      });\n    });\n  });\n  const sendFileMessage = usePreservedCallback((params, onPending) => {\n    var _a;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise((resolve, reject) => {\n      channelRef.current.sendFileMessage(params).onPending(pendingMessage => {\n        var _a;\n        if (pendingMessage.channelUrl === channelRef.current.url) {\n          updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n      }).onSucceeded(sentMessage => {\n        var _a;\n        if (sentMessage.channelUrl === channelRef.current.url) {\n          updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        resolve(sentMessage);\n      }).onFailed((err, failedMessage) => {\n        var _a;\n        if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n          updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        reject(err);\n      });\n    });\n  });\n  const sendFileMessages = usePreservedCallback((paramsList, onPending) => __awaiter(void 0, void 0, void 0, function* () {\n    var _u;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_u = logger === null || logger === void 0 ? void 0 : logger.error) === null || _u === void 0 ? void 0 : _u.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise(resolve => {\n      const messages = [];\n      channelRef.current.sendFileMessages(paramsList).onPending(pendingMessage => {\n        var _a;\n        if (pendingMessage.channelUrl === channelRef.current.url) {\n          updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n      }).onSucceeded(sentMessage => {\n        var _a;\n        if (sentMessage.isFileMessage() && sentMessage.channelUrl === channelRef.current.url) {\n          updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n          messages.push(sentMessage);\n        }\n        if (messages.length === paramsList.length) resolve(messages);\n      }).onFailed((_, failedMessage) => {\n        var _a;\n        if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n          updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n          messages.push(failedMessage);\n        } else {\n          // NOTE: Since failedMessage is nullable by type, to resolve the promise, handle pushing null even when there is no failedMessage.\n          messages.push(null);\n        }\n        if (messages.length === paramsList.length) resolve(messages);\n      });\n    });\n  }));\n  const sendMultipleFilesMessage = usePreservedCallback((params, onPending) => {\n    var _a;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise((resolve, reject) => {\n      channelRef.current.sendMultipleFilesMessage(params).onPending(pendingMessage => {\n        var _a;\n        if (pendingMessage.channelUrl === channelRef.current.url) {\n          updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n      }).onFileUploaded(() => {\n        // Just re-render to use updated message.messageParams\n        forceUpdate();\n      }).onSucceeded(sentMessage => {\n        var _a;\n        if (sentMessage.channelUrl === channelRef.current.url) {\n          updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        resolve(sentMessage);\n      }).onFailed((err, failedMessage) => {\n        var _a;\n        if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n          updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n        }\n        reject(err);\n      });\n    });\n  });\n  const updateUserMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {\n    var _v, _w;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_v = logger === null || logger === void 0 ? void 0 : logger.error) === null || _v === void 0 ? void 0 : _v.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    const updatedMessage = yield channelRef.current.updateUserMessage(messageId, params);\n    if (updatedMessage.channelUrl === channelRef.current.url && isThreadedMessage(updatedMessage, parentMessageRef.current)) {\n      updateMessages([updatedMessage], false, (_w = sdk.currentUser) === null || _w === void 0 ? void 0 : _w.userId);\n    }\n    return updatedMessage;\n  }));\n  const updateFileMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {\n    var _x, _y;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_x = logger === null || logger === void 0 ? void 0 : logger.error) === null || _x === void 0 ? void 0 : _x.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    const updatedMessage = yield channelRef.current.updateFileMessage(messageId, params);\n    if (updatedMessage.channelUrl === channelRef.current.url && isThreadedMessage(updatedMessage, parentMessageRef.current)) {\n      updateMessages([updatedMessage], false, (_y = sdk.currentUser) === null || _y === void 0 ? void 0 : _y.userId);\n    }\n    return updatedMessage;\n  }));\n  const resendMessage = usePreservedCallback(failedMessage => __awaiter(void 0, void 0, void 0, function* () {\n    var _z;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_z = logger === null || logger === void 0 ? void 0 : logger.error) === null || _z === void 0 ? void 0 : _z.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    return new Promise((resolve, reject) => {\n      let handler = undefined;\n      if (failedMessage.isUserMessage()) handler = channelRef.current.resendMessage(failedMessage);\n      if (failedMessage.isFileMessage()) handler = channelRef.current.resendMessage(failedMessage);\n      if (failedMessage.isMultipleFilesMessage()) handler = channelRef.current.resendMessage(failedMessage);\n      if (handler) {\n        if ('onPending' in handler) {\n          handler.onPending(message => {\n            var _a;\n            if (message.channelUrl === channelRef.current.url) {\n              updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n            }\n          });\n        }\n        if ('onFileUploaded' in handler) {\n          handler.onFileUploaded(() => {\n            // Just re-render to use updated message.messageParams\n            forceUpdate();\n          });\n        }\n        if ('onSucceeded' in handler) {\n          handler.onSucceeded(message => {\n            var _a;\n            if (message.channelUrl === channelRef.current.url) {\n              updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n            }\n            resolve(message);\n          });\n        }\n        if ('onFailed' in handler) {\n          handler.onFailed((err, message) => {\n            var _a;\n            if (message && message.channelUrl === channelRef.current.url) {\n              updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n            }\n            reject(err);\n          });\n        }\n      }\n    });\n  }));\n  const deleteMessage = usePreservedCallback(message => __awaiter(void 0, void 0, void 0, function* () {\n    var _0, _1;\n    if (!channelRef.current || !channelRef.current.url) {\n      (_0 = logger === null || logger === void 0 ? void 0 : logger.error) === null || _0 === void 0 ? void 0 : _0.call(logger, '[useGroupChannelThreadMessages] channel is required');\n      throw new Error('Channel is required');\n    }\n    if (message.sendingStatus === 'succeeded') {\n      if (message.isUserMessage()) yield channelRef.current.deleteMessage(message);\n      if (message.isFileMessage()) yield channelRef.current.deleteMessage(message);\n      if (message.isMultipleFilesMessage()) yield channelRef.current.deleteMessage(message);\n    } else {\n      try {\n        yield (_1 = collectionRef.current.instance) === null || _1 === void 0 ? void 0 : _1.removeFailedMessage(message.reqId);\n      } finally {\n        deleteMessages([message.messageId], [message.reqId]);\n      }\n    }\n  }));\n  const resetNewMessages = usePreservedCallback(() => {\n    var _a;\n    updateNewMessages([], true, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n  });\n  const resetWithStartingPoint = usePreservedCallback(startingPoint => __awaiter(void 0, void 0, void 0, function* () {\n    var _2;\n    if (sdk.currentUser && channelRef.current) {\n      updateLoading(true);\n      updateMessages([], true, (_2 = sdk.currentUser) === null || _2 === void 0 ? void 0 : _2.userId);\n      yield init(startingPoint);\n      updateLoading(false);\n    }\n  }));\n  return {\n    /**\n     * Initialized state, only available on first render\n     * */\n    initialized,\n    /**\n     * Loading state, status is changes on first mount or when the resetWithStartingPoint is called.\n     * */\n    loading,\n    /**\n     * Refreshing state, status is changes when the refresh is called.\n     * */\n    refreshing,\n    /**\n     * Get messages, this state is for render\n     * For example, if a user receives a new messages while searching for an old message\n     * for this case, new messages will be included here.\n     * */\n    messages,\n    /**\n     * If the `shouldCountNewMessages()` is true, only then push in the newMessages state.\n     * (Return false for the `shouldCountNewMessages()` if the message scroll is the most recent; otherwise, return true.)\n     *\n     * A new message means a message that meets the below conditions\n     * - Not admin message\n     * - Not updated message\n     * - Not current user's message\n     * */\n    newMessages,\n    /**\n     * Reset new message list\n     * @return {void}\n     * */\n    resetNewMessages,\n    /**\n     * Reset message list and create a new collection for latest messages\n     * @return {Promise<void>}\n     * */\n    refresh,\n    /**\n     * Load previous messages to state\n     * @return {Promise<void>}\n     * */\n    loadPrevious,\n    /**\n     * Check if there are more previous messages to fetch\n     * @return {boolean}\n     * */\n    hasPrevious,\n    /**\n     * Load next messages to state\n     * @return {Promise<void>}\n     * */\n    loadNext,\n    /**\n     * Check if there are more next messages to fetch\n     * @return {boolean}\n     * */\n    hasNext,\n    /**\n     * Send user message\n     * @param {UserMessageCreateParams} params user message create params\n     * @param {function} [onPending] pending message callback\n     * @return {Promise<UserMessage>} succeeded message\n     * */\n    sendUserMessage,\n    /**\n     * Send file message\n     * @param {FileMessageCreateParams} params file message create params\n     * @param {function} [onPending] pending message callback\n     * @return {Promise<FileMessage>} succeeded message\n     * */\n    sendFileMessage,\n    /**\n     * Send file messages\n     * @param {FileMessageCreateParams[]} paramList file message create params\n     * @param {function} [onPending] pending message callback for each message request\n     * @return {Promise<FileMessage[]>} succeeded or failed message\n     * */\n    sendFileMessages,\n    /**\n     * Send multiple files message\n     * @param {MultipleFilesMessageCreateParams} params multiple files message create params\n     * @param {function} [onPending] pending message callback\n     * @return {Promise<MultipleFilesMessage>} succeeded message\n     * */\n    sendMultipleFilesMessage,\n    /**\n     * Update user message\n     * @param {number} messageId\n     * @param {UserMessageUpdateParams} params user message update params\n     * @return {Promise<UserMessage>}\n     * */\n    updateUserMessage,\n    /**\n     * Update file message\n     * @param {number} messageId\n     * @param {FileMessageUpdateParams} params file message update params\n     * @return {Promise<FileMessage>}\n     * */\n    updateFileMessage,\n    /**\n     * Resend failed message\n     * @template {UserMessage | FileMessage | MultipleFilesMessage} T\n     * @param {T} failedMessage message to resend\n     * @return {Promise<T>}\n     * */\n    resendMessage,\n    /**\n     * Delete a message\n     * @template {UserMessage | FileMessage | MultipleFilesMessage} T\n     * @param {T} message succeeded or failed message\n     * @return {Promise<void>}\n     * */\n    deleteMessage,\n    /**\n     * Reset message list and create a new collection with starting point\n     * @param {number} startingPoint\n     * @param {function} callback\n     * @return {void}\n     * */\n    resetWithStartingPoint\n  };\n};","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","useEffect","useLayoutEffect","useRef","CollectionEventSource","MessageCollectionInitPolicy","MessageFilter","ReplyType","sbuConstants","isDifferentChannel","isMyMessage","isSendableMessage","isNotEmptyArray","useAsyncEffect","useForceUpdate","useGroupChannelHandler","usePreservedCallback","useChannelThreadMessagesReducer","isThreadedMessage","message","parentMessage","parentMessageId","messageId","useGroupChannelThreadMessages","sdk","channel","options","arguments","length","undefined","_a","_b","_c","_d","_e","internalOptions","current","channelRef","parentMessageRef","startingPoint","Number","MAX_SAFE_INTEGER","prevFetchSize","collection","defaultLimit","prev","nextFetchSize","logger","isFetching","forceUpdate","collectionRef","initialized","apiInitialized","instance","loading","refreshing","hasPreviousMessages","hasNextMessages","oldestMessageTimeStamp","latestMessageTimeStamp","messages","newMessages","updateMessages","updateNewMessages","deleteNewMessages","deleteMessages","updateInitialized","updateLoading","updateRefreshing","updateHasPreviousMessages","updateHasNextMessages","sortComparator","markAsReadBySource","source","url","error","call","EVENT_MESSAGE_RECEIVED","EVENT_MESSAGE_SENT_SUCCESS","SYNC_MESSAGE_FILL","markAsRead","warn","updateNewMessagesReceived","incomingMessages","filter","it","currentUser","userId","shouldCountNewMessages","onMessagesReceived","_f","_g","_h","_j","_k","getMessagesByMessageId","prevResultSize","nextResultSize","isInclusive","includeThreadInfo","includeMetaArray","includeReactions","isReactionEnabled","find","onParentMessageUpdated","init","dispose","updateUnsentMessages","pendingMessages","failedMessages","filteredMessages","setTimeout","params","threadedMessages","getThreadedMessagesByTimestamp","prevMessagesCount","createdAt","nextMessagesCount","collectionInstance","createMessageCollection","prevResultLimit","nextResultLimit","replyType","ALL","setMessageCollectionHandler","onMessagesAdded","ctx","__","onMessagesUpdated","EVENT_MESSAGE_UPDATED","onMessagesDeleted","_","___","onParentMessageDeleted","msgIds","map","reqIds","reqId","onChannelDeleted","channelUrl","onChannelUpdated","onHugeGapDetected","initialize","CACHE_AND_REPLACE_BY_API","onCacheResult","err","isCacheEnabled","debug","onApiResult","onUserBanned","eventChannel","bannedUser","isGroupChannel","onCurrentUserBanned","timeout","clearTimeout","refresh","loadPrevious","_l","_m","_o","_p","hasPrevious","loadNext","_q","_r","_s","_t","hasNext","sendUserMessage","onPending","Error","pendingMessage","onSucceeded","sentMessage","onFailed","failedMessage","sendFileMessage","sendFileMessages","paramsList","_u","isFileMessage","push","sendMultipleFilesMessage","onFileUploaded","updateUserMessage","_v","_w","updatedMessage","updateFileMessage","_x","_y","resendMessage","_z","handler","isUserMessage","isMultipleFilesMessage","deleteMessage","_0","_1","sendingStatus","removeFailedMessage","resetNewMessages","resetWithStartingPoint","_2"],"sources":["D:/ebgbot/node_modules/@sendbird/uikit-react/node_modules/@sendbird/uikit-tools/dist/esm/hooks/useGroupChannelThreadMessages/index.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { useEffect, useLayoutEffect, useRef } from 'react';\nimport { CollectionEventSource } from '@sendbird/chat';\nimport { MessageCollectionInitPolicy, MessageFilter } from '@sendbird/chat/groupChannel';\nimport { ReplyType } from '@sendbird/chat/message';\nimport { sbuConstants } from '../../constants/sbuConstants.js';\nimport { isDifferentChannel } from '../../utils/channel.js';\nimport { isMyMessage, isSendableMessage } from '../../utils/message.js';\nimport { isNotEmptyArray } from '../../utils/validators.js';\nimport { useAsyncEffect } from '../useAsyncEffect.js';\nimport { useForceUpdate } from '../useForceUpdate.js';\nimport { useGroupChannelHandler } from '../useGroupChannelHandler.js';\nimport { usePreservedCallback } from '../usePreservedCallback.js';\nimport { useChannelThreadMessagesReducer } from './reducer.js';\nfunction isThreadedMessage(message, parentMessage) {\n    return message.parentMessageId === parentMessage.messageId;\n}\nexport const useGroupChannelThreadMessages = (sdk, channel, parentMessage, options = {}) => {\n    var _a, _b, _c, _d, _e;\n    const internalOptions = useRef(options); // to keep reference of options in event handler\n    internalOptions.current = options;\n    const channelRef = useRef(channel); // to keep reference of channel in event handler\n    channelRef.current = channel;\n    const parentMessageRef = useRef(parentMessage); // to keep reference of parent message in event handler\n    parentMessageRef.current = parentMessage;\n    const startingPoint = useRef(((_a = internalOptions.current) === null || _a === void 0 ? void 0 : _a.startingPoint) || Number.MAX_SAFE_INTEGER);\n    startingPoint.current = ((_b = internalOptions.current) === null || _b === void 0 ? void 0 : _b.startingPoint) || Number.MAX_SAFE_INTEGER;\n    const prevFetchSize = sbuConstants.collection.message.defaultLimit.prev;\n    const nextFetchSize = sbuConstants.collection.message.defaultLimit.next;\n    const logger = internalOptions.current.logger;\n    const isFetching = useRef({ prev: false, next: false });\n    const forceUpdate = useForceUpdate();\n    const collectionRef = useRef({\n        initialized: false,\n        apiInitialized: false,\n        instance: null,\n    });\n    const { initialized, loading, refreshing, hasPreviousMessages, hasNextMessages, oldestMessageTimeStamp, latestMessageTimeStamp, messages, newMessages, updateMessages, updateNewMessages, deleteNewMessages, deleteMessages, updateInitialized, updateLoading, updateRefreshing, updateHasPreviousMessages, updateHasNextMessages, } = useChannelThreadMessagesReducer(options === null || options === void 0 ? void 0 : options.sortComparator);\n    const markAsReadBySource = usePreservedCallback((source) => {\n        var _a, _b, _c, _d;\n        if (!channelRef.current || !channelRef.current.url) {\n            return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n        }\n        try {\n            switch (source) {\n                case CollectionEventSource.EVENT_MESSAGE_RECEIVED:\n                case CollectionEventSource.EVENT_MESSAGE_SENT_SUCCESS:\n                case CollectionEventSource.SYNC_MESSAGE_FILL:\n                case undefined:\n                    (_c = (_b = internalOptions.current).markAsRead) === null || _c === void 0 ? void 0 : _c.call(_b, [channelRef.current]);\n                    break;\n            }\n        }\n        catch (e) {\n            (_d = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _d === void 0 ? void 0 : _d.call(logger, '[useGroupChannelThreadMessages/markAsReadBySource]', e);\n        }\n    });\n    const updateNewMessagesReceived = usePreservedCallback((source, messages) => {\n        var _a, _b, _c, _d, _e;\n        const incomingMessages = messages.filter((it) => { var _a; return isThreadedMessage(it, parentMessageRef.current) && !isMyMessage(it, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId); });\n        if (incomingMessages.length > 0) {\n            switch (source) {\n                case CollectionEventSource.EVENT_MESSAGE_RECEIVED:\n                case CollectionEventSource.SYNC_MESSAGE_FILL: {\n                    if ((_b = (_a = internalOptions.current).shouldCountNewMessages) === null || _b === void 0 ? void 0 : _b.call(_a)) {\n                        updateNewMessages(incomingMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n                    }\n                    (_e = (_d = internalOptions.current).onMessagesReceived) === null || _e === void 0 ? void 0 : _e.call(_d, incomingMessages);\n                    break;\n                }\n            }\n        }\n    });\n    useAsyncEffect(() => __awaiter(void 0, void 0, void 0, function* () {\n        var _f, _g, _h, _j, _k;\n        const messages = yield ((_f = channelRef.current) === null || _f === void 0 ? void 0 : _f.getMessagesByMessageId((_g = parentMessageRef.current) === null || _g === void 0 ? void 0 : _g.messageId, {\n            prevResultSize: 1,\n            nextResultSize: 1,\n            isInclusive: true,\n            includeThreadInfo: true,\n            includeMetaArray: true,\n            includeReactions: (_h = internalOptions.current.isReactionEnabled) !== null && _h !== void 0 ? _h : false,\n        }));\n        const parentMessage = messages === null || messages === void 0 ? void 0 : messages.find((message) => {\n            return message.messageId === parentMessageRef.current.messageId;\n        });\n        if (parentMessage) {\n            parentMessageRef.current = parentMessage;\n            (_k = (_j = internalOptions.current).onParentMessageUpdated) === null || _k === void 0 ? void 0 : _k.call(_j, parentMessage);\n        }\n    }), [(_c = channelRef.current) === null || _c === void 0 ? void 0 : _c.url, internalOptions.current.isReactionEnabled]);\n    const init = usePreservedCallback((startingPoint) => __awaiter(void 0, void 0, void 0, function* () {\n        return new Promise((resolve) => {\n            var _a, _b, _c;\n            if (!channelRef.current || !channelRef.current.url) {\n                return (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            }\n            if (!parentMessageRef.current) {\n                return (_b = logger === null || logger === void 0 ? void 0 : logger.error) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelThreadMessages] parent message is required');\n            }\n            if (collectionRef.current.instance)\n                collectionRef.current.instance.dispose();\n            markAsReadBySource();\n            updateNewMessages([], true, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n            const updateUnsentMessages = () => {\n                var _a, _b;\n                const { pendingMessages, failedMessages } = (_a = collectionRef.current.instance) !== null && _a !== void 0 ? _a : {};\n                let filteredMessages;\n                if (isNotEmptyArray(pendingMessages)) {\n                    filteredMessages = pendingMessages.filter((message) => isThreadedMessage(message, parentMessageRef.current));\n                }\n                if (isNotEmptyArray(failedMessages)) {\n                    filteredMessages = failedMessages.filter((message) => isThreadedMessage(message, parentMessageRef.current));\n                }\n                if (isNotEmptyArray(filteredMessages))\n                    updateMessages(filteredMessages, false, (_b = sdk.currentUser) === null || _b === void 0 ? void 0 : _b.userId);\n            };\n            setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {\n                var _d, _e, _f, _g;\n                try {\n                    if (parentMessageRef.current) {\n                        const params = {\n                            prevResultSize: prevFetchSize,\n                            nextResultSize: nextFetchSize,\n                            isInclusive: true,\n                            includeReactions: (_d = internalOptions.current.isReactionEnabled) !== null && _d !== void 0 ? _d : false,\n                        };\n                        const { threadedMessages } = yield parentMessageRef.current.getThreadedMessagesByTimestamp(startingPoint, params);\n                        if (isNotEmptyArray(threadedMessages)) {\n                            const prevMessagesCount = threadedMessages.filter((message) => message.createdAt < startingPoint).length;\n                            const nextMessagesCount = threadedMessages.filter((message) => message.createdAt > startingPoint).length;\n                            updateHasPreviousMessages(prevMessagesCount >= prevFetchSize);\n                            updateHasNextMessages(nextMessagesCount >= nextFetchSize);\n                            updateMessages(threadedMessages, true, (_e = sdk.currentUser) === null || _e === void 0 ? void 0 : _e.userId);\n                        }\n                    }\n                    else {\n                        (_f = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _f === void 0 ? void 0 : _f.call(logger, '[useGroupChannelThreadMessages] parent message is required');\n                    }\n                    resolve();\n                }\n                catch (error) {\n                    (_g = logger === null || logger === void 0 ? void 0 : logger.error) === null || _g === void 0 ? void 0 : _g.call(logger, '[useGroupChannelThreadMessages] Initialize thread list failed.', error);\n                }\n            }));\n            const collectionInstance = channelRef.current.createMessageCollection({\n                prevResultLimit: prevFetchSize,\n                nextResultLimit: nextFetchSize,\n                startingPoint: startingPoint - 1,\n                filter: new MessageFilter({ replyType: ReplyType.ALL }),\n            });\n            collectionRef.current = { apiInitialized: false, initialized: false, instance: collectionInstance };\n            collectionInstance.setMessageCollectionHandler({\n                onMessagesAdded: (ctx, __, messages) => {\n                    var _a;\n                    const filteredMessages = messages.filter((message) => isThreadedMessage(message, parentMessageRef.current));\n                    if (isNotEmptyArray(filteredMessages)) {\n                        markAsReadBySource(ctx.source);\n                        updateNewMessagesReceived(ctx.source, filteredMessages);\n                        updateMessages(filteredMessages, false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                    }\n                },\n                onMessagesUpdated: (ctx, __, messages) => {\n                    var _a, _b, _c, _d, _e;\n                    const filteredMessages = messages.filter((message) => isThreadedMessage(message, parentMessageRef.current));\n                    const parentMessage = messages.find((message) => message.messageId === parentMessageRef.current.messageId);\n                    if (parentMessage) {\n                        parentMessageRef.current = parentMessage;\n                        (_b = (_a = internalOptions.current).onParentMessageUpdated) === null || _b === void 0 ? void 0 : _b.call(_a, parentMessage);\n                    }\n                    if (isNotEmptyArray(filteredMessages)) {\n                        markAsReadBySource(ctx.source);\n                        updateNewMessagesReceived(ctx.source, filteredMessages); // NOTE: admin message is not added via onMessagesAdded handler, not checked yet is this a bug.\n                        updateMessages(filteredMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n                        if (ctx.source === CollectionEventSource.EVENT_MESSAGE_UPDATED) {\n                            (_e = (_d = internalOptions.current).onMessagesUpdated) === null || _e === void 0 ? void 0 : _e.call(_d, filteredMessages);\n                        }\n                    }\n                },\n                onMessagesDeleted: (_, __, ___, messages) => {\n                    var _a, _b;\n                    const parentMessage = messages.find((message) => message.messageId === parentMessageRef.current.messageId);\n                    if (parentMessage) {\n                        (_b = (_a = internalOptions.current).onParentMessageDeleted) === null || _b === void 0 ? void 0 : _b.call(_a);\n                    }\n                    const filteredMessages = messages.filter((message) => isThreadedMessage(message, parentMessageRef.current));\n                    if (isNotEmptyArray(filteredMessages)) {\n                        const msgIds = filteredMessages.map((it) => it.messageId);\n                        const reqIds = filteredMessages.filter(isSendableMessage).map((it) => it.reqId);\n                        deleteMessages(msgIds, reqIds);\n                        deleteNewMessages(msgIds, reqIds);\n                    }\n                },\n                onChannelDeleted: (_, channelUrl) => {\n                    var _a, _b;\n                    (_b = (_a = internalOptions.current).onChannelDeleted) === null || _b === void 0 ? void 0 : _b.call(_a, channelUrl);\n                },\n                onChannelUpdated: (_, channel) => {\n                    var _a, _b;\n                    forceUpdate();\n                    (_b = (_a = internalOptions.current).onChannelUpdated) === null || _b === void 0 ? void 0 : _b.call(_a, channel);\n                },\n                onHugeGapDetected: () => {\n                    init(startingPoint);\n                },\n            });\n            collectionInstance\n                .initialize(MessageCollectionInitPolicy.CACHE_AND_REPLACE_BY_API)\n                .onCacheResult((err, messages) => {\n                var _a, _b, _c;\n                if (err) {\n                    sdk.isCacheEnabled && ((_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages/onCacheResult]', err));\n                }\n                else if (messages) {\n                    (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelThreadMessages/onCacheResult]', 'message length:', messages.length);\n                    const filteredMessages = messages.filter((message) => isThreadedMessage(message, parentMessageRef.current));\n                    if (isNotEmptyArray(filteredMessages)) {\n                        updateMessages(filteredMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n                        updateUnsentMessages();\n                    }\n                }\n            })\n                .onApiResult((err, messages) => {\n                var _a, _b, _c;\n                if (err) {\n                    (_a = logger === null || logger === void 0 ? void 0 : logger.warn) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages/onApiResult]', err);\n                }\n                else if (messages) {\n                    (_b = logger === null || logger === void 0 ? void 0 : logger.debug) === null || _b === void 0 ? void 0 : _b.call(logger, '[useGroupChannelThreadMessages/onApiResult]', 'message length:', messages.length);\n                    const filteredMessages = messages.filter((message) => isThreadedMessage(message, parentMessageRef.current));\n                    if (isNotEmptyArray(filteredMessages)) {\n                        updateMessages(filteredMessages, false, (_c = sdk.currentUser) === null || _c === void 0 ? void 0 : _c.userId);\n                        if (sdk.isCacheEnabled)\n                            updateUnsentMessages();\n                    }\n                }\n                collectionRef.current.initialized = true;\n                collectionRef.current.apiInitialized = true;\n            });\n        });\n    }));\n    useGroupChannelHandler(sdk, {\n        onUserBanned(eventChannel, bannedUser) {\n            var _a, _b, _c;\n            if (eventChannel.isGroupChannel() && !isDifferentChannel(eventChannel, channelRef.current)) {\n                if (bannedUser.userId === ((_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId)) {\n                    (_c = (_b = internalOptions.current).onCurrentUserBanned) === null || _c === void 0 ? void 0 : _c.call(_b);\n                }\n                else {\n                    forceUpdate();\n                }\n            }\n        },\n    });\n    useLayoutEffect(() => {\n        const timeout = setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {\n            if (sdk.currentUser && channelRef.current) {\n                updateInitialized(false);\n                updateLoading(true);\n                yield init(startingPoint.current);\n                updateLoading(false);\n                updateInitialized(true);\n            }\n        }));\n        return () => clearTimeout(timeout);\n    }, [sdk, (_d = sdk.currentUser) === null || _d === void 0 ? void 0 : _d.userId, (_e = channelRef.current) === null || _e === void 0 ? void 0 : _e.url, startingPoint.current]);\n    useEffect(() => {\n        return () => {\n            if (collectionRef.current.instance)\n                collectionRef.current.instance.dispose();\n        };\n    }, []);\n    const refresh = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        if (sdk.currentUser && channelRef.current) {\n            updateRefreshing(true);\n            yield init(startingPoint.current);\n            updateRefreshing(false);\n        }\n    }));\n    const loadPrevious = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        var _l, _m, _o, _p;\n        if (!channelRef.current || !channelRef.current.url || !parentMessageRef.current) {\n            (_l = logger === null || logger === void 0 ? void 0 : logger.error) === null || _l === void 0 ? void 0 : _l.call(logger, '[useGroupChannelThreadMessages] channel or parent message is required');\n            return;\n        }\n        if (hasPreviousMessages && !isFetching.current.prev) {\n            try {\n                isFetching.current.prev = true;\n                const params = {\n                    prevResultSize: prevFetchSize,\n                    nextResultSize: 0,\n                    isInclusive: false,\n                    includeReactions: (_m = internalOptions.current.isReactionEnabled) !== null && _m !== void 0 ? _m : false,\n                };\n                const { threadedMessages } = yield parentMessageRef.current.getThreadedMessagesByTimestamp(oldestMessageTimeStamp, params);\n                if (isNotEmptyArray(threadedMessages)) {\n                    updateHasPreviousMessages(threadedMessages.length >= prevFetchSize);\n                    updateMessages(threadedMessages, false, (_o = sdk.currentUser) === null || _o === void 0 ? void 0 : _o.userId);\n                }\n            }\n            catch (error) {\n                (_p = logger === null || logger === void 0 ? void 0 : logger.error) === null || _p === void 0 ? void 0 : _p.call(logger, '[useGroupChannelThreadMessages] loadPrevious thread list failed.', error);\n            }\n            finally {\n                isFetching.current.prev = false;\n            }\n        }\n    }));\n    const hasPrevious = usePreservedCallback(() => {\n        return hasPreviousMessages;\n    });\n    const loadNext = usePreservedCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        var _q, _r, _s, _t;\n        if (!channelRef.current || !channelRef.current.url || !parentMessageRef.current) {\n            (_q = logger === null || logger === void 0 ? void 0 : logger.error) === null || _q === void 0 ? void 0 : _q.call(logger, '[useGroupChannelThreadMessages] channel or parent message is required');\n            return;\n        }\n        if (hasNextMessages && !isFetching.current.next) {\n            try {\n                isFetching.current.prev = true;\n                const params = {\n                    prevResultSize: 0,\n                    nextResultSize: nextFetchSize,\n                    isInclusive: false,\n                    includeReactions: (_r = internalOptions.current.isReactionEnabled) !== null && _r !== void 0 ? _r : false,\n                };\n                const { threadedMessages } = yield parentMessageRef.current.getThreadedMessagesByTimestamp(latestMessageTimeStamp, params);\n                updateHasNextMessages(threadedMessages.length >= nextFetchSize);\n                updateMessages(threadedMessages, false, (_s = sdk.currentUser) === null || _s === void 0 ? void 0 : _s.userId);\n            }\n            catch (error) {\n                (_t = logger === null || logger === void 0 ? void 0 : logger.error) === null || _t === void 0 ? void 0 : _t.call(logger, '[useGroupChannelThreadMessages] loadNext thread list failed.', error);\n            }\n            finally {\n                isFetching.current.next = false;\n            }\n        }\n    }));\n    const hasNext = usePreservedCallback(() => {\n        return hasNextMessages;\n    });\n    const sendUserMessage = usePreservedCallback((params, onPending) => {\n        var _a;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve, reject) => {\n            channelRef.current\n                .sendUserMessage(params)\n                .onPending((pendingMessage) => {\n                var _a;\n                if (pendingMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n            })\n                .onSucceeded((sentMessage) => {\n                var _a;\n                if (sentMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                resolve(sentMessage);\n            })\n                .onFailed((err, failedMessage) => {\n                var _a;\n                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                reject(err);\n            });\n        });\n    });\n    const sendFileMessage = usePreservedCallback((params, onPending) => {\n        var _a;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve, reject) => {\n            channelRef.current\n                .sendFileMessage(params)\n                .onPending((pendingMessage) => {\n                var _a;\n                if (pendingMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n            })\n                .onSucceeded((sentMessage) => {\n                var _a;\n                if (sentMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                resolve(sentMessage);\n            })\n                .onFailed((err, failedMessage) => {\n                var _a;\n                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                reject(err);\n            });\n        });\n    });\n    const sendFileMessages = usePreservedCallback((paramsList, onPending) => __awaiter(void 0, void 0, void 0, function* () {\n        var _u;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_u = logger === null || logger === void 0 ? void 0 : logger.error) === null || _u === void 0 ? void 0 : _u.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve) => {\n            const messages = [];\n            channelRef.current\n                .sendFileMessages(paramsList)\n                .onPending((pendingMessage) => {\n                var _a;\n                if (pendingMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n            })\n                .onSucceeded((sentMessage) => {\n                var _a;\n                if (sentMessage.isFileMessage() && sentMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                    messages.push(sentMessage);\n                }\n                if (messages.length === paramsList.length)\n                    resolve(messages);\n            })\n                .onFailed((_, failedMessage) => {\n                var _a;\n                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                    messages.push(failedMessage);\n                }\n                else {\n                    // NOTE: Since failedMessage is nullable by type, to resolve the promise, handle pushing null even when there is no failedMessage.\n                    messages.push(null);\n                }\n                if (messages.length === paramsList.length)\n                    resolve(messages);\n            });\n        });\n    }));\n    const sendMultipleFilesMessage = usePreservedCallback((params, onPending) => {\n        var _a;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_a = logger === null || logger === void 0 ? void 0 : logger.error) === null || _a === void 0 ? void 0 : _a.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve, reject) => {\n            channelRef.current\n                .sendMultipleFilesMessage(params)\n                .onPending((pendingMessage) => {\n                var _a;\n                if (pendingMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([pendingMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                onPending === null || onPending === void 0 ? void 0 : onPending(pendingMessage);\n            })\n                .onFileUploaded(() => {\n                // Just re-render to use updated message.messageParams\n                forceUpdate();\n            })\n                .onSucceeded((sentMessage) => {\n                var _a;\n                if (sentMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([sentMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                resolve(sentMessage);\n            })\n                .onFailed((err, failedMessage) => {\n                var _a;\n                if (failedMessage && failedMessage.channelUrl === channelRef.current.url) {\n                    updateMessages([failedMessage], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                }\n                reject(err);\n            });\n        });\n    });\n    const updateUserMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {\n        var _v, _w;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_v = logger === null || logger === void 0 ? void 0 : logger.error) === null || _v === void 0 ? void 0 : _v.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        const updatedMessage = yield channelRef.current.updateUserMessage(messageId, params);\n        if (updatedMessage.channelUrl === channelRef.current.url &&\n            isThreadedMessage(updatedMessage, parentMessageRef.current)) {\n            updateMessages([updatedMessage], false, (_w = sdk.currentUser) === null || _w === void 0 ? void 0 : _w.userId);\n        }\n        return updatedMessage;\n    }));\n    const updateFileMessage = usePreservedCallback((messageId, params) => __awaiter(void 0, void 0, void 0, function* () {\n        var _x, _y;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_x = logger === null || logger === void 0 ? void 0 : logger.error) === null || _x === void 0 ? void 0 : _x.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        const updatedMessage = yield channelRef.current.updateFileMessage(messageId, params);\n        if (updatedMessage.channelUrl === channelRef.current.url &&\n            isThreadedMessage(updatedMessage, parentMessageRef.current)) {\n            updateMessages([updatedMessage], false, (_y = sdk.currentUser) === null || _y === void 0 ? void 0 : _y.userId);\n        }\n        return updatedMessage;\n    }));\n    const resendMessage = usePreservedCallback((failedMessage) => __awaiter(void 0, void 0, void 0, function* () {\n        var _z;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_z = logger === null || logger === void 0 ? void 0 : logger.error) === null || _z === void 0 ? void 0 : _z.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        return new Promise((resolve, reject) => {\n            let handler = undefined;\n            if (failedMessage.isUserMessage())\n                handler = channelRef.current.resendMessage(failedMessage);\n            if (failedMessage.isFileMessage())\n                handler = channelRef.current.resendMessage(failedMessage);\n            if (failedMessage.isMultipleFilesMessage())\n                handler = channelRef.current.resendMessage(failedMessage);\n            if (handler) {\n                if ('onPending' in handler) {\n                    handler.onPending((message) => {\n                        var _a;\n                        if (message.channelUrl === channelRef.current.url) {\n                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                        }\n                    });\n                }\n                if ('onFileUploaded' in handler) {\n                    handler.onFileUploaded(() => {\n                        // Just re-render to use updated message.messageParams\n                        forceUpdate();\n                    });\n                }\n                if ('onSucceeded' in handler) {\n                    handler.onSucceeded((message) => {\n                        var _a;\n                        if (message.channelUrl === channelRef.current.url) {\n                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                        }\n                        resolve(message);\n                    });\n                }\n                if ('onFailed' in handler) {\n                    handler.onFailed((err, message) => {\n                        var _a;\n                        if (message && message.channelUrl === channelRef.current.url) {\n                            updateMessages([message], false, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n                        }\n                        reject(err);\n                    });\n                }\n            }\n        });\n    }));\n    const deleteMessage = usePreservedCallback((message) => __awaiter(void 0, void 0, void 0, function* () {\n        var _0, _1;\n        if (!channelRef.current || !channelRef.current.url) {\n            (_0 = logger === null || logger === void 0 ? void 0 : logger.error) === null || _0 === void 0 ? void 0 : _0.call(logger, '[useGroupChannelThreadMessages] channel is required');\n            throw new Error('Channel is required');\n        }\n        if (message.sendingStatus === 'succeeded') {\n            if (message.isUserMessage())\n                yield channelRef.current.deleteMessage(message);\n            if (message.isFileMessage())\n                yield channelRef.current.deleteMessage(message);\n            if (message.isMultipleFilesMessage())\n                yield channelRef.current.deleteMessage(message);\n        }\n        else {\n            try {\n                yield ((_1 = collectionRef.current.instance) === null || _1 === void 0 ? void 0 : _1.removeFailedMessage(message.reqId));\n            }\n            finally {\n                deleteMessages([message.messageId], [message.reqId]);\n            }\n        }\n    }));\n    const resetNewMessages = usePreservedCallback(() => {\n        var _a;\n        updateNewMessages([], true, (_a = sdk.currentUser) === null || _a === void 0 ? void 0 : _a.userId);\n    });\n    const resetWithStartingPoint = usePreservedCallback((startingPoint) => __awaiter(void 0, void 0, void 0, function* () {\n        var _2;\n        if (sdk.currentUser && channelRef.current) {\n            updateLoading(true);\n            updateMessages([], true, (_2 = sdk.currentUser) === null || _2 === void 0 ? void 0 : _2.userId);\n            yield init(startingPoint);\n            updateLoading(false);\n        }\n    }));\n    return {\n        /**\n         * Initialized state, only available on first render\n         * */\n        initialized,\n        /**\n         * Loading state, status is changes on first mount or when the resetWithStartingPoint is called.\n         * */\n        loading,\n        /**\n         * Refreshing state, status is changes when the refresh is called.\n         * */\n        refreshing,\n        /**\n         * Get messages, this state is for render\n         * For example, if a user receives a new messages while searching for an old message\n         * for this case, new messages will be included here.\n         * */\n        messages,\n        /**\n         * If the `shouldCountNewMessages()` is true, only then push in the newMessages state.\n         * (Return false for the `shouldCountNewMessages()` if the message scroll is the most recent; otherwise, return true.)\n         *\n         * A new message means a message that meets the below conditions\n         * - Not admin message\n         * - Not updated message\n         * - Not current user's message\n         * */\n        newMessages,\n        /**\n         * Reset new message list\n         * @return {void}\n         * */\n        resetNewMessages,\n        /**\n         * Reset message list and create a new collection for latest messages\n         * @return {Promise<void>}\n         * */\n        refresh,\n        /**\n         * Load previous messages to state\n         * @return {Promise<void>}\n         * */\n        loadPrevious,\n        /**\n         * Check if there are more previous messages to fetch\n         * @return {boolean}\n         * */\n        hasPrevious,\n        /**\n         * Load next messages to state\n         * @return {Promise<void>}\n         * */\n        loadNext,\n        /**\n         * Check if there are more next messages to fetch\n         * @return {boolean}\n         * */\n        hasNext,\n        /**\n         * Send user message\n         * @param {UserMessageCreateParams} params user message create params\n         * @param {function} [onPending] pending message callback\n         * @return {Promise<UserMessage>} succeeded message\n         * */\n        sendUserMessage,\n        /**\n         * Send file message\n         * @param {FileMessageCreateParams} params file message create params\n         * @param {function} [onPending] pending message callback\n         * @return {Promise<FileMessage>} succeeded message\n         * */\n        sendFileMessage,\n        /**\n         * Send file messages\n         * @param {FileMessageCreateParams[]} paramList file message create params\n         * @param {function} [onPending] pending message callback for each message request\n         * @return {Promise<FileMessage[]>} succeeded or failed message\n         * */\n        sendFileMessages,\n        /**\n         * Send multiple files message\n         * @param {MultipleFilesMessageCreateParams} params multiple files message create params\n         * @param {function} [onPending] pending message callback\n         * @return {Promise<MultipleFilesMessage>} succeeded message\n         * */\n        sendMultipleFilesMessage,\n        /**\n         * Update user message\n         * @param {number} messageId\n         * @param {UserMessageUpdateParams} params user message update params\n         * @return {Promise<UserMessage>}\n         * */\n        updateUserMessage,\n        /**\n         * Update file message\n         * @param {number} messageId\n         * @param {FileMessageUpdateParams} params file message update params\n         * @return {Promise<FileMessage>}\n         * */\n        updateFileMessage,\n        /**\n         * Resend failed message\n         * @template {UserMessage | FileMessage | MultipleFilesMessage} T\n         * @param {T} failedMessage message to resend\n         * @return {Promise<T>}\n         * */\n        resendMessage,\n        /**\n         * Delete a message\n         * @template {UserMessage | FileMessage | MultipleFilesMessage} T\n         * @param {T} message succeeded or failed message\n         * @return {Promise<void>}\n         * */\n        deleteMessage,\n        /**\n         * Reset message list and create a new collection with starting point\n         * @param {number} startingPoint\n         * @param {function} callback\n         * @return {void}\n         * */\n        resetWithStartingPoint,\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}