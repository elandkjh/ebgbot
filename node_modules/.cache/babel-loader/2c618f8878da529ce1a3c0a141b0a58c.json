{"ast":null,"code":"import { b as VOICE_RECORDER_AUDIO_SAMPLE_RATE } from './bundle-DCMGp6rH.js';\nimport { WavHeader as ut, Mp3Encoder as ht } from '../lame.all.js';\n\n// Thanks to https://codesandbox.io/s/media-recorder-api-downsampling-16k-mp3-encode-using-lame-js-forked-n1pblw\nfunction encodeMp3(arrayBuffer) {\n  var wav = ut.readHeader(new DataView(arrayBuffer));\n  var dataView = new Int16Array(arrayBuffer, wav.dataOffset, wav.dataLen / 2);\n  var mp3Encoder = new ht(wav.channels, wav.sampleRate, 128);\n  var maxSamples = 1152;\n  var samplesLeft = wav.channels === 1 ? dataView : new Int16Array(wav.dataLen / (2 * wav.channels));\n  var samplesRight = wav.channels === 2 ? new Int16Array(wav.dataLen / (2 * wav.channels)) : undefined;\n  if (wav.channels > 1) {\n    for (var j = 0; j < samplesLeft.length; j++) {\n      samplesLeft[j] = dataView[j * 2];\n      if (samplesRight) {\n        samplesRight[j] = dataView[j * 2 + 1];\n      }\n    }\n  }\n  var dataBuffer = [];\n  var remaining = samplesLeft.length;\n  for (var i = 0; remaining >= maxSamples; i += maxSamples) {\n    var left = samplesLeft.subarray(i, i + maxSamples);\n    var right = void 0;\n    if (samplesRight) {\n      right = samplesRight.subarray(i, i + maxSamples);\n    }\n    var mp3buf = mp3Encoder.encodeBuffer(left, right);\n    dataBuffer.push(new Int8Array(mp3buf));\n    remaining -= maxSamples;\n  }\n  var mp3Lastbuf = mp3Encoder.flush();\n  dataBuffer.push(new Int8Array(mp3Lastbuf));\n  return dataBuffer;\n}\n// Convert audioFile to arrayBuffer, because Mp3Encoder requires a parameter of ArrayBuffer type\nfunction downsampleToWav(file, callback) {\n  // Browser compatibility\n  // https://caniuse.com/?search=AudioContext\n  var audioCtx = new AudioContext({\n    sampleRate: VOICE_RECORDER_AUDIO_SAMPLE_RATE\n  });\n  var fileReader = new FileReader();\n  fileReader.onload = function (ev) {\n    var _a;\n    // Decode audio\n    audioCtx.decodeAudioData((_a = ev.target) === null || _a === void 0 ? void 0 : _a.result, function (buffer) {\n      // this is where you down sample the audio, usually is 44100 samples per second\n      var usingWebkit = !window.OfflineAudioContext;\n      var offlineAudioCtx = new OfflineAudioContext(1, 16000 * buffer.duration, 16000);\n      var soundSource = offlineAudioCtx.createBufferSource();\n      soundSource.buffer = buffer;\n      soundSource.connect(offlineAudioCtx.destination);\n      var reader = new FileReader();\n      reader.onload = function () {\n        var renderCompleteHandler = function (evt) {\n          var renderedBuffer = usingWebkit ? evt.renderedBuffer : evt;\n          var buffer = bufferToWav(renderedBuffer, renderedBuffer.length);\n          if (callback) {\n            callback(buffer);\n          }\n        };\n        if (usingWebkit) {\n          offlineAudioCtx.oncomplete = renderCompleteHandler;\n          offlineAudioCtx.startRendering();\n        } else {\n          offlineAudioCtx.startRendering().then(renderCompleteHandler)\n          // eslint-disable-next-line no-console\n          .catch(function (err) {\n            return console.warn(err);\n          });\n        }\n      };\n      reader.readAsArrayBuffer(file);\n      soundSource.start(0);\n    });\n  };\n  fileReader.readAsArrayBuffer(file);\n}\nfunction bufferToWav(abuffer, len) {\n  var numOfChan = abuffer.numberOfChannels;\n  var length = len * numOfChan * 2 + 44;\n  var buffer = new ArrayBuffer(length);\n  var view = new DataView(buffer);\n  var channels = [];\n  var i = 0;\n  var sample;\n  var offset = 0;\n  var pos = 0;\n  // write WAVE header\n  setUint32(0x46464952); // \"RIFF\"\n  setUint32(length - 8); // file length - 8\n  setUint32(0x45564157); // \"WAVE\"\n  setUint32(0x20746d66); // \"fmt \" chunk\n  setUint32(16); // length = 16\n  setUint16(1); // PCM (uncompressed)\n  setUint16(numOfChan);\n  setUint32(abuffer.sampleRate);\n  setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec\n  setUint16(numOfChan * 2); // block-align\n  setUint16(16); // 16-bit (hardcoded in this demo)\n  setUint32(0x61746164); // \"data\" - chunk\n  setUint32(length - pos - 4); // chunk length\n  // write interleaved data\n  for (i = 0; i < abuffer.numberOfChannels; i++) {\n    channels.push(abuffer.getChannelData(i));\n  }\n  while (pos < length) {\n    for (i = 0; i < numOfChan; i++) {\n      // interleave channels\n      sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp\n      sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; // scale to 16-bit signed int\n      view.setInt16(pos, sample, true); // write 16-bit sample\n      pos += 2;\n    }\n    offset++; // next source sample\n  }\n  return buffer;\n  function setUint16(data) {\n    view.setUint16(pos, data, true);\n    pos += 2;\n  }\n  function setUint32(data) {\n    view.setUint32(pos, data, true);\n    pos += 4;\n  }\n}\nexport { downsampleToWav, encodeMp3 };","map":{"version":3,"names":[],"sources":[],"sourcesContent":["import { b as VOICE_RECORDER_AUDIO_SAMPLE_RATE } from './bundle-DCMGp6rH.js';\nimport { WavHeader as ut, Mp3Encoder as ht } from '../lame.all.js';\n\n// Thanks to https://codesandbox.io/s/media-recorder-api-downsampling-16k-mp3-encode-using-lame-js-forked-n1pblw\nfunction encodeMp3(arrayBuffer) {\n    var wav = ut.readHeader(new DataView(arrayBuffer));\n    var dataView = new Int16Array(arrayBuffer, wav.dataOffset, wav.dataLen / 2);\n    var mp3Encoder = new ht(wav.channels, wav.sampleRate, 128);\n    var maxSamples = 1152;\n    var samplesLeft = (wav.channels === 1) ? dataView : new Int16Array(wav.dataLen / (2 * wav.channels));\n    var samplesRight = (wav.channels === 2) ? new Int16Array(wav.dataLen / (2 * wav.channels)) : undefined;\n    if (wav.channels > 1) {\n        for (var j = 0; j < samplesLeft.length; j++) {\n            samplesLeft[j] = dataView[j * 2];\n            if (samplesRight) {\n                samplesRight[j] = dataView[j * 2 + 1];\n            }\n        }\n    }\n    var dataBuffer = [];\n    var remaining = samplesLeft.length;\n    for (var i = 0; remaining >= maxSamples; i += maxSamples) {\n        var left = samplesLeft.subarray(i, i + maxSamples);\n        var right = void 0;\n        if (samplesRight) {\n            right = samplesRight.subarray(i, i + maxSamples);\n        }\n        var mp3buf = mp3Encoder.encodeBuffer(left, right);\n        dataBuffer.push(new Int8Array(mp3buf));\n        remaining -= maxSamples;\n    }\n    var mp3Lastbuf = mp3Encoder.flush();\n    dataBuffer.push(new Int8Array(mp3Lastbuf));\n    return dataBuffer;\n}\n// Convert audioFile to arrayBuffer, because Mp3Encoder requires a parameter of ArrayBuffer type\nfunction downsampleToWav(file, callback) {\n    // Browser compatibility\n    // https://caniuse.com/?search=AudioContext\n    var audioCtx = new AudioContext({ sampleRate: VOICE_RECORDER_AUDIO_SAMPLE_RATE });\n    var fileReader = new FileReader();\n    fileReader.onload = function (ev) {\n        var _a;\n        // Decode audio\n        audioCtx.decodeAudioData((_a = ev.target) === null || _a === void 0 ? void 0 : _a.result, function (buffer) {\n            // this is where you down sample the audio, usually is 44100 samples per second\n            var usingWebkit = !window.OfflineAudioContext;\n            var offlineAudioCtx = new OfflineAudioContext(1, 16000 * buffer.duration, 16000);\n            var soundSource = offlineAudioCtx.createBufferSource();\n            soundSource.buffer = buffer;\n            soundSource.connect(offlineAudioCtx.destination);\n            var reader = new FileReader();\n            reader.onload = function () {\n                var renderCompleteHandler = function (evt) {\n                    var renderedBuffer = usingWebkit ? evt.renderedBuffer : evt;\n                    var buffer = bufferToWav(renderedBuffer, renderedBuffer.length);\n                    if (callback) {\n                        callback(buffer);\n                    }\n                };\n                if (usingWebkit) {\n                    offlineAudioCtx.oncomplete = renderCompleteHandler;\n                    offlineAudioCtx.startRendering();\n                }\n                else {\n                    offlineAudioCtx\n                        .startRendering()\n                        .then(renderCompleteHandler)\n                        // eslint-disable-next-line no-console\n                        .catch(function (err) { return console.warn(err); });\n                }\n            };\n            reader.readAsArrayBuffer(file);\n            soundSource.start(0);\n        });\n    };\n    fileReader.readAsArrayBuffer(file);\n}\nfunction bufferToWav(abuffer, len) {\n    var numOfChan = abuffer.numberOfChannels;\n    var length = len * numOfChan * 2 + 44;\n    var buffer = new ArrayBuffer(length);\n    var view = new DataView(buffer);\n    var channels = [];\n    var i = 0;\n    var sample;\n    var offset = 0;\n    var pos = 0;\n    // write WAVE header\n    setUint32(0x46464952); // \"RIFF\"\n    setUint32(length - 8); // file length - 8\n    setUint32(0x45564157); // \"WAVE\"\n    setUint32(0x20746d66); // \"fmt \" chunk\n    setUint32(16); // length = 16\n    setUint16(1); // PCM (uncompressed)\n    setUint16(numOfChan);\n    setUint32(abuffer.sampleRate);\n    setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec\n    setUint16(numOfChan * 2); // block-align\n    setUint16(16); // 16-bit (hardcoded in this demo)\n    setUint32(0x61746164); // \"data\" - chunk\n    setUint32(length - pos - 4); // chunk length\n    // write interleaved data\n    for (i = 0; i < abuffer.numberOfChannels; i++) {\n        channels.push(abuffer.getChannelData(i));\n    }\n    while (pos < length) {\n        for (i = 0; i < numOfChan; i++) {\n            // interleave channels\n            sample = Math.max(-1, Math.min(1, channels[i][offset])); // clamp\n            sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; // scale to 16-bit signed int\n            view.setInt16(pos, sample, true); // write 16-bit sample\n            pos += 2;\n        }\n        offset++; // next source sample\n    }\n    return buffer;\n    function setUint16(data) {\n        view.setUint16(pos, data, true);\n        pos += 2;\n    }\n    function setUint32(data) {\n        view.setUint32(pos, data, true);\n        pos += 4;\n    }\n}\n\nexport { downsampleToWav, encodeMp3 };\n//# sourceMappingURL=bundle-bm4u5f1K.js.map\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module"}