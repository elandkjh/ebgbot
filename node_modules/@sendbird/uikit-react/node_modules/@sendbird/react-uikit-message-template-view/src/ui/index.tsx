import React, { ReactElement } from 'react';

import {
  BasicProps,
  Box,
  ComponentsUnion,
  FlexSizeSpecValue,
  Layout,
  Text,
  TextButton,
  createMessageTemplate,
  createParser,
  createRenderer,
} from '@sendbird/uikit-message-template';

import { Carousel } from '../components/Carousel';
import ReactMessageTemplateImage from '../components/ReactMessageTemplateImage';
import { MessageContextInterface, useMessageContext } from '../context/MessageContextProvider';
import { useRecalculateWidth } from '../hook/useRecalculationSize';
import '../index.css';
import {
  ReactParsedProperties,
  getDefaultStyles,
  setAlign,
  setImageAspectRatio,
  setImageStyle,
  setTextAlign,
  setTextStyle,
  setViewProps,
  webkitLineClampStyles,
} from '../styles';

const hasValidUrlProtocol = (url = '') =>
  ['http://', 'https://', 'ftp://'].some((protocol) => url.startsWith(protocol));

/**
 * @param url - url to be checked
 * @returns url with http:// protocol if it doesn't have any protocol
 * @example
 * returnUrl('www.sendbird.com') // returns 'http://www.sendbird.com'
 * returnUrl('https://www.sendbird.com') // returns 'https://www.sendbird.com'
 * returnUrl('ftp://www.sendbird.com') // returns 'ftp://www.sendbird.com'
 * returnUrl('sendbird.com') // returns 'https://sendbird.com'
 **/
const returnUrl = (url = '') => {
  if (hasValidUrlProtocol(url)) {
    return url;
  }
  return `https://${url}`;
};

export type ActionHandlerProps = React.PropsWithChildren<{
  className: string;
  style: ReactParsedProperties | undefined;
  children: React.ReactElement | React.ReactNode;
  props: BasicProps<ComponentsUnion['properties'], ReactParsedProperties>;
  elementId?: string;
}>;

// todo: semantic html here is not perfect, need to revisit. Same for Button
const ActionHandler = ({ className = '', style, children, props }: ActionHandlerProps) => {
  const { recalculatedStyle, elemRef } = useRecalculateWidth({ style, props });
  const { message, handleWebAction, handleCustomAction, handlePredefinedAction } =
    useMessageContext() as MessageContextInterface;
  const onClick = (e: React.SyntheticEvent) => {
    if (props?.action?.type === 'web') {
      if (handleWebAction) {
        handleWebAction(e, props.action, message);
      } else {
        window?.open(returnUrl(props?.action?.data), '_blank', 'noopener noreferrer')?.focus();
      }
    }
    if (props?.action?.type === 'custom') {
      if (handleCustomAction) {
        handleCustomAction(e, props.action, message);
      } else {
        window?.open(returnUrl(props?.action?.data), '_blank', 'noopener noreferrer')?.focus();
      }
    }
    if (props?.action?.type === 'uikit') {
      handlePredefinedAction?.(e, props.action, message);
    }
  };

  const borderClass = props.viewStyle?.borderWidth ? ' sb-message-template__border' : '';

  if (className === 'sb-message-template__text-button') {
    return (
      <button
        className={`${className}${borderClass}`}
        data-sb-template-id={props.elementId}
        style={{
          ...style,
          paddingTop: props.viewStyle?.padding?.top,
          paddingRight: props.viewStyle?.padding?.right,
          paddingBottom: props.viewStyle?.padding?.bottom,
          paddingLeft: props.viewStyle?.padding?.left,
        }}
        onClick={onClick}
      >
        {children}
      </button>
    );
  }

  const { display, flexDirection, justifyContent, alignItems, objectFit, ...wrapperStyles } = recalculatedStyle;

  return (
    <div
      ref={elemRef}
      className={`${className}${borderClass} ${props?.action ? 'sb-message-template__action' : ''}`}
      data-sb-template-id={props.elementId}
      style={wrapperStyles}
      onClick={onClick}
    >
      <div
        style={{
          display,
          flexDirection,
          justifyContent,
          alignItems,
          objectFit,
          width: '100%',
          height: '100%',
          paddingTop: props.viewStyle?.padding?.top,
          paddingRight: props.viewStyle?.padding?.right,
          paddingBottom: props.viewStyle?.padding?.bottom,
          paddingLeft: props.viewStyle?.padding?.left,
        }}
      >
        {children}
      </div>
    </div>
  );
};

/**
 * Text that is fixed or fill parent should be wrapped in a div with max-width: 100% and max-height: 100%
 * This is to prevent text from overflowing the padding of the container
 */
function isFixedOrFill(view: Box | Text | TextButton) {
  const heightType = view?.height?.type;
  const widthType = view?.width?.type;
  const isFixedDiamension = heightType === 'fixed' || widthType === 'fixed';
  const isFill =
    (heightType === 'flex' && view?.height?.value === FlexSizeSpecValue.FillParent) ||
    (widthType === 'flex' && view?.width?.value === FlexSizeSpecValue.FillParent);
  return isFixedDiamension || isFill;
}

function convertNewlinesToBr(text: string) {
  return text.split('\n').map((line, index) => (
    <React.Fragment key={index}>
      {line}
      <br />
    </React.Fragment>
  ));
}

function renderText(view: Text | TextButton) {
  const { text, maxTextLines } = view;
  const isToBeWrapped = isFixedOrFill(view);
  const isMultiLine = maxTextLines != null && maxTextLines > 0;

  const convertedText = convertNewlinesToBr(text);

  if (isMultiLine || isToBeWrapped) {
    const wrapperStyling = {
      ...((isMultiLine || isToBeWrapped) && { maxWidth: '100%' }),
      ...(isToBeWrapped && { maxHeight: '100%', overflow: 'hidden' }),
    };
    return (
      <div style={wrapperStyling}>
        {isMultiLine ? <div style={webkitLineClampStyles(maxTextLines)}>{convertedText}</div> : convertedText}
      </div>
    );
  }
  return isMultiLine ? <div style={webkitLineClampStyles(maxTextLines)}>{convertedText}</div> : convertedText;
}

export const renderer = createRenderer<ReactParsedProperties>({
  views: {
    box(props) {
      return (
        <ActionHandler
          className="sb-message-template__box"
          elementId={props.elementId}
          style={props.parsedProperties}
          props={props}
        >
          {props.children}
        </ActionHandler>
      );
    },
    text(props) {
      return (
        <ActionHandler
          className="sb-message-template__text"
          elementId={props.elementId}
          style={props.parsedProperties}
          props={props}
        >
          {renderText(props)}
        </ActionHandler>
      );
    },
    image(props) {
      // todo: add image backup
      return (
        <ActionHandler
          className="sb-message-template__image-container"
          elementId={props.elementId}
          style={props.parsedProperties}
          props={props}
        >
          <ReactMessageTemplateImage
            className="sb-message-template__image"
            alt="image"
            src={props.imageUrl}
            style={{ width: '100%', height: '100%', aspectRatio: 'inherit', objectFit: 'inherit' }}
            tintColor={props.imageStyle?.tintColor}
            metaData={props.metaData}
          />
        </ActionHandler>
      );
    },
    textButton(props) {
      return (
        <ActionHandler
          className="sb-message-template__text-button"
          elementId={props.elementId}
          style={props.parsedProperties}
          props={props}
        >
          {renderText({ maxTextLines: 1, ...props })}
        </ActionHandler>
      );
    },
    imageButton(props) {
      return (
        <ActionHandler
          className="sb-message-template__image-container sb-message-template__image-button"
          elementId={props.elementId}
          style={props.parsedProperties}
          props={props}
        >
          <ReactMessageTemplateImage
            className="sb-message-template__image"
            alt="image-button"
            src={props.imageUrl}
            style={{ width: '100%', height: '100%', aspectRatio: 'inherit', objectFit: 'inherit' }}
            tintColor={props.imageStyle?.tintColor}
            metaData={props.metaData}
          />
        </ActionHandler>
      );
    },
    carouselView(props) {
      return <Carousel gap={props.spacing}>{props.children as ReactElement[]}</Carousel>;
    },
  },
});

export const parser = createParser<ReactParsedProperties>({
  mapBoxProps(props, options) {
    const styles = getDefaultStyles();

    setViewProps(styles, props, options);
    setAlign(styles, props.layout, props.align);

    return styles;
  },
  mapTextProps(props, options) {
    const styles = getDefaultStyles({ whiteSpace: 'pre-line' });

    // Better not set flex 1 to text
    setViewProps(styles, props, options);
    setTextStyle(styles, props, options);
    setAlign(styles, Layout.Row, props.align);
    setTextAlign(styles, props.align?.horizontal);

    return styles;
  },
  mapImageProps(props, options) {
    const styles = getDefaultStyles();

    setViewProps(styles, props, options);
    setImageStyle(styles, props.imageStyle);
    setImageAspectRatio(styles, props);

    return styles;
  },
  mapTextButtonProps(props, options) {
    const styles = getDefaultStyles({ whiteSpace: 'pre-line', alignItems: 'center', justifyContent: 'center' });
    setViewProps(styles, props, options);
    setTextStyle(styles, { ...props, textStyle: { weight: 500, ...props.textStyle } }, options);

    return styles;
  },
  mapImageButtonProps(props, options) {
    const styles = getDefaultStyles();

    setViewProps(styles, props, options);
    setImageStyle(styles, props.imageStyle);
    setImageAspectRatio(styles, props);

    return styles;
  },
  mapCarouselProps(props, options) {
    const styles = getDefaultStyles();
    setViewProps(styles, props, options);
    return styles;
  },
});

export const { MessageTemplate } = createMessageTemplate<ReactParsedProperties>({
  renderer,
  parser,
  Container: ({ children, className }) => {
    return (
      <div
        className={`sb-message-template__parent ${className}`}
        style={{
          display: 'flex',
          flexDirection: 'column',
          maxWidth: 400,
          marginBottom: 24,
        }}
      >
        {children}
      </div>
    );
  },
});
