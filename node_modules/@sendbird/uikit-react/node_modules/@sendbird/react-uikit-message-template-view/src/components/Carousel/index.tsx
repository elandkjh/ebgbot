import React, { ReactElement, useRef, useState } from 'react';

import type { MessageTemplateProps } from '@sendbird/uikit-message-template';

const PADDING_WIDTH = 24;
const CONTENT_LEFT_WIDTH = 40;
const SWIPE_THRESHOLD = 15;
const GAP_DEFAULT = 8;

interface ItemPosition {
  start: number;
  end: number;
}

interface CarouselItemProps {
  key: string;
  item: ReactElement;
  defaultWidth: string;
  marginRight?: number;
}

/**
 * fixed sized template items should use its child width.
 * Whereas flex sized template items should use its parent's width.
 * @param item
 */
function shouldRenderAsFixed(item: ReactElement<MessageTemplateProps>) {
  return item.props.templateItems[0].width?.type === 'fixed';
}

function CarouselItem({ item, defaultWidth, marginRight }: CarouselItemProps): ReactElement {
  const style: React.CSSProperties = shouldRenderAsFixed(item)
    ? { width: 'fit-content' }
    : { minWidth: defaultWidth, width: '100%' };
  if (marginRight) {
    style['marginRight'] = marginRight;
  }
  return <div style={style}>{item}</div>;
}

interface CarouselProps {
  children: ReactElement[];
  gap?: number;
}

interface Position {
  x: number;
  y: number;
}

interface DraggingInfo {
  scrolling: boolean;
  dragging: boolean;
  startPos: Position | null;
  offset: number;
  translateX: number;
  currentIndex: number;
}

export const Carousel = React.memo(({ children, gap = GAP_DEFAULT }: CarouselProps): ReactElement => {
  const carouselRef = useRef<HTMLDivElement>(null);
  const screenWidth = window.innerWidth;
  const defaultItemWidth = carouselRef.current?.clientWidth ?? 0;
  const itemWidths = children.map((item) => {
    if (shouldRenderAsFixed(item)) {
      return Number(item.props.templateItems[0].width?.value);
    }
    return defaultItemWidth;
  });
  const itemPositions: ItemPosition[] = getEachItemPositions();
  const [draggingInfo, setDraggingInfo] = useState<DraggingInfo>({
    scrolling: false,
    dragging: false,
    startPos: null,
    offset: 0,
    translateX: 0,
    currentIndex: 0,
  });

  const handleMouseDown = (event: React.MouseEvent<HTMLDivElement>) => {
    setDraggingInfo((props) => ({
      ...props,
      scrolling: false,
      dragging: true,
      startPos: {
        x: event.clientX,
        y: event.clientY,
      },
      offset: 0,
    }));
  };

  const handleMouseMove = (event: React.MouseEvent<HTMLDivElement>) => {
    if (!draggingInfo.dragging || !draggingInfo.startPos) return;
    const currentX = event.clientX;
    const newOffset = currentX - draggingInfo.startPos.x;
    setDraggingInfo({
      ...draggingInfo,
      offset: newOffset,
    });
  };

  const handleMouseUp = () => {
    if (!draggingInfo.dragging) return;
    handleDragEnd();
    unblockScroll();
  };

  const blockScroll = () => {
    if (carouselRef.current) {
      carouselRef.current.style.touchAction = 'pan-x';
    }
  };

  const unblockScroll = () => {
    if (carouselRef.current) {
      carouselRef.current.style.touchAction = 'pan-y';
    }
  };

  const handleTouchStart = (event: React.TouchEvent<HTMLDivElement>) => {
    setDraggingInfo((props) => ({
      ...props,
      scrolling: false,
      dragging: false,
      startPos: {
        x: event.touches[0].clientX,
        y: event.touches[0].clientY,
      },
      offset: 0,
    }));
  };

  const handleTouchMove = (event: React.TouchEvent<HTMLDivElement>) => {
    if (!draggingInfo.startPos || draggingInfo.scrolling) return;

    const startPos = draggingInfo.startPos;
    const [touchMoveX, touchMoveY] = [event.touches[0].clientX, event.touches[0].clientY];
    const [deltaX, deltaY] = [Math.abs(touchMoveX - startPos.x), Math.abs(touchMoveY - startPos.y)];
    const newOffset = touchMoveX - startPos.x;

    if (draggingInfo.dragging) {
      if (newOffset === draggingInfo.offset) return;
      setDraggingInfo((props) => ({
        ...props,
        offset: newOffset,
      }));
      return;
    }
    if (deltaY > deltaX) {
      setDraggingInfo((props) => ({
        ...props,
        scrolling: true,
      }));
    } else {
      blockScroll();
      setDraggingInfo((props) => ({
        ...props,
        dragging: true,
        offset: newOffset,
      }));
    }
  };
  const handleTouchEnd = () => {
    if (!draggingInfo.dragging) return;
    handleDragEnd();
    unblockScroll();
  };

  const getNewDraggingInfo = ({
    translateX,
    currentIndex,
    newTranslateX,
    nextIndex,
  }: DraggingInfo & {
    newTranslateX?: number;
    nextIndex?: number;
  }): DraggingInfo => {
    return {
      scrolling: false,
      dragging: false,
      startPos: null,
      offset: 0,
      translateX: newTranslateX ?? translateX,
      currentIndex: nextIndex ?? currentIndex,
    };
  };
  const handleDragEnd = () => {
    const { offset, currentIndex } = draggingInfo;
    const absOffset = Math.abs(offset);
    if (absOffset < SWIPE_THRESHOLD) {
      setDraggingInfo((props) => getNewDraggingInfo(props));
      return;
    }
    // If dragged to left, next index should be to the right
    if (offset < 0 && currentIndex < children.length - 1) {
      if (isLastItemFitsScreen(currentIndex)) {
        setDraggingInfo((props) => getNewDraggingInfo(props));
        return;
      }
      const nextIndex = currentIndex + 1;
      /**
       * This is special logic for "더 보기" button for Socar use-case.
       * The button will have a small width (less than 50px).
       * We want to include this button in the view and snap to right padding wall IFF !isLastTwoItemsFitScreen.
       */
      if (nextIndex === children.length - 1 || isLastItemFitsScreen(nextIndex)) {
        setDraggingInfo((props) =>
          getNewDraggingInfo({
            ...props,
            newTranslateX: itemPositions[children.length - 1].end - PADDING_WIDTH - CONTENT_LEFT_WIDTH + screenWidth,
            nextIndex: children.length - 1,
          }),
        );
      } else {
        setDraggingInfo((props) =>
          getNewDraggingInfo({
            ...props,
            newTranslateX: itemPositions[nextIndex].start,
            nextIndex,
          }),
        );
      }
      // If dragged to right, next index should be to the left
    } else if (offset > 0 && currentIndex > 0) {
      let nextIndex = currentIndex - 1;
      while (draggingInfo.translateX >= itemPositions[nextIndex].start) {
        nextIndex--;
      }
      setDraggingInfo((props) =>
        getNewDraggingInfo({
          ...props,
          newTranslateX: itemPositions[nextIndex].start,
          nextIndex,
        }),
      );
    } else {
      setDraggingInfo((props) => getNewDraggingInfo(props));
    }
  };

  function getCurrentTranslateX() {
    return draggingInfo.translateX + draggingInfo.offset;
  }

  function isLastItemFitsScreen(nextIndex: number) {
    const restItemsWidth = itemWidths.slice(nextIndex).reduce((prev, curr) => prev + gap + curr);
    const restTotalWidth = PADDING_WIDTH + CONTENT_LEFT_WIDTH + restItemsWidth;
    return restTotalWidth <= screenWidth;
  }

  function getEachItemPositions(): ItemPosition[] {
    let accumulator = 0;
    return itemWidths.map((itemWidth, i): ItemPosition => {
      if (i > 0) {
        accumulator -= gap;
      }
      const itemPosition = {
        start: accumulator,
        end: accumulator - itemWidth,
      };
      accumulator -= itemWidth;
      return itemPosition;
    });
  }

  return (
    <div
      ref={carouselRef}
      onMouseDown={handleMouseDown}
      onMouseMove={handleMouseMove}
      onMouseUp={handleMouseUp}
      onMouseLeave={handleMouseUp}
      onTouchStart={handleTouchStart}
      onTouchMove={handleTouchMove}
      onTouchEnd={handleTouchEnd}
      className="sb-message-template__carousel"
      style={{
        cursor: draggingInfo.dragging ? 'grabbing' : 'grab',
        transition: draggingInfo.dragging ? 'none' : 'transform 0.5s ease',
        transform: `translateX(${getCurrentTranslateX()}px)`,
      }}
    >
      {children.map((item, index) => (
        <CarouselItem
          key={index + ''}
          item={item}
          defaultWidth={defaultItemWidth + 'px'}
          marginRight={index < children.length - 1 ? gap : undefined}
        />
      ))}
    </div>
  );
});

export default Carousel;
