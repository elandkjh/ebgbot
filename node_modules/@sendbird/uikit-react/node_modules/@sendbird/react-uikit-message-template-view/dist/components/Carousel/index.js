import React, { useRef, useState } from 'react';
const PADDING_WIDTH = 24;
const CONTENT_LEFT_WIDTH = 40;
const SWIPE_THRESHOLD = 15;
const GAP_DEFAULT = 8;
/**
 * fixed sized template items should use its child width.
 * Whereas flex sized template items should use its parent's width.
 * @param item
 */
function shouldRenderAsFixed(item) {
    var _a;
    return ((_a = item.props.templateItems[0].width) === null || _a === void 0 ? void 0 : _a.type) === 'fixed';
}
function CarouselItem({ item, defaultWidth, marginRight }) {
    const style = shouldRenderAsFixed(item)
        ? { width: 'fit-content' }
        : { minWidth: defaultWidth, width: '100%' };
    if (marginRight) {
        style['marginRight'] = marginRight;
    }
    return React.createElement("div", { style: style }, item);
}
export const Carousel = React.memo(({ children, gap = GAP_DEFAULT }) => {
    var _a, _b;
    const carouselRef = useRef(null);
    const screenWidth = window.innerWidth;
    const defaultItemWidth = (_b = (_a = carouselRef.current) === null || _a === void 0 ? void 0 : _a.clientWidth) !== null && _b !== void 0 ? _b : 0;
    const itemWidths = children.map((item) => {
        var _a;
        if (shouldRenderAsFixed(item)) {
            return Number((_a = item.props.templateItems[0].width) === null || _a === void 0 ? void 0 : _a.value);
        }
        return defaultItemWidth;
    });
    const itemPositions = getEachItemPositions();
    const [draggingInfo, setDraggingInfo] = useState({
        scrolling: false,
        dragging: false,
        startPos: null,
        offset: 0,
        translateX: 0,
        currentIndex: 0,
    });
    const handleMouseDown = (event) => {
        setDraggingInfo((props) => (Object.assign(Object.assign({}, props), { scrolling: false, dragging: true, startPos: {
                x: event.clientX,
                y: event.clientY,
            }, offset: 0 })));
    };
    const handleMouseMove = (event) => {
        if (!draggingInfo.dragging || !draggingInfo.startPos)
            return;
        const currentX = event.clientX;
        const newOffset = currentX - draggingInfo.startPos.x;
        setDraggingInfo(Object.assign(Object.assign({}, draggingInfo), { offset: newOffset }));
    };
    const handleMouseUp = () => {
        if (!draggingInfo.dragging)
            return;
        handleDragEnd();
        unblockScroll();
    };
    const blockScroll = () => {
        if (carouselRef.current) {
            carouselRef.current.style.touchAction = 'pan-x';
        }
    };
    const unblockScroll = () => {
        if (carouselRef.current) {
            carouselRef.current.style.touchAction = 'pan-y';
        }
    };
    const handleTouchStart = (event) => {
        setDraggingInfo((props) => (Object.assign(Object.assign({}, props), { scrolling: false, dragging: false, startPos: {
                x: event.touches[0].clientX,
                y: event.touches[0].clientY,
            }, offset: 0 })));
    };
    const handleTouchMove = (event) => {
        if (!draggingInfo.startPos || draggingInfo.scrolling)
            return;
        const startPos = draggingInfo.startPos;
        const [touchMoveX, touchMoveY] = [event.touches[0].clientX, event.touches[0].clientY];
        const [deltaX, deltaY] = [Math.abs(touchMoveX - startPos.x), Math.abs(touchMoveY - startPos.y)];
        const newOffset = touchMoveX - startPos.x;
        if (draggingInfo.dragging) {
            if (newOffset === draggingInfo.offset)
                return;
            setDraggingInfo((props) => (Object.assign(Object.assign({}, props), { offset: newOffset })));
            return;
        }
        if (deltaY > deltaX) {
            setDraggingInfo((props) => (Object.assign(Object.assign({}, props), { scrolling: true })));
        }
        else {
            blockScroll();
            setDraggingInfo((props) => (Object.assign(Object.assign({}, props), { dragging: true, offset: newOffset })));
        }
    };
    const handleTouchEnd = () => {
        if (!draggingInfo.dragging)
            return;
        handleDragEnd();
        unblockScroll();
    };
    const getNewDraggingInfo = ({ translateX, currentIndex, newTranslateX, nextIndex, }) => {
        return {
            scrolling: false,
            dragging: false,
            startPos: null,
            offset: 0,
            translateX: newTranslateX !== null && newTranslateX !== void 0 ? newTranslateX : translateX,
            currentIndex: nextIndex !== null && nextIndex !== void 0 ? nextIndex : currentIndex,
        };
    };
    const handleDragEnd = () => {
        const { offset, currentIndex } = draggingInfo;
        const absOffset = Math.abs(offset);
        if (absOffset < SWIPE_THRESHOLD) {
            setDraggingInfo((props) => getNewDraggingInfo(props));
            return;
        }
        // If dragged to left, next index should be to the right
        if (offset < 0 && currentIndex < children.length - 1) {
            if (isLastItemFitsScreen(currentIndex)) {
                setDraggingInfo((props) => getNewDraggingInfo(props));
                return;
            }
            const nextIndex = currentIndex + 1;
            /**
             * This is special logic for "더 보기" button for Socar use-case.
             * The button will have a small width (less than 50px).
             * We want to include this button in the view and snap to right padding wall IFF !isLastTwoItemsFitScreen.
             */
            if (nextIndex === children.length - 1 || isLastItemFitsScreen(nextIndex)) {
                setDraggingInfo((props) => getNewDraggingInfo(Object.assign(Object.assign({}, props), { newTranslateX: itemPositions[children.length - 1].end - PADDING_WIDTH - CONTENT_LEFT_WIDTH + screenWidth, nextIndex: children.length - 1 })));
            }
            else {
                setDraggingInfo((props) => getNewDraggingInfo(Object.assign(Object.assign({}, props), { newTranslateX: itemPositions[nextIndex].start, nextIndex })));
            }
            // If dragged to right, next index should be to the left
        }
        else if (offset > 0 && currentIndex > 0) {
            let nextIndex = currentIndex - 1;
            while (draggingInfo.translateX >= itemPositions[nextIndex].start) {
                nextIndex--;
            }
            setDraggingInfo((props) => getNewDraggingInfo(Object.assign(Object.assign({}, props), { newTranslateX: itemPositions[nextIndex].start, nextIndex })));
        }
        else {
            setDraggingInfo((props) => getNewDraggingInfo(props));
        }
    };
    function getCurrentTranslateX() {
        return draggingInfo.translateX + draggingInfo.offset;
    }
    function isLastItemFitsScreen(nextIndex) {
        const restItemsWidth = itemWidths.slice(nextIndex).reduce((prev, curr) => prev + gap + curr);
        const restTotalWidth = PADDING_WIDTH + CONTENT_LEFT_WIDTH + restItemsWidth;
        return restTotalWidth <= screenWidth;
    }
    function getEachItemPositions() {
        let accumulator = 0;
        return itemWidths.map((itemWidth, i) => {
            if (i > 0) {
                accumulator -= gap;
            }
            const itemPosition = {
                start: accumulator,
                end: accumulator - itemWidth,
            };
            accumulator -= itemWidth;
            return itemPosition;
        });
    }
    return (React.createElement("div", { ref: carouselRef, onMouseDown: handleMouseDown, onMouseMove: handleMouseMove, onMouseUp: handleMouseUp, onMouseLeave: handleMouseUp, onTouchStart: handleTouchStart, onTouchMove: handleTouchMove, onTouchEnd: handleTouchEnd, className: "sb-message-template__carousel", style: {
            cursor: draggingInfo.dragging ? 'grabbing' : 'grab',
            transition: draggingInfo.dragging ? 'none' : 'transform 0.5s ease',
            transform: `translateX(${getCurrentTranslateX()}px)`,
        } }, children.map((item, index) => (React.createElement(CarouselItem, { key: index + '', item: item, defaultWidth: defaultItemWidth + 'px', marginRight: index < children.length - 1 ? gap : undefined })))));
});
export default Carousel;
