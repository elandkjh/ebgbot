import React, { type ReactElement } from 'react';

import { SizeContextProvider } from '../context/SizeProvider';
import { BasicProps, ComponentType, ComponentsUnion } from '../types/components';
import { CompositeComponentType } from '../types/components';
import type { Layout } from '../types/styles';
import type { Template } from '../types/template';
import { SUPPORTED_TEMPLATE_VERSIONS, isTemplateVersionSupported } from '../utils';
import { setTemplateItemId } from '../utils/templateItemId';
import { defaultProperties } from './defaultValues';
import { Parser, createParser } from './parser';
import { Renderer, createRenderer } from './renderer';

interface ContainerProps extends React.PropsWithChildren<unknown> {
  className: string;
}

interface MessageTemplateOptions<ParsedProperties> {
  parser?: Parser<ParsedProperties>;
  renderer?: Renderer<ParsedProperties>;
  Container?: (props: ContainerProps) => React.ReactElement;
  UnknownMessage?: (props: { item: ComponentsUnion['properties'] }) => React.ReactElement | null;
}

export interface MessageTemplateProps {
  templateItems: Template['body']['items'];
  templateVersion?: Template['version']; // Made optional for backward compatibility.
  parentLayout?: Layout;
  isRoot?: boolean;
}

export const createMessageTemplate = <T,>(opts: MessageTemplateOptions<T>) => {
  const Container = opts.Container || React.Fragment;
  const UnknownMessage = opts.UnknownMessage || (() => null);

  const parser = opts.parser || createParser<T>();
  const renderer = opts.renderer || createRenderer<T>();

  const MessageTemplateBase = ({
    templateItems,
    parentLayout = defaultProperties.box.layout,
    isRoot = false,
  }: MessageTemplateProps) => {
    const renderItems = templateItems;

    return (
      <React.Fragment>
        {renderItems.map((item, index, siblings) => {
          const { properties } = parser.parse(item, { parentLayout, elemIdx: index, siblings });
          const props: BasicProps<unknown, T> = {
            key: index,
            parentLayout,
            parsedProperties: properties,
            siblings,
          };

          switch (item.type) {
            // CompositeComponent should be top level component
            case CompositeComponentType.Carousel: {
              if (!isRoot) {
                throw new Error('Cannot parse template item as Carousel if the template item is not the root.');
              }
              if (!item.items || !Array.isArray(item.items) || item.items.length === 0) {
                throw new Error('Cannot parse template item as Carousel if carousel has no items.');
              }
              return (
                <renderer.carouselView {...item} {...props}>
                  {
                    item.items.map((items, index) => (
                      <MessageTemplateBase key={index} templateItems={items || []} parentLayout={parentLayout} />
                    )) as ReactElement[]
                  }
                </renderer.carouselView>
              );
            }
            case ComponentType.Box: {
              return (
                <renderer.box {...item} {...props}>
                  <MessageTemplateBase templateItems={item.items || []} parentLayout={item.layout} />
                </renderer.box>
              );
            }

            case ComponentType.Text: {
              return <renderer.text {...item} {...props} />;
            }

            case ComponentType.Image: {
              return <renderer.image {...item} {...props} />;
            }

            case ComponentType.TextButton: {
              return <renderer.textButton {...item} {...props} />;
            }

            case ComponentType.ImageButton: {
              return <renderer.imageButton {...item} {...props} />;
            }

            default: {
              // or throw new Error('Cannot parse template item')
              return <UnknownMessage item={item} />;
            }
          }
        })}
      </React.Fragment>
    );
  };

  return {
    MessageTemplate: ({
      parentLayout = defaultProperties.rootLayout,
      templateVersion,
      templateItems,
    }: MessageTemplateProps) => {
      const items = setTemplateItemId(templateItems);
      if (!isTemplateVersionSupported(templateVersion)) {
        /**
         * I choose to throw instead of returning UnknownMessage because UnknownMessage syntax (required prop: item) is not what UIKit wants.
         */
        throw new Error(
          `Cannot parse template item due to unsupported template version: ${templateVersion}, ${SUPPORTED_TEMPLATE_VERSIONS}`,
        );
      }
      let isCarousel = false;
      if (Array.isArray(items) && items.length > 0) {
        isCarousel = items[0].type === CompositeComponentType.Carousel;
      }
      return (
        <SizeContextProvider>
          <Container className={isCarousel ? 'sb-message-template__parent_for_carousel' : ''}>
            <MessageTemplateBase parentLayout={parentLayout} templateItems={items} isRoot={true} />
          </Container>
        </SizeContextProvider>
      );
    },
    MessageTemplateBase,
  };
};
